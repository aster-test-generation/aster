/**
 * Generated by Aster
 */
package org.apache.commons.jxpath.ri.compiler;

import java.util.Collection;
import java.util.concurrent.TimeUnit;
import org.apache.commons.jxpath.BasicNodeSet;
import org.apache.commons.jxpath.JXPathContext;
import org.apache.commons.jxpath.NodeSet;
import org.apache.commons.jxpath.ri.Compiler;
import org.apache.commons.jxpath.ri.EvalContext;
import org.apache.commons.jxpath.ri.InfoSetUtil;
import org.apache.commons.jxpath.ri.QName;
import org.apache.commons.jxpath.ri.axes.NodeSetContext;
import org.apache.commons.jxpath.ri.model.NodePointer;
import org.junit.jupiter.api.Assertions;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.Timeout;
import org.junit.jupiter.api.Timeout.ThreadMode;
import org.junit.jupiter.api.extension.ExtendWith;
import org.mockito.Mockito;
import org.mockito.junit.jupiter.MockitoExtension;
import org.mockito.junit.jupiter.MockitoSettings;
import org.mockito.quality.Strictness;

import static org.junit.jupiter.api.Assertions.*;
import static org.junit.jupiter.api.Timeout.ThreadMode.SEPARATE_THREAD;
import static org.mockito.Mockito.*;

@ExtendWith(MockitoExtension.class)
@MockitoSettings(strictness = Strictness.LENIENT)
public class Aster_CoreFunction_Test_Failing {
    CoreFunction corefunction;
    EvalContext evalContext;
    JXPathContext jxpathContext;
    NodePointer nodePointer;
    Expression arg1;
    private int functionCode = Compiler.FUNCTION_LAST;
    private CoreFunction coreFunction;
    EvalContext context;
    Expression arg2;
    Expression[] args;
    EvalContext ctx;
    Expression arg3;
    NodeSet nodeSet;
    BasicNodeSet basicNodeSet;

    @Test
    @Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testfunctionName_noArguments() throws Exception {
        evalContext = Mockito.mock(EvalContext.class);
        nodePointer = Mockito.mock(NodePointer.class);
        arg1 = Mockito.mock(Expression.class);
        coreFunction = new CoreFunction(1, new Expression[]{arg1});
        Mockito.when(coreFunction.getArgumentCount()).thenReturn(0);
        Mockito.when(evalContext.getCurrentNodePointer()).thenReturn(nodePointer);
        Mockito.when(nodePointer.getName()).thenReturn(Mockito.mock(QName.class));
        String result = (String) coreFunction.functionName(evalContext);
        assertNotNull(result);
    }

    @Test
    @Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testfunctionName_oneArgument() throws Exception {
        evalContext = Mockito.mock(EvalContext.class);
        nodePointer = Mockito.mock(NodePointer.class);
        arg1 = Mockito.mock(Expression.class);
        coreFunction = new CoreFunction(1, new Expression[]{arg1});
        Mockito.when(coreFunction.getArgumentCount()).thenReturn(1);
        Mockito.when(coreFunction.getArg1()).thenReturn(arg1);
        Mockito.when(arg1.compute(evalContext)).thenReturn(evalContext);
        Mockito.when(evalContext.hasNext()).thenReturn(true);
        Mockito.when(evalContext.next()).thenReturn(nodePointer);
        Mockito.when(nodePointer.getName()).thenReturn(Mockito.mock(QName.class));
        String result = (String) coreFunction.functionName(evalContext);
        assertNotNull(result);
    }

    @Test
    @Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testfunctionName_oneArgument_noNext() throws Exception {
        evalContext = Mockito.mock(EvalContext.class);
        nodePointer = Mockito.mock(NodePointer.class);
        arg1 = Mockito.mock(Expression.class);
        coreFunction = new CoreFunction(1, new Expression[]{arg1});
        Mockito.when(coreFunction.getArgumentCount()).thenReturn(1);
        Mockito.when(coreFunction.getArg1()).thenReturn(arg1);
        Mockito.when(arg1.compute(evalContext)).thenReturn(evalContext);
        Mockito.when(evalContext.hasNext()).thenReturn(false);
        String result = (String) coreFunction.functionName(evalContext);
        assertEquals("", result);
    }

    @Test
    @Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testfunctionLang() throws Exception {
        coreFunction = new CoreFunction(1, new Expression[]{});
        evalContext = mock(EvalContext.class);
        nodePointer = mock(NodePointer.class);
        arg1 = mock(Expression.class);
        when(coreFunction.getArg1()).thenReturn(arg1);
        when(arg1.computeValue(evalContext)).thenReturn("en-US");
        when(evalContext.getSingleNodePointer()).thenReturn(nodePointer);
        when(nodePointer.isLanguage("en-US")).thenReturn(true);
        Object result = coreFunction.functionLang(evalContext);
        assertEquals(Boolean.TRUE, result);
    }

    @Test
    @Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testfunctionLang_nullPointer() throws Exception {
        coreFunction = new CoreFunction(1, new Expression[]{});
        evalContext = mock(EvalContext.class);
        nodePointer = mock(NodePointer.class);
        arg1 = mock(Expression.class);
        when(coreFunction.getArg1()).thenReturn(arg1);
        when(arg1.computeValue(evalContext)).thenReturn("en-US");
        when(evalContext.getSingleNodePointer()).thenReturn(null);
        Object result = coreFunction.functionLang(evalContext);
        assertEquals(Boolean.FALSE, result);
    }

    @Test
    @Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testfunctionLang_invalidLang() throws Exception {
        coreFunction = new CoreFunction(1, new Expression[]{});
        evalContext = mock(EvalContext.class);
        nodePointer = mock(NodePointer.class);
        arg1 = mock(Expression.class);
        when(coreFunction.getArg1()).thenReturn(arg1);
        when(arg1.computeValue(evalContext)).thenReturn("en-US");
        when(evalContext.getSingleNodePointer()).thenReturn(nodePointer);
        when(nodePointer.isLanguage("en-US")).thenReturn(false);
        Object result = coreFunction.functionLang(evalContext);
        assertEquals(Boolean.FALSE, result);
    }

    @Test
    @Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testfunctionNot_1() throws Exception {
        arg1 = mock(Expression.class);
        context = mock(EvalContext.class);
        coreFunction = new CoreFunction(1, new Expression[]{arg1});
        // given
        when(arg1.computeValue(context)).thenReturn(Boolean.TRUE);
        // when
        Object result = coreFunction.functionNot(context);
        // then
        // given
        when(arg1.computeValue(context)).thenReturn(Boolean.FALSE);
        // when
        result = coreFunction.functionNot(context);
        // then
        assertEquals(Boolean.FALSE, result);
    }

    @Test
    @Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testfunctionCount_NodePointer() throws Exception {
        coreFunction = new CoreFunction(1, new Expression[]{});
        evalContext = mock(EvalContext.class);
        arg1 = mock(Expression.class);
        nodePointer = mock(NodePointer.class);
        ctx = mock(EvalContext.class);
        when(arg1.compute(evalContext)).thenReturn(nodePointer);
        when(nodePointer.getValue()).thenReturn(ctx);
        when(ctx.hasNext()).thenReturn(true, false);
        when(ctx.next()).thenReturn(true);
        Object result = coreFunction.functionCount(evalContext);
        assertEquals(1.0, result);
    }

    @Test
    @Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testfunctionCount_Collection() throws Exception {
        coreFunction = new CoreFunction(1, new Expression[]{});
        evalContext = mock(EvalContext.class);
        arg1 = mock(Expression.class);
        nodePointer = mock(NodePointer.class);
        ctx = mock(EvalContext.class);
        Collection collection = mock(Collection.class);
        when(arg1.compute(evalContext)).thenReturn(collection);
        when(collection.size()).thenReturn(5);
        Object result = coreFunction.functionCount(evalContext);
        assertEquals(5.0, result);
    }

    @Test
    @Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testfunctionCount_Null() throws Exception {
        coreFunction = new CoreFunction(1, new Expression[]{});
        evalContext = mock(EvalContext.class);
        arg1 = mock(Expression.class);
        nodePointer = mock(NodePointer.class);
        ctx = mock(EvalContext.class);
        when(arg1.compute(evalContext)).thenReturn(null);
        Object result = coreFunction.functionCount(evalContext);
        assertEquals(0.0, result);
    }

    @Test
    @Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testfunctionCount_Other() throws Exception {
        coreFunction = new CoreFunction(1, new Expression[]{});
        evalContext = mock(EvalContext.class);
        arg1 = mock(Expression.class);
        nodePointer = mock(NodePointer.class);
        ctx = mock(EvalContext.class);
        Object obj = new Object();
        when(arg1.compute(evalContext)).thenReturn(obj);
        Object result = coreFunction.functionCount(evalContext);
        assertEquals(1.0, result);
    }

    @Test
    @Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testfunctionKey_3() throws Exception {
        arg1 = mock(Expression.class);
        arg2 = mock(Expression.class);
        context = mock(EvalContext.class);
        jxpathContext = mock(JXPathContext.class);
        nodeSet = mock(NodeSet.class);
        nodePointer = mock(NodePointer.class);
        basicNodeSet = new BasicNodeSet();
        coreFunction = new CoreFunction(1, new Expression[]{arg1, arg2});
        // given
        when(arg1.computeValue(context)).thenReturn("key");
        when(arg2.compute(context)).thenReturn(nodePointer);
        when(context.getJXPathContext()).thenReturn(jxpathContext);
        when(jxpathContext.getNodeSetByKey("key", nodePointer.getValue())).thenReturn(nodeSet);
        when(nodePointer.getValue()).thenReturn("value");
        // when
        Object result = coreFunction.functionKey(context);
        // then
        NodeSetContext nodeSetContext = (NodeSetContext) result;
        assertNull(nodeSet);
    }

    @Test
    @Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testComputeValue_2() throws Exception {
        evalContext = Mockito.mock(EvalContext.class);
        coreFunction = new CoreFunction(functionCode, new Expression[0]);
        // mock the behavior of evalContext
        Mockito.when(evalContext.getPosition()).thenReturn(1);
        // call the method under test
        Object result = coreFunction.computeValue(evalContext);
        // assert the result
        assertEquals(Integer.valueOf(1), result);
    }

    @Test
    @Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testfunctionNamespaceURI_noArguments_fid1() throws Exception {
        context = mock(EvalContext.class);
        nodePointer = mock(NodePointer.class);
        arg1 = mock(Expression.class);
        corefunction = new CoreFunction(0, new Expression[]{arg1});
        when(context.getCurrentNodePointer()).thenReturn(nodePointer);
        when(nodePointer.getNamespaceURI()).thenReturn("namespace-uri");
        Object result = corefunction.functionNamespaceURI(context);
        assertEquals("namespace-uri", result);
    }

    @Test
    @Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testfunctionKey_3_fid1() throws Exception {
        arg1 = mock(Expression.class);
        arg2 = mock(Expression.class);
        context = mock(EvalContext.class);
        jxpathContext = mock(JXPathContext.class);
        nodeSet = mock(NodeSet.class);
        nodePointer = mock(NodePointer.class);
        basicNodeSet = new BasicNodeSet();
        coreFunction = new CoreFunction(1, new Expression[]{arg1, arg2});
        // given
        when(arg1.computeValue(context)).thenReturn("key");
        when(arg2.compute(context)).thenReturn(nodePointer);
        when(context.getJXPathContext()).thenReturn(jxpathContext);
        when(jxpathContext.getNodeSetByKey("key", nodePointer.getValue())).thenReturn(nodeSet);
        when(nodePointer.getValue()).thenReturn("value");
        // when
        Object result = coreFunction.functionKey(context);
        // then
        NodeSetContext nodeSetContext = (NodeSetContext) result;
        assertEquals(nodeSet, nodeSetContext.getNodeSet());
    }

    @Test
    @Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testfunctionCeiling_1() throws Exception {
        arg1 = mock(Expression.class);
        context = mock(EvalContext.class);
        coreFunction = new CoreFunction(1, new Expression[]{arg1});
        // Test case 1: NaN value
        when(arg1.computeValue(context)).thenReturn(Double.NaN);
        // Test case 2: Infinite value
        when(arg1.computeValue(context)).thenReturn(Double.POSITIVE_INFINITY);
        // Test case 3: Normal value
        when(arg1.computeValue(context)).thenReturn(1.5);
        assertEquals(Double.valueOf(Double.NaN), coreFunction.functionCeiling(context));
    }

    @Test
    @Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testfunctionCeiling_2() throws Exception {
        arg1 = mock(Expression.class);
        context = mock(EvalContext.class);
        coreFunction = new CoreFunction(1, new Expression[]{arg1});
        // Test case 1: NaN value
        when(arg1.computeValue(context)).thenReturn(Double.NaN);
        // Test case 2: Infinite value
        when(arg1.computeValue(context)).thenReturn(Double.POSITIVE_INFINITY);
        // Test case 3: Normal value
        when(arg1.computeValue(context)).thenReturn(1.5);
        assertEquals(Double.valueOf(Double.POSITIVE_INFINITY), coreFunction.functionCeiling(context));
    }

    @Test
    @Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testfunctionLocalName_noArguments_1() throws Exception {
        coreFunction = new CoreFunction(0, new Expression[0]);
        context = mock(EvalContext.class);
        nodePointer = mock(NodePointer.class);
        arg1 = mock(Expression.class);
        when(context.getCurrentNodePointer()).thenReturn(nodePointer);
        when(nodePointer.getName()).thenReturn(mock(QName.class));
        Object result = coreFunction.functionLocalName(context);
        assertNotNull(result);
    }

    @Test
    @Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testComputeValue() throws Exception {
        evalContext = Mockito.mock(EvalContext.class);
        coreFunction = new CoreFunction(functionCode, new Expression[0]);
        // mock the behavior of evalContext
        Mockito.when(evalContext.getPosition()).thenReturn(1);
        // call the method under test
        Object result = coreFunction.computeValue(evalContext);
        // assert the result
        assertNotNull(result);
        assertEquals(Integer.valueOf(1), result);
    }

    @Test
    @Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testfunctionKey() throws Exception {
        arg1 = mock(Expression.class);
        arg2 = mock(Expression.class);
        context = mock(EvalContext.class);
        jxpathContext = mock(JXPathContext.class);
        nodeSet = mock(NodeSet.class);
        nodePointer = mock(NodePointer.class);
        basicNodeSet = new BasicNodeSet();
        coreFunction = new CoreFunction(1, new Expression[]{arg1, arg2});
        // given
        when(arg1.computeValue(context)).thenReturn("key");
        when(arg2.compute(context)).thenReturn(nodePointer);
        when(context.getJXPathContext()).thenReturn(jxpathContext);
        when(jxpathContext.getNodeSetByKey("key", nodePointer.getValue())).thenReturn(nodeSet);
        when(nodePointer.getValue()).thenReturn("value");
        // when
        Object result = coreFunction.functionKey(context);
        // then
        assertNotNull(result);
        assertTrue(result instanceof NodeSetContext);
        NodeSetContext nodeSetContext = (NodeSetContext) result;
        assertEquals(nodeSet, nodeSetContext.getNodeSet());
    }

    @Test
    @Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testfunctionLocalName_noArguments() throws Exception {
        coreFunction = new CoreFunction(0, new Expression[0]);
        context = mock(EvalContext.class);
        nodePointer = mock(NodePointer.class);
        arg1 = mock(Expression.class);
        when(context.getCurrentNodePointer()).thenReturn(nodePointer);
        when(nodePointer.getName()).thenReturn(mock(QName.class));
        Object result = coreFunction.functionLocalName(context);
        assertNotNull(result);
        assertEquals("expected name", result); // adjust the expected name
    }

    @Test
    @Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testfunctionLocalName_oneArgument() throws Exception {
        coreFunction = new CoreFunction(0, new Expression[0]);
        context = mock(EvalContext.class);
        nodePointer = mock(NodePointer.class);
        arg1 = mock(Expression.class);
        coreFunction = new CoreFunction(0, new Expression[]{arg1});
        when(arg1.compute(context)).thenReturn(context);
        when(context.hasNext()).thenReturn(true);
        when(context.next()).thenReturn(nodePointer);
        when(nodePointer.getName()).thenReturn(mock(QName.class));
        Object result = coreFunction.functionLocalName(context);
        assertNotNull(result);
        assertEquals("expected name", result); // adjust the expected name
    }

    @Test
    @Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testfunctionNormalizeSpace() throws Exception {
        arg1 = mock(Expression.class);
        context = mock(EvalContext.class);
        coreFunction = new CoreFunction(1, new Expression[]{arg1});
        // given
        when(arg1.computeValue(context)).thenReturn("   hello   world  ");
        when(InfoSetUtil.stringValue("   hello   world  ")).thenReturn("   hello   world  ");
        // when
        Object result = coreFunction.functionNormalizeSpace(context);
        // then
        assertEquals("hello world", result);
    }

    @Test
    @Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testToString_NoArguments_vveY0() {
        CoreFunction coreFunction = new CoreFunction(1, new Expression[0]);
        assertEquals("functionName()", coreFunction.toString());
    }

    @Test
    @Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testToString_NullArguments_jFvC3() {
        CoreFunction coreFunction = new CoreFunction(1, null);
        assertEquals("functionName()", coreFunction.toString());
    }

    @Test
    @Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testfunctionString_noArguments() throws Exception {
        context = mock(EvalContext.class);
        arg1 = mock(Expression.class);
        nodePointer = mock(NodePointer.class);
        corefunction = new CoreFunction(0, new Expression[]{arg1});
        when(corefunction.getArgumentCount()).thenReturn(0);
        when(context.getCurrentNodePointer()).thenReturn(nodePointer);
        when(InfoSetUtil.stringValue(nodePointer)).thenReturn("nodePointerString");
        String result = (String) corefunction.functionString(context);
        assertEquals("nodePointerString", result);
        verify(context).getCurrentNodePointer();
    }

    @Test
    @Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testfunctionString_oneArgument() throws Exception {
        context = mock(EvalContext.class);
        arg1 = mock(Expression.class);
        nodePointer = mock(NodePointer.class);
        corefunction = new CoreFunction(0, new Expression[]{arg1});
        when(corefunction.getArgumentCount()).thenReturn(1);
        when(corefunction.getArg1()).thenReturn(arg1);
        when(arg1.computeValue(context)).thenReturn(nodePointer);
        when(InfoSetUtil.stringValue(nodePointer)).thenReturn("nodePointerString");
        String result = (String) corefunction.functionString(context);
        assertEquals("nodePointerString", result);
        verify(arg1).computeValue(context);
    }

    @Test
    @Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testfunctionSubstringAfter() throws Exception {
        coreFunction = new CoreFunction(0, new Expression[2]);
        context = mock(EvalContext.class);
        arg1 = mock(Expression.class);
        arg2 = mock(Expression.class);
        when(coreFunction.getArg1()).thenReturn(arg1);
        when(coreFunction.getArg2()).thenReturn(arg2);
        coreFunction = new CoreFunction(0, new Expression[2]);
        context = mock(EvalContext.class);
        arg1 = mock(Expression.class);
        arg2 = mock(Expression.class);
        when(coreFunction.getArg1()).thenReturn(arg1);
        when(coreFunction.getArg2()).thenReturn(arg2);
        // given
        when(arg1.computeValue(context)).thenReturn("hello world");
        when(arg2.computeValue(context)).thenReturn("world");
        // when
        Object result = coreFunction.functionSubstringAfter(context);
        // then
        assertEquals("", result);
    }

    @Test
    @Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testfunctionSubstringAfter_notFound() throws Exception {
        coreFunction = new CoreFunction(0, new Expression[2]);
        context = mock(EvalContext.class);
        arg1 = mock(Expression.class);
        arg2 = mock(Expression.class);
        when(coreFunction.getArg1()).thenReturn(arg1);
        when(coreFunction.getArg2()).thenReturn(arg2);
        // given
        when(arg1.computeValue(context)).thenReturn("hello world");
        when(arg2.computeValue(context)).thenReturn("foo");
        // when
        Object result = coreFunction.functionSubstringAfter(context);
        // then
        assertEquals("", result);
    }

    @Test
    @Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testCompute() throws Exception {
        args = new Expression[0]; // no arguments for simplicity
        coreFunction = new CoreFunction(functionCode, args);
        evalContext = Mockito.mock(EvalContext.class);
        // given
        Object expectedResult = "some result";
        Mockito.when(evalContext.getValue()).thenReturn(expectedResult);
        // when
        Object result = coreFunction.compute(evalContext);
        // then
        Assertions.assertEquals(expectedResult, result);
        Mockito.verify(evalContext).getValue();
    }

    @Test
    @Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testfunctionFloor() throws Exception {
        coreFunction = new CoreFunction(1, new Expression[]{});
        context = mock(EvalContext.class);
        arg1 = mock(Expression.class);
        when(coreFunction.getArg1()).thenReturn(arg1);
        // Test case 1: NaN value
        when(arg1.computeValue(context)).thenReturn(Double.NaN);
        assertEquals(Double.NaN, ((Double) coreFunction.functionFloor(context)).doubleValue(), 0.0);
        // Test case 2: Infinite value
        when(arg1.computeValue(context)).thenReturn(Double.POSITIVE_INFINITY);
        assertEquals(Double.POSITIVE_INFINITY, ((Double) coreFunction.functionFloor(context)).doubleValue(), 0.0);
        // Test case 3: Normal value
        when(arg1.computeValue(context)).thenReturn(3.7);
        assertEquals(3.0, ((Double) coreFunction.functionFloor(context)).doubleValue(), 0.0);
    }

    @Test
    @Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testfunctionNumber_noArguments() throws Exception {
        context = mock(EvalContext.class);
        arg1 = mock(Expression.class);
        nodePointer = mock(NodePointer.class);
        corefunction = new CoreFunction(1, new Expression[]{arg1});
        when(corefunction.getArgumentCount()).thenReturn(0);
        when(context.getCurrentNodePointer()).thenReturn(nodePointer);
        when(InfoSetUtil.number(nodePointer)).thenReturn(10.0);
        Object result = corefunction.functionNumber(context);
        assertEquals(10.0, result);
    }

    @Test
    @Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testfunctionNumber_oneArgument() throws Exception {
        context = mock(EvalContext.class);
        arg1 = mock(Expression.class);
        nodePointer = mock(NodePointer.class);
        corefunction = new CoreFunction(1, new Expression[]{arg1});
        when(corefunction.getArgumentCount()).thenReturn(1);
        when(corefunction.getArg1()).thenReturn(arg1);
        when(arg1.computeValue(context)).thenReturn(nodePointer);
        when(InfoSetUtil.number(nodePointer)).thenReturn(20.0);
        Object result = corefunction.functionNumber(context);
        assertEquals(20.0, result);
    }

    @Test
    @Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testfunctionSubstring() throws Exception {
        coreFunction = new CoreFunction(1, new Expression[3]);
        context = mock(EvalContext.class);
        arg1 = mock(Expression.class);
        arg2 = mock(Expression.class);
        arg3 = mock(Expression.class);
        when(coreFunction.getArg1()).thenReturn(arg1);
        when(coreFunction.getArg2()).thenReturn(arg2);
        when(coreFunction.getArg3()).thenReturn(arg3);
        // Test case 1: 2 arguments
        when(arg1.computeValue(context)).thenReturn("hello");
        when(arg2.computeValue(context)).thenReturn(2.0);
        assertEquals("ell", coreFunction.functionSubstring(context));
        // Test case 2: 3 arguments
        when(arg1.computeValue(context)).thenReturn("hello");
        when(arg2.computeValue(context)).thenReturn(2.0);
        when(arg3.computeValue(context)).thenReturn(3.0);
        assertEquals("ell", coreFunction.functionSubstring(context));
        // Test case 3: from is NaN
        when(arg1.computeValue(context)).thenReturn("hello");
        when(arg2.computeValue(context)).thenReturn(Double.NaN);
        assertEquals("", coreFunction.functionSubstring(context));
        // Test case 4: from is greater than string length
        when(arg1.computeValue(context)).thenReturn("hello");
        when(arg2.computeValue(context)).thenReturn(10.0);
        assertEquals("", coreFunction.functionSubstring(context));
        // Test case 5: length is negative
        when(arg1.computeValue(context)).thenReturn("hello");
        when(arg2.computeValue(context)).thenReturn(2.0);
        when(arg3.computeValue(context)).thenReturn(-1.0);
        assertEquals("", coreFunction.functionSubstring(context));
    }

    @Test
    @Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testComputeContextDependent3_XFZR2() {
        CoreFunction coreFunction = new CoreFunction(Compiler.FUNCTION_FORMAT_NUMBER, new Expression[2]);
        assertTrue(coreFunction.computeContextDependent());
    }

    @Test
    @Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testComputeContextDependent4_xPkF3() {
        CoreFunction coreFunction = new CoreFunction(Compiler.FUNCTION_COUNT, new Expression[1]);
        assertFalse(coreFunction.computeContextDependent());
    }

    @Test
    @Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testComputeContextDependent5_VVOB4() {
        CoreFunction coreFunction = new CoreFunction(Compiler.FUNCTION_CONCAT, new Expression[2]);
        assertFalse(coreFunction.computeContextDependent());
    }

    @Test
    @Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testComputeContextDependent6_lBtA5() {
        CoreFunction coreFunction = new CoreFunction(Compiler.FUNCTION_TRUE, null);
        assertTrue(coreFunction.computeContextDependent());
    }
}