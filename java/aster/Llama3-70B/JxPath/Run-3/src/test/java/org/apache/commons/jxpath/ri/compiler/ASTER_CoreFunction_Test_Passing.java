/**
 * Generated by Aster
 */
package org.apache.commons.jxpath.ri.compiler;

import java.util.concurrent.TimeUnit;
import org.apache.commons.jxpath.BasicNodeSet;
import org.apache.commons.jxpath.JXPathContext;
import org.apache.commons.jxpath.NodeSet;
import org.apache.commons.jxpath.ri.Compiler;
import org.apache.commons.jxpath.ri.EvalContext;
import org.apache.commons.jxpath.ri.InfoSetUtil;
import org.apache.commons.jxpath.ri.axes.NodeSetContext;
import org.apache.commons.jxpath.ri.model.NodePointer;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.Timeout;
import org.junit.jupiter.api.Timeout.ThreadMode;
import org.junit.jupiter.api.extension.ExtendWith;
import org.mockito.Mockito;
import org.mockito.junit.jupiter.MockitoExtension;
import org.mockito.junit.jupiter.MockitoSettings;
import org.mockito.quality.Strictness;

import static org.junit.jupiter.api.Assertions.*;
import static org.junit.jupiter.api.Timeout.ThreadMode.SEPARATE_THREAD;
import static org.mockito.Mockito.*;

@ExtendWith(MockitoExtension.class)
@MockitoSettings(strictness = Strictness.LENIENT)
public class Aster_CoreFunction_Test_Passing {
    CoreFunction corefunction;
    EvalContext evalContext;
    JXPathContext jxpathContext;
    NodePointer nodePointer;
    Expression arg1;
    private int functionCode = Compiler.FUNCTION_LAST;
    private CoreFunction coreFunction;
    EvalContext context;
    Expression arg2;
    Expression[] args;
    EvalContext ctx;
    Expression arg3;
    NodeSet nodeSet;
    BasicNodeSet basicNodeSet;

    @Test
    @Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testfunctionID() throws Exception {
        evalContext = mock(EvalContext.class);
        jxpathContext = mock(JXPathContext.class);
        nodePointer = mock(NodePointer.class);
        arg1 = mock(Expression.class);
        corefunction = new CoreFunction(1, new Expression[]{arg1});
        when(evalContext.getJXPathContext()).thenReturn(jxpathContext);
        when(jxpathContext.getContextPointer()).thenReturn(nodePointer);
        when(arg1.computeValue(evalContext)).thenReturn("some-id");
        when(nodePointer.getPointerByID(jxpathContext, "some-id")).thenReturn(nodePointer);
        Object result = corefunction.functionID(evalContext);
        assertEquals(nodePointer, result);
        verify(evalContext).getJXPathContext();
        verify(jxpathContext).getContextPointer();
        verify(arg1).computeValue(evalContext);
        verify(nodePointer).getPointerByID(jxpathContext, "some-id");
    }

    @Test
    @Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testComputeValue_1() throws Exception {
        evalContext = Mockito.mock(EvalContext.class);
        coreFunction = new CoreFunction(functionCode, new Expression[0]);
        // mock the behavior of evalContext
        Mockito.when(evalContext.getPosition()).thenReturn(1);
        // call the method under test
        Object result = coreFunction.computeValue(evalContext);
        // assert the result
        assertNotNull(result);
    }

    @Test
    @Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testfunctionBoolean() throws Exception {
        arg1 = mock(Expression.class);
        evalContext = mock(EvalContext.class);
        coreFunction = new CoreFunction(1, new Expression[]{arg1});
        // given
        when(arg1.computeValue(evalContext)).thenReturn(Boolean.TRUE);
        // when
        Object result = coreFunction.functionBoolean(evalContext);
        // then
        assertEquals(Boolean.TRUE, result);
    }

    @Test
    @Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testfunctionBoolean_False() throws Exception {
        arg1 = mock(Expression.class);
        evalContext = mock(EvalContext.class);
        coreFunction = new CoreFunction(1, new Expression[]{arg1});
        // given
        when(arg1.computeValue(evalContext)).thenReturn(Boolean.FALSE);
        // when
        Object result = coreFunction.functionBoolean(evalContext);
        // then
        assertEquals(Boolean.FALSE, result);
    }

    @Test
    @Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testfunctionSubstringBefore() throws Exception {
        arg1 = mock(Expression.class);
        arg2 = mock(Expression.class);
        context = mock(EvalContext.class);
        coreFunction = new CoreFunction(1, new Expression[]{arg1, arg2});
        // given
        when(arg1.computeValue(context)).thenReturn("hello world");
        when(arg2.computeValue(context)).thenReturn("world");
        // when
        Object result = coreFunction.functionSubstringBefore(context);
        // then
        assertEquals("hello ", result);
    }

    @Test
    @Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testfunctionSubstringBefore_notFound() throws Exception {
        arg1 = mock(Expression.class);
        arg2 = mock(Expression.class);
        context = mock(EvalContext.class);
        coreFunction = new CoreFunction(1, new Expression[]{arg1, arg2});
        // given
        when(arg1.computeValue(context)).thenReturn("hello world");
        when(arg2.computeValue(context)).thenReturn("foo");
        // when
        Object result = coreFunction.functionSubstringBefore(context);
        // then
        assertEquals("", result);
    }

    @Test
    @Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testfunctionFalse() throws Exception {
        evalContext = mock(EvalContext.class);
        coreFunction = new CoreFunction(0, new Expression[0]);
        Object result = coreFunction.functionFalse(evalContext);
        assertEquals(Boolean.FALSE, result);
    }

    @Test
    @Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testfunctionPosition() throws Exception {
        evalContext = Mockito.mock(EvalContext.class);
        coreFunction = new CoreFunction(0, new Expression[0]);
        // given
        Mockito.when(evalContext.getCurrentPosition()).thenReturn(10);
        // when
        Object result = coreFunction.functionPosition(evalContext);
        // then
        assertEquals(Integer.valueOf(10), result);
    }

    @Test
    @Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testfunctionLast() throws Exception {
        args = new Expression[0];
        coreFunction = new CoreFunction(0, args);
        evalContext = Mockito.mock(EvalContext.class);
        // given
        Mockito.when(evalContext.getCurrentPosition()).thenReturn(5);
        Mockito.when(evalContext.nextNode()).thenReturn(true, true, false);
        // when
        Object result = coreFunction.functionLast(evalContext);
        // then
        assertEquals(Double.valueOf(2), result);
        Mockito.verify(evalContext).reset();
        Mockito.verify(evalContext).setPosition(5);
    }

    @Test
    @Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testfunctionNot_2() throws Exception {
        arg1 = mock(Expression.class);
        context = mock(EvalContext.class);
        coreFunction = new CoreFunction(1, new Expression[]{arg1});
        // given
        when(arg1.computeValue(context)).thenReturn(Boolean.TRUE);
        // when
        Object result = coreFunction.functionNot(context);
        // then
        // given
        when(arg1.computeValue(context)).thenReturn(Boolean.FALSE);
        // when
        result = coreFunction.functionNot(context);
        // then
        assertEquals(Boolean.TRUE, result);
    }

    @Test
    @Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testfunctionStartsWith() throws Exception {
        arg1 = mock(Expression.class);
        arg2 = mock(Expression.class);
        context = mock(EvalContext.class);
        coreFunction = new CoreFunction(1, new Expression[]{arg1, arg2});
        // given
        when(arg1.computeValue(context)).thenReturn("hello world");
        when(arg2.computeValue(context)).thenReturn("hello");
        // when
        Object result = coreFunction.functionStartsWith(context);
        // then
        assertEquals(Boolean.TRUE, result);
    }

    @Test
    @Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testfunctionStartsWith_NotMatching() throws Exception {
        arg1 = mock(Expression.class);
        arg2 = mock(Expression.class);
        context = mock(EvalContext.class);
        coreFunction = new CoreFunction(1, new Expression[]{arg1, arg2});
        // given
        when(arg1.computeValue(context)).thenReturn("hello world");
        when(arg2.computeValue(context)).thenReturn("goodbye");
        // when
        Object result = coreFunction.functionStartsWith(context);
        // then
        assertEquals(Boolean.FALSE, result);
    }

    @Test
    @Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testfunctionNamespaceURI_noArguments() throws Exception {
        context = mock(EvalContext.class);
        nodePointer = mock(NodePointer.class);
        arg1 = mock(Expression.class);
        corefunction = new CoreFunction(0, new Expression[]{arg1});
        when(context.getCurrentNodePointer()).thenReturn(nodePointer);
        when(nodePointer.getNamespaceURI()).thenReturn("");
        Object result = corefunction.functionNamespaceURI(context);
        assertEquals("", result);
    }

    @Test
    @Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testfunctionNamespaceURI_oneArgument() throws Exception {
        context = mock(EvalContext.class);
        nodePointer = mock(NodePointer.class);
        arg1 = mock(Expression.class);
        corefunction = new CoreFunction(0, new Expression[]{arg1});
        when(context.hasNext()).thenReturn(true);
        when(context.next()).thenReturn(nodePointer);
        when(nodePointer.getNamespaceURI()).thenReturn("namespace-uri");
        when(arg1.compute(context)).thenReturn(context);
        Object result = corefunction.functionNamespaceURI(context);
        assertEquals("namespace-uri", result);
    }

    @Test
    @Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testfunctionNamespaceURI_oneArgument_noNext() throws Exception {
        context = mock(EvalContext.class);
        nodePointer = mock(NodePointer.class);
        arg1 = mock(Expression.class);
        corefunction = new CoreFunction(0, new Expression[]{arg1});
        when(context.hasNext()).thenReturn(false);
        when(arg1.compute(context)).thenReturn(context);
        Object result = corefunction.functionNamespaceURI(context);
        assertEquals("", result);
    }

    @Test
    @Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testfunctionNamespaceURI_oneArgument_notEvalContext() throws Exception {
        context = mock(EvalContext.class);
        nodePointer = mock(NodePointer.class);
        arg1 = mock(Expression.class);
        corefunction = new CoreFunction(0, new Expression[]{arg1});
        when(arg1.compute(context)).thenReturn("not-eval-context");
        Object result = corefunction.functionNamespaceURI(context);
        assertEquals("", result);
    }

    @Test
    @Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testfunctionConcat() throws Exception {
        args = new Expression[]{mock(Expression.class), mock(Expression.class)};
        coreFunction = new CoreFunction(1, args);
        context = mock(EvalContext.class);
        // given
        when(args[0].compute(context)).thenReturn("Hello");
        when(args[1].compute(context)).thenReturn("World");
        // when
        Object result = coreFunction.functionConcat(context);
        // then
        assertEquals("HelloWorld", result);
        verify(args[0]).compute(context);
        verify(args[1]).compute(context);
    }

    @Test
    @Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testGetFunctionName_LAST_Awue0() {
        CoreFunction coreFunction = new CoreFunction(Compiler.FUNCTION_LAST, new Expression[0]);
        assertEquals("last", coreFunction.getFunctionName());
    }

    @Test
    @Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testfunctionTranslate_1() throws Exception {
        arg1 = mock(Expression.class);
        arg2 = mock(Expression.class);
        arg3 = mock(Expression.class);
        context = mock(EvalContext.class);
        coreFunction = new CoreFunction(1, new Expression[]{arg1, arg2, arg3});
        // Given
        when(arg1.computeValue(context)).thenReturn("hello");
        when(arg2.computeValue(context)).thenReturn("h");
        when(arg3.computeValue(context)).thenReturn("x");
        // When
        Object result = coreFunction.functionTranslate(context);
        // Then
        assertNotNull(result);
    }

    @Test
    @Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testfunctionTranslate_2() throws Exception {
        arg1 = mock(Expression.class);
        arg2 = mock(Expression.class);
        arg3 = mock(Expression.class);
        context = mock(EvalContext.class);
        coreFunction = new CoreFunction(1, new Expression[]{arg1, arg2, arg3});
        // Given
        when(arg1.computeValue(context)).thenReturn("hello");
        when(arg2.computeValue(context)).thenReturn("h");
        when(arg3.computeValue(context)).thenReturn("x");
        // When
        Object result = coreFunction.functionTranslate(context);
        // Then
        assertEquals("xello", result);
    }

    @Test
    @Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testGetArgumentCount_withNullArgs_fSnc0() {
        CoreFunction coreFunction = new CoreFunction(1, null);
        assertEquals(0, coreFunction.getArgumentCount());
    }

    @Test
    @Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testGetArgumentCount_withNonNullArgs_LsRT1() {
        Expression[] args = new Expression[5];
        CoreFunction coreFunction = new CoreFunction(1, args);
        assertEquals(5, coreFunction.getArgumentCount());
    }

    @Test
    @Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testfunctionEndsWith() throws Exception {
        evalContext = mock(EvalContext.class);
        arg1 = mock(Expression.class);
        arg2 = mock(Expression.class);
        coreFunction = new CoreFunction(1, new Expression[]{arg1, arg2});
        // given
        when(arg1.computeValue(evalContext)).thenReturn("hello world");
        when(arg2.computeValue(evalContext)).thenReturn("world");
        // when
        Object result = coreFunction.functionEndsWith(evalContext);
        // then
        assertEquals(Boolean.TRUE, result);
    }

    @Test
    @Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testfunctionEndsWith_NotMatching() throws Exception {
        evalContext = mock(EvalContext.class);
        arg1 = mock(Expression.class);
        arg2 = mock(Expression.class);
        coreFunction = new CoreFunction(1, new Expression[]{arg1, arg2});
        // given
        when(arg1.computeValue(evalContext)).thenReturn("hello world");
        when(arg2.computeValue(evalContext)).thenReturn("foo");
        // when
        Object result = coreFunction.functionEndsWith(evalContext);
        // then
        assertEquals(Boolean.FALSE, result);
    }

    @Test
    @Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testfunctionKey_1() throws Exception {
        arg1 = mock(Expression.class);
        arg2 = mock(Expression.class);
        context = mock(EvalContext.class);
        jxpathContext = mock(JXPathContext.class);
        nodeSet = mock(NodeSet.class);
        nodePointer = mock(NodePointer.class);
        basicNodeSet = new BasicNodeSet();
        coreFunction = new CoreFunction(1, new Expression[]{arg1, arg2});
        // given
        when(arg1.computeValue(context)).thenReturn("key");
        when(arg2.compute(context)).thenReturn(nodePointer);
        when(context.getJXPathContext()).thenReturn(jxpathContext);
        when(jxpathContext.getNodeSetByKey("key", nodePointer.getValue())).thenReturn(nodeSet);
        when(nodePointer.getValue()).thenReturn("value");
        // when
        Object result = coreFunction.functionKey(context);
        // then
        NodeSetContext nodeSetContext = (NodeSetContext) result;
        assertNotNull(result);
    }

    @Test
    @Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testfunctionKey_2() throws Exception {
        arg1 = mock(Expression.class);
        arg2 = mock(Expression.class);
        context = mock(EvalContext.class);
        jxpathContext = mock(JXPathContext.class);
        nodeSet = mock(NodeSet.class);
        nodePointer = mock(NodePointer.class);
        basicNodeSet = new BasicNodeSet();
        coreFunction = new CoreFunction(1, new Expression[]{arg1, arg2});
        // given
        when(arg1.computeValue(context)).thenReturn("key");
        when(arg2.compute(context)).thenReturn(nodePointer);
        when(context.getJXPathContext()).thenReturn(jxpathContext);
        when(jxpathContext.getNodeSetByKey("key", nodePointer.getValue())).thenReturn(nodeSet);
        when(nodePointer.getValue()).thenReturn("value");
        // when
        Object result = coreFunction.functionKey(context);
        // then
        NodeSetContext nodeSetContext = (NodeSetContext) result;
        assertTrue(result instanceof NodeSetContext);
    }

    @Test
    @Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testfunctionCeiling_3() throws Exception {
        arg1 = mock(Expression.class);
        context = mock(EvalContext.class);
        coreFunction = new CoreFunction(1, new Expression[]{arg1});
        // Test case 1: NaN value
        when(arg1.computeValue(context)).thenReturn(Double.NaN);
        // Test case 2: Infinite value
        when(arg1.computeValue(context)).thenReturn(Double.POSITIVE_INFINITY);
        // Test case 3: Normal value
        when(arg1.computeValue(context)).thenReturn(1.5);
        assertEquals(Double.valueOf(Math.ceil(1.5)), coreFunction.functionCeiling(context));
    }

    @Test
    @Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testfunctionNot() throws Exception {
        arg1 = mock(Expression.class);
        context = mock(EvalContext.class);
        coreFunction = new CoreFunction(1, new Expression[]{arg1});
        // given
        when(arg1.computeValue(context)).thenReturn(Boolean.TRUE);
        // when
        Object result = coreFunction.functionNot(context);
        // then
        assertEquals(Boolean.FALSE, result);
        // given
        when(arg1.computeValue(context)).thenReturn(Boolean.FALSE);
        // when
        result = coreFunction.functionNot(context);
        // then
        assertEquals(Boolean.TRUE, result);
    }

    @Test
    @Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testfunctionTranslate() throws Exception {
        arg1 = mock(Expression.class);
        arg2 = mock(Expression.class);
        arg3 = mock(Expression.class);
        context = mock(EvalContext.class);
        coreFunction = new CoreFunction(1, new Expression[]{arg1, arg2, arg3});
        // Given
        when(arg1.computeValue(context)).thenReturn("hello");
        when(arg2.computeValue(context)).thenReturn("h");
        when(arg3.computeValue(context)).thenReturn("x");
        // When
        Object result = coreFunction.functionTranslate(context);
        // Then
        assertNotNull(result);
        assertEquals("xello", result);
    }

    @Test
    @Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testfunctionCeiling() throws Exception {
        arg1 = mock(Expression.class);
        context = mock(EvalContext.class);
        coreFunction = new CoreFunction(1, new Expression[]{arg1});
        // Test case 1: NaN value
        when(arg1.computeValue(context)).thenReturn(Double.NaN);
        assertEquals(Double.valueOf(Double.NaN), coreFunction.functionCeiling(context));
        // Test case 2: Infinite value
        when(arg1.computeValue(context)).thenReturn(Double.POSITIVE_INFINITY);
        assertEquals(Double.valueOf(Double.POSITIVE_INFINITY), coreFunction.functionCeiling(context));
        // Test case 3: Normal value
        when(arg1.computeValue(context)).thenReturn(1.5);
        assertEquals(Double.valueOf(Math.ceil(1.5)), coreFunction.functionCeiling(context));
    }

    @Test
    @Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testfunctionLocalName_oneArgument_noNext() throws Exception {
        coreFunction = new CoreFunction(0, new Expression[0]);
        context = mock(EvalContext.class);
        nodePointer = mock(NodePointer.class);
        arg1 = mock(Expression.class);
        coreFunction = new CoreFunction(0, new Expression[]{arg1});
        when(arg1.compute(context)).thenReturn(context);
        when(context.hasNext()).thenReturn(false);
        Object result = coreFunction.functionLocalName(context);
        assertEquals("", result);
    }

    @Test
    @Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testfunctionStringLength_noArguments() throws Exception {
        coreFunction = new CoreFunction(0, new Expression[0]);
        context = Mockito.mock(EvalContext.class);
        arg1 = Mockito.mock(Expression.class);
        nodePointer = Mockito.mock(NodePointer.class);
        // given
        Mockito.when(context.getCurrentNodePointer()).thenReturn(nodePointer);
        Mockito.when(InfoSetUtil.stringValue(nodePointer)).thenReturn("test string");
        // when
        Object result = coreFunction.functionStringLength(context);
        // then
        assertEquals(11.0, result);
    }

    @Test
    @Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testfunctionStringLength_withArgument() throws Exception {
        coreFunction = new CoreFunction(0, new Expression[0]);
        context = Mockito.mock(EvalContext.class);
        arg1 = Mockito.mock(Expression.class);
        nodePointer = Mockito.mock(NodePointer.class);
        // given
        coreFunction = new CoreFunction(0, new Expression[]{arg1});
        Mockito.when(arg1.computeValue(context)).thenReturn(nodePointer);
        Mockito.when(InfoSetUtil.stringValue(nodePointer)).thenReturn("test string");
        // when
        Object result = coreFunction.functionStringLength(context);
        // then
        assertEquals(11.0, result);
    }

    @Test
    @Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testfunctionTrue() throws Exception {
        evalContext = Mockito.mock(EvalContext.class);
        corefunction = new CoreFunction(1, new Expression[0]);
        Object result = corefunction.functionTrue(evalContext);
        assertEquals(Boolean.TRUE, result);
    }

    @Test
    @Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testfunctionNull() throws Exception {
        evalContext = mock(EvalContext.class);
        coreFunction = new CoreFunction(0, new Expression[0]);
        Object result = coreFunction.functionNull(evalContext);
        assertNull(result);
    }

    @Test
    @Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testfunctionContains() throws Exception {
        arg1 = mock(Expression.class);
        arg2 = mock(Expression.class);
        context = mock(EvalContext.class);
        coreFunction = new CoreFunction(1, new Expression[]{arg1, arg2});
        // given
        when(arg1.computeValue(context)).thenReturn("hello world");
        when(arg2.computeValue(context)).thenReturn("world");
        // when
        Object result = coreFunction.functionContains(context);
        // then
        assertTrue((Boolean) result);
    }

    @Test
    @Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testfunctionContains_NotContains() throws Exception {
        arg1 = mock(Expression.class);
        arg2 = mock(Expression.class);
        context = mock(EvalContext.class);
        coreFunction = new CoreFunction(1, new Expression[]{arg1, arg2});
        // given
        when(arg1.computeValue(context)).thenReturn("hello world");
        when(arg2.computeValue(context)).thenReturn("foo");
        // when
        Object result = coreFunction.functionContains(context);
        // then
        assertFalse((Boolean) result);
    }

    @Test
    @Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testfunctionRound() throws Exception {
        arg1 = mock(Expression.class);
        context = mock(EvalContext.class);
        coreFunction = new CoreFunction(1, new Expression[]{arg1});
        // Test case 1: NaN value
        when(arg1.computeValue(context)).thenReturn(Double.NaN);
        Object result = coreFunction.functionRound(context);
        assertEquals(Double.NaN, ((Double) result).doubleValue(), 0.0);
        // Test case 2: Infinite value
        when(arg1.computeValue(context)).thenReturn(Double.POSITIVE_INFINITY);
        result = coreFunction.functionRound(context);
        assertEquals(Double.POSITIVE_INFINITY, ((Double) result).doubleValue(), 0.0);
        // Test case 3: Normal value
        when(arg1.computeValue(context)).thenReturn(10.5);
        result = coreFunction.functionRound(context);
        assertEquals(11.0, ((Double) result).doubleValue(), 0.0);
    }

    @Test
    @Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testGetFunctionCode_mXmc0() {
        Expression[] args = new Expression[0];
        CoreFunction coreFunction = new CoreFunction(1, args);
        assertEquals(1, coreFunction.getFunctionCode());
    }

    @Test
    @Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testComputeContextDependent1_gfEq0() {
        CoreFunction coreFunction = new CoreFunction(Compiler.FUNCTION_LAST, null);
        assertTrue(coreFunction.computeContextDependent());
    }

    @Test
    @Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testComputeContextDependent2_YzLH1() {
        CoreFunction coreFunction = new CoreFunction(Compiler.FUNCTION_BOOLEAN, new Expression[0]);
        assertTrue(coreFunction.computeContextDependent());
    }
}