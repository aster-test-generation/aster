/**
 * Generated by Aster
 */
package org.apache.commons.jxpath.ri.compiler;

import java.util.Collection;
import java.util.concurrent.TimeUnit;
import org.apache.commons.jxpath.BasicNodeSet;
import org.apache.commons.jxpath.JXPathContext;
import org.apache.commons.jxpath.JXPathException;
import org.apache.commons.jxpath.NodeSet;
import org.apache.commons.jxpath.ri.Compiler;
import org.apache.commons.jxpath.ri.EvalContext;
import org.apache.commons.jxpath.ri.InfoSetUtil;
import org.apache.commons.jxpath.ri.QName;
import org.apache.commons.jxpath.ri.model.NodePointer;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.Timeout;
import org.junit.jupiter.api.Timeout.ThreadMode;
import org.junit.jupiter.api.extension.ExtendWith;
import org.mockito.Mock;
import org.mockito.Mockito;
import org.mockito.junit.jupiter.MockitoExtension;
import org.mockito.junit.jupiter.MockitoSettings;
import org.mockito.quality.Strictness;

import static org.junit.jupiter.api.Assertions.*;
import static org.junit.jupiter.api.Timeout.ThreadMode.SEPARATE_THREAD;
import static org.mockito.Mockito.*;

@ExtendWith(MockitoExtension.class)
@MockitoSettings(strictness = Strictness.LENIENT)
public class Aster_CoreFunction_Test_Passing {
    CoreFunction coreFunction;
    EvalContext evalContext;
    JXPathContext jXPathContext;
    NodePointer nodePointer;
    Expression arg1;
    private int functionCode = Compiler.FUNCTION_LAST;
    Expression arg2;
    CoreFunction corefunction;
    Expression[] args;
    EvalContext ctx;
    EvalContext context;
    Expression arg3;
    @Mock
    private JXPathContext jxpathContext;
    @Mock
    private NodeSet nodeSet;
    @Mock
    private BasicNodeSet basicNodeSet;
    private static Double ZERO = Double.valueOf(0);

    @Test
    @Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testfunctionID() throws Exception {
        evalContext = mock(EvalContext.class);
        jXPathContext = mock(JXPathContext.class);
        nodePointer = mock(NodePointer.class);
        arg1 = mock(Expression.class);
        coreFunction = new CoreFunction(1, new Expression[]{arg1});
        // given
        when(evalContext.getJXPathContext()).thenReturn(jXPathContext);
        when(jXPathContext.getContextPointer()).thenReturn(nodePointer);
        when(arg1.computeValue(evalContext)).thenReturn("some-id");
        when(nodePointer.getPointerByID(jXPathContext, "some-id")).thenReturn(nodePointer);
        // when
        Object result = coreFunction.functionID(evalContext);
        // then
        assertEquals(nodePointer, result);
        verify(evalContext).getJXPathContext();
        verify(jXPathContext).getContextPointer();
        verify(arg1).computeValue(evalContext);
        verify(nodePointer).getPointerByID(jXPathContext, "some-id");
    }

    @Test
    @Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testComputeValue_1() throws Exception {
        coreFunction = new CoreFunction(functionCode, new Expression[0]);
        evalContext = Mockito.mock(EvalContext.class);
        // mock the behavior of evalContext
        Mockito.when(evalContext.getPosition()).thenReturn(1);
        // call the method under test
        Object result = coreFunction.computeValue(evalContext);
        // assert the result
        assertNotNull(result);
    }

    @Test
    @Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testfunctionBoolean() throws Exception {
        evalContext = mock(EvalContext.class);
        arg1 = mock(Expression.class);
        coreFunction = new CoreFunction(1, new Expression[]{arg1});
        // Given
        when(arg1.computeValue(evalContext)).thenReturn(Boolean.TRUE);
        // When
        Object result = coreFunction.functionBoolean(evalContext);
        // Then
        assertEquals(Boolean.TRUE, result);
    }

    @Test
    @Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testfunctionBoolean_False() throws Exception {
        evalContext = mock(EvalContext.class);
        arg1 = mock(Expression.class);
        coreFunction = new CoreFunction(1, new Expression[]{arg1});
        // Given
        when(arg1.computeValue(evalContext)).thenReturn(Boolean.FALSE);
        // When
        Object result = coreFunction.functionBoolean(evalContext);
        // Then
        assertEquals(Boolean.FALSE, result);
    }

    @Test
    @Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testfunctionSubstringBefore() throws Exception {
        evalContext = mock(EvalContext.class);
        arg1 = mock(Expression.class);
        arg2 = mock(Expression.class);
        coreFunction = new CoreFunction(0, new Expression[]{arg1, arg2});
        // given
        when(arg1.computeValue(evalContext)).thenReturn("hello world");
        when(arg2.computeValue(evalContext)).thenReturn("world");
        // when
        Object result = coreFunction.functionSubstringBefore(evalContext);
        // then
        assertEquals("hello ", result);
    }

    @Test
    @Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testfunctionSubstringBefore_notFound() throws Exception {
        evalContext = mock(EvalContext.class);
        arg1 = mock(Expression.class);
        arg2 = mock(Expression.class);
        coreFunction = new CoreFunction(0, new Expression[]{arg1, arg2});
        // given
        when(arg1.computeValue(evalContext)).thenReturn("hello world");
        when(arg2.computeValue(evalContext)).thenReturn("foo");
        // when
        Object result = coreFunction.functionSubstringBefore(evalContext);
        // then
        assertEquals("", result);
    }

    @Test
    @Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testfunctionFalse() throws Exception {
        evalContext = mock(EvalContext.class);
        coreFunction = new CoreFunction(0, new Expression[0]);
        Object result = coreFunction.functionFalse(evalContext);
        assertEquals(Boolean.FALSE, result);
    }

    @Test
    @Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testfunctionLang() throws Exception {
        evalContext = mock(EvalContext.class);
        nodePointer = mock(NodePointer.class);
        arg1 = mock(Expression.class);
        coreFunction = new CoreFunction(1, new Expression[]{arg1});
        when(evalContext.getSingleNodePointer()).thenReturn(nodePointer);
        when(arg1.computeValue(evalContext)).thenReturn("en-US");
        when(nodePointer.isLanguage("en-US")).thenReturn(true);
        Object result = coreFunction.functionLang(evalContext);
        assertEquals(Boolean.TRUE, result);
    }

    @Test
    @Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testfunctionLang_nullPointer() throws Exception {
        evalContext = mock(EvalContext.class);
        nodePointer = mock(NodePointer.class);
        arg1 = mock(Expression.class);
        coreFunction = new CoreFunction(1, new Expression[]{arg1});
        when(evalContext.getSingleNodePointer()).thenReturn(null);
        Object result = coreFunction.functionLang(evalContext);
        assertEquals(Boolean.FALSE, result);
    }

    @Test
    @Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testfunctionPosition() throws Exception {
        evalContext = mock(EvalContext.class);
        corefunction = new CoreFunction(0, new Expression[0]);
        when(evalContext.getCurrentPosition()).thenReturn(10);
        Object result = corefunction.functionPosition(evalContext);
        assertEquals(Integer.valueOf(10), result);
        verify(evalContext, times(1)).getCurrentPosition();
    }

    @Test
    @Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testGetFunctionName_LAST_dISf0() {
        CoreFunction coreFunction = new CoreFunction(Compiler.FUNCTION_LAST, new Expression[0]);
        assertEquals("last", coreFunction.getFunctionName());
    }

    @Test
    @Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testfunctionLast() throws Exception {
        coreFunction = new CoreFunction(0, new Expression[0]);
        evalContext = mock(EvalContext.class);
        // given
        when(evalContext.getCurrentPosition()).thenReturn(5);
        when(evalContext.nextNode()).thenReturn(true, true, true, false);
        // when
        Object result = coreFunction.functionLast(evalContext);
        // then
        verify(evalContext).reset();
        verify(evalContext).setPosition(5);
        assertEquals(3.0, ((Double) result).doubleValue());
    }

    @Test
    @Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testfunctionNot() throws Exception {
        arg1 = mock(Expression.class);
        evalContext = mock(EvalContext.class);
        coreFunction = new CoreFunction(1, new Expression[]{arg1});
        // given
        when(arg1.computeValue(evalContext)).thenReturn(Boolean.TRUE);
        // when
        Object result = coreFunction.functionNot(evalContext);
        // then
        assertEquals(Boolean.FALSE, result);
        // given
        when(arg1.computeValue(evalContext)).thenReturn(Boolean.FALSE);
        // when
        result = coreFunction.functionNot(evalContext);
        // then
        assertEquals(Boolean.TRUE, result);
    }

    @Test
    @Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testGetArgumentCount_withNullArgs_Awur0() {
        CoreFunction coreFunction = new CoreFunction(1, null);
        assertEquals(0, coreFunction.getArgumentCount());
    }

    @Test
    @Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testGetArgumentCount_withArgs_sesd1() {
        Expression[] args = new Expression[2];
        CoreFunction coreFunction = new CoreFunction(1, args);
        assertEquals(2, coreFunction.getArgumentCount());
    }

    @Test
    @Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testfunctionStartsWith() throws Exception {
        arg1 = mock(Expression.class);
        arg2 = mock(Expression.class);
        evalContext = mock(EvalContext.class);
        coreFunction = new CoreFunction(1, new Expression[]{arg1, arg2});
        // given
        when(arg1.computeValue(evalContext)).thenReturn("hello world");
        when(arg2.computeValue(evalContext)).thenReturn("hello");
        // when
        Object result = coreFunction.functionStartsWith(evalContext);
        // then
        assertEquals(Boolean.TRUE, result);
    }

    @Test
    @Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testfunctionStartsWith_False() throws Exception {
        arg1 = mock(Expression.class);
        arg2 = mock(Expression.class);
        evalContext = mock(EvalContext.class);
        coreFunction = new CoreFunction(1, new Expression[]{arg1, arg2});
        // given
        when(arg1.computeValue(evalContext)).thenReturn("hello world");
        when(arg2.computeValue(evalContext)).thenReturn("goodbye");
        // when
        Object result = coreFunction.functionStartsWith(evalContext);
        // then
        assertEquals(Boolean.FALSE, result);
    }

    @Test
    @Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testfunctionNamespaceURI_oneArgument() throws Exception {
        evalContext = mock(EvalContext.class);
        nodePointer = mock(NodePointer.class);
        arg1 = mock(Expression.class);
        corefunction = new CoreFunction(0, new Expression[]{arg1});
        when(evalContext.hasNext()).thenReturn(true);
        when(evalContext.next()).thenReturn(nodePointer);
        when(nodePointer.getNamespaceURI()).thenReturn("namespace-uri");
        when(arg1.compute(evalContext)).thenReturn(evalContext);
        Object result = corefunction.functionNamespaceURI(evalContext);
        assertEquals("namespace-uri", result);
    }

    @Test
    @Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testfunctionNamespaceURI_oneArgument_noNext() throws Exception {
        evalContext = mock(EvalContext.class);
        nodePointer = mock(NodePointer.class);
        arg1 = mock(Expression.class);
        corefunction = new CoreFunction(0, new Expression[]{arg1});
        when(evalContext.hasNext()).thenReturn(false);
        when(arg1.compute(evalContext)).thenReturn(evalContext);
        Object result = corefunction.functionNamespaceURI(evalContext);
        assertEquals("", result);
    }

    @Test
    @Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testfunctionNamespaceURI_oneArgument_notEvalContext() throws Exception {
        evalContext = mock(EvalContext.class);
        nodePointer = mock(NodePointer.class);
        arg1 = mock(Expression.class);
        corefunction = new CoreFunction(0, new Expression[]{arg1});
        when(arg1.compute(evalContext)).thenReturn("not-eval-context");
        Object result = corefunction.functionNamespaceURI(evalContext);
        assertEquals("", result);
    }

    @Test
    @Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testfunctionCount_NodePointer() throws Exception {
        evalContext = mock(EvalContext.class);
        arg1 = mock(Expression.class);
        nodePointer = mock(NodePointer.class);
        ctx = mock(EvalContext.class);
        coreFunction = new CoreFunction(1, new Expression[]{arg1});
        when(arg1.compute(evalContext)).thenReturn(nodePointer);
        when(nodePointer.getValue()).thenReturn(nodePointer);
        assertEquals(Double.valueOf(1), coreFunction.functionCount(evalContext));
    }

    @Test
    @Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testfunctionCount_EvalContext() throws Exception {
        evalContext = mock(EvalContext.class);
        arg1 = mock(Expression.class);
        nodePointer = mock(NodePointer.class);
        ctx = mock(EvalContext.class);
        coreFunction = new CoreFunction(1, new Expression[]{arg1});
        when(arg1.compute(evalContext)).thenReturn(ctx);
        when(ctx.hasNext()).thenReturn(true, false);
        assertEquals(Double.valueOf(1), coreFunction.functionCount(evalContext));
    }

    @Test
    @Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testfunctionCount_Collection() throws Exception {
        evalContext = mock(EvalContext.class);
        arg1 = mock(Expression.class);
        nodePointer = mock(NodePointer.class);
        ctx = mock(EvalContext.class);
        coreFunction = new CoreFunction(1, new Expression[]{arg1});
        Collection collection = mock(Collection.class);
        when(arg1.compute(evalContext)).thenReturn(collection);
        when(collection.size()).thenReturn(5);
        assertEquals(Double.valueOf(5), coreFunction.functionCount(evalContext));
    }

    @Test
    @Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testfunctionCount_Null() throws Exception {
        evalContext = mock(EvalContext.class);
        arg1 = mock(Expression.class);
        nodePointer = mock(NodePointer.class);
        ctx = mock(EvalContext.class);
        coreFunction = new CoreFunction(1, new Expression[]{arg1});
        when(arg1.compute(evalContext)).thenReturn(null);
        assertEquals(Double.valueOf(0), coreFunction.functionCount(evalContext));
    }

    @Test
    @Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testfunctionCount_Other() throws Exception {
        evalContext = mock(EvalContext.class);
        arg1 = mock(Expression.class);
        nodePointer = mock(NodePointer.class);
        ctx = mock(EvalContext.class);
        coreFunction = new CoreFunction(1, new Expression[]{arg1});
        Object obj = new Object();
        when(arg1.compute(evalContext)).thenReturn(obj);
        assertEquals(Double.valueOf(1), coreFunction.functionCount(evalContext));
    }

    @Test
    @Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testfunctionEndsWith() throws Exception {
        arg1 = mock(Expression.class);
        arg2 = mock(Expression.class);
        context = mock(EvalContext.class);
        coreFunction = new CoreFunction(1, new Expression[]{arg1, arg2});
        // given
        when(arg1.computeValue(context)).thenReturn("hello world");
        when(arg2.computeValue(context)).thenReturn("world");
        // when
        Object result = coreFunction.functionEndsWith(context);
        // then
        assertEquals(Boolean.TRUE, result);
    }

    @Test
    @Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testfunctionEndsWith_notEnding() throws Exception {
        arg1 = mock(Expression.class);
        arg2 = mock(Expression.class);
        context = mock(EvalContext.class);
        coreFunction = new CoreFunction(1, new Expression[]{arg1, arg2});
        // given
        when(arg1.computeValue(context)).thenReturn("hello world");
        when(arg2.computeValue(context)).thenReturn("foo");
        // when
        Object result = coreFunction.functionEndsWith(context);
        // then
        assertEquals(Boolean.FALSE, result);
    }

    @Test
    @Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testfunctionLocalName_oneArgument() throws Exception {
        evalContext = mock(EvalContext.class);
        nodePointer = mock(NodePointer.class);
        arg1 = mock(Expression.class);
        coreFunction = new CoreFunction(0, new Expression[]{arg1});
        when(evalContext.hasNext()).thenReturn(true);
        when(evalContext.next()).thenReturn(nodePointer);
        when(arg1.compute(evalContext)).thenReturn(evalContext);
        when(nodePointer.getName()).thenReturn(new QName("localName"));
        Object result = coreFunction.functionLocalName(evalContext);
        assertEquals("localName", result);
    }

    @Test
    @Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testfunctionLocalName_oneArgument_noNext() throws Exception {
        evalContext = mock(EvalContext.class);
        nodePointer = mock(NodePointer.class);
        arg1 = mock(Expression.class);
        coreFunction = new CoreFunction(0, new Expression[]{arg1});
        when(evalContext.hasNext()).thenReturn(false);
        when(arg1.compute(evalContext)).thenReturn(evalContext);
        Object result = coreFunction.functionLocalName(evalContext);
        assertEquals("", result);
    }

    @Test
    @Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testfunctionStringLength_withArgument() throws Exception {
        evalContext = mock(EvalContext.class);
        arg1 = mock(Expression.class);
        nodePointer = mock(NodePointer.class);
        coreFunction = new CoreFunction(0, new Expression[]{arg1});
        when(arg1.computeValue(evalContext)).thenReturn(nodePointer);
        when(InfoSetUtil.stringValue(nodePointer)).thenReturn("Hello World");
        Object result = coreFunction.functionStringLength(evalContext);
        assertEquals(11.0, ((Double) result).doubleValue());
    }

    @Test
    @Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testfunctionTrue() throws Exception {
        evalContext = mock(EvalContext.class);
        coreFunction = new CoreFunction(0, new Expression[0]);
        Object result = coreFunction.functionTrue(evalContext);
        assertEquals(Boolean.TRUE, result);
    }

    @Test
    @Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testfunctionNull() throws Exception {
        evalContext = mock(EvalContext.class);
        coreFunction = new CoreFunction(0, new Expression[0]);
        Object result = coreFunction.functionNull(evalContext);
        assertNull(result);
    }

    @Test
    @Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testfunctionSum() throws Exception {
        evalContext = mock(EvalContext.class);
        arg1 = mock(Expression.class);
        nodePointer = mock(NodePointer.class);
        coreFunction = new CoreFunction(1, new Expression[]{arg1});
        // Test case 1: null value
        when(arg1.compute(evalContext)).thenReturn(null);
        assertEquals(ZERO, coreFunction.functionSum(evalContext));
        // Test case 2: EvalContext with hasNext() and next()
        when(arg1.compute(evalContext)).thenReturn(evalContext);
        when(evalContext.hasNext()).thenReturn(true, false);
        when(evalContext.next()).thenReturn(nodePointer);
        when(InfoSetUtil.doubleValue(nodePointer)).thenReturn(10.0);
        assertEquals(Double.valueOf(10.0), coreFunction.functionSum(evalContext));
        // Test case 3: Invalid argument type
        when(arg1.compute(evalContext)).thenReturn("Invalid type");
        JXPathException exception = assertThrows(JXPathException.class, () -> coreFunction.functionSum(evalContext));
        assertEquals("Invalid argument type for 'sum': java.lang.String", exception.getMessage());
    }

    @Test
    @Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testfunctionSubstringAfter() throws Exception {
        evalContext = mock(EvalContext.class);
        arg1 = mock(Expression.class);
        arg2 = mock(Expression.class);
        coreFunction = new CoreFunction(0, new Expression[]{arg1, arg2});
        // given
        when(arg1.computeValue(evalContext)).thenReturn("hello world");
        when(arg2.computeValue(evalContext)).thenReturn("world");
        // when
        Object result = coreFunction.functionSubstringAfter(evalContext);
        // then
        assertEquals("", result);
    }

    @Test
    @Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testfunctionSubstringAfter_noMatch() throws Exception {
        evalContext = mock(EvalContext.class);
        arg1 = mock(Expression.class);
        arg2 = mock(Expression.class);
        coreFunction = new CoreFunction(0, new Expression[]{arg1, arg2});
        // given
        when(arg1.computeValue(evalContext)).thenReturn("hello world");
        when(arg2.computeValue(evalContext)).thenReturn("foo");
        // when
        Object result = coreFunction.functionSubstringAfter(evalContext);
        // then
        assertEquals("", result);
    }

    @Test
    @Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testfunctionSubstringAfter_matchAtStart() throws Exception {
        evalContext = mock(EvalContext.class);
        arg1 = mock(Expression.class);
        arg2 = mock(Expression.class);
        coreFunction = new CoreFunction(0, new Expression[]{arg1, arg2});
        // given
        when(arg1.computeValue(evalContext)).thenReturn("world hello");
        when(arg2.computeValue(evalContext)).thenReturn("world");
        // when
        Object result = coreFunction.functionSubstringAfter(evalContext);
        // then
        assertEquals(" hello", result);
    }

    @Test
    @Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testComputeContextDependent1_bJXt0() {
        CoreFunction coreFunction = new CoreFunction(Compiler.FUNCTION_LAST, null);
        assertTrue(coreFunction.computeContextDependent());
    }

    @Test
    @Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testComputeContextDependent2_IzSn1() {
        CoreFunction coreFunction = new CoreFunction(Compiler.FUNCTION_BOOLEAN, new Expression[0]);
        assertTrue(coreFunction.computeContextDependent());
    }

    @Test
    @Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testGetFunctionCode_yMML0() {
        Expression[] args = new Expression[0];
        CoreFunction coreFunction = new CoreFunction(1, args);
        assertEquals(1, coreFunction.getFunctionCode());
    }

    @Test
    @Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testfunctionContains() throws Exception {
        arg1 = mock(Expression.class);
        arg2 = mock(Expression.class);
        evalContext = mock(EvalContext.class);
        coreFunction = new CoreFunction(1, new Expression[]{arg1, arg2});
        // Given
        when(arg1.computeValue(evalContext)).thenReturn("hello world");
        when(arg2.computeValue(evalContext)).thenReturn("world");
        // When
        Object result = coreFunction.functionContains(evalContext);
        // Then
        assertTrue((Boolean) result);
    }

    @Test
    @Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testfunctionContains_NotContains() throws Exception {
        arg1 = mock(Expression.class);
        arg2 = mock(Expression.class);
        evalContext = mock(EvalContext.class);
        coreFunction = new CoreFunction(1, new Expression[]{arg1, arg2});
        // Given
        when(arg1.computeValue(evalContext)).thenReturn("hello world");
        when(arg2.computeValue(evalContext)).thenReturn("foo");
        // When
        Object result = coreFunction.functionContains(evalContext);
        // Then
        assertFalse((Boolean) result);
    }

    @Test
    @Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testfunctionNumber_noArgs() throws Exception {
        coreFunction = new CoreFunction(0, new Expression[0]);
        context = mock(EvalContext.class);
        arg1 = mock(Expression.class);
        when(context.getCurrentNodePointer()).thenReturn(mock(NodePointer.class));
        Object result = coreFunction.functionNumber(context);
        assertNotNull(result);
    }

    @Test
    @Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testfunctionNumber_oneArg() throws Exception {
        coreFunction = new CoreFunction(0, new Expression[0]);
        context = mock(EvalContext.class);
        arg1 = mock(Expression.class);
        coreFunction = new CoreFunction(0, new Expression[]{arg1});
        when(arg1.computeValue(context)).thenReturn(mock(Object.class));
        Object result = coreFunction.functionNumber(context);
        assertNotNull(result);
    }

    @Test
    @Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testfunctionSubstring_withInvalidFrom() throws Exception {
        evalContext = mock(EvalContext.class);
        arg1 = mock(Expression.class);
        arg2 = mock(Expression.class);
        arg3 = mock(Expression.class);
        coreFunction = new CoreFunction(0, new Expression[]{arg1, arg2, arg3});
        // Given
        when(arg1.computeValue(evalContext)).thenReturn("Hello World");
        when(arg2.computeValue(evalContext)).thenReturn(Double.NaN);
        // When
        Object result = coreFunction.functionSubstring(evalContext);
        // Then
        assertEquals("", result);
    }

    @Test
    @Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testfunctionSubstring_withInvalidLength() throws Exception {
        evalContext = mock(EvalContext.class);
        arg1 = mock(Expression.class);
        arg2 = mock(Expression.class);
        arg3 = mock(Expression.class);
        coreFunction = new CoreFunction(0, new Expression[]{arg1, arg2, arg3});
        // Given
        when(arg1.computeValue(evalContext)).thenReturn("Hello World");
        when(arg2.computeValue(evalContext)).thenReturn(2.0);
        when(arg3.computeValue(evalContext)).thenReturn(-1.0);
        // When
        Object result = coreFunction.functionSubstring(evalContext);
        // Then
        assertEquals("", result);
    }
}