/**
 * Generated by Aster
 */
package org.apache.commons.codec.binary;

import static org.junit.jupiter.api.Assertions.*;
import static org.junit.jupiter.api.Timeout.ThreadMode.SEPARATE_THREAD;

import java.util.concurrent.TimeUnit;
import org.apache.commons.codec.CodecPolicy;
import org.apache.commons.codec.DecoderException;
import org.apache.commons.codec.EncoderException;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.Timeout;
import org.junit.jupiter.api.Timeout.ThreadMode;

public class Aster_Base32_Test_Failing {
    @Test
    @Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testGetLineSeparator_rcIN0() {
        Base32 base32 = new Base32(10, new byte[]{'\r', '\n'}, true, (byte) ' ', CodecPolicy.STRICT);
        assertArrayEquals(new byte[]{'\r', '\n'}, base32.getLineSeparator());
    }

    @Test
    @Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testGetLineSeparatorWithNoLineSeparator_fiAd1() {
        Base32 base32 = new Base32(10, null, true, (byte) ' ', CodecPolicy.STRICT);
        assertArrayEquals(new byte[0], base32.getLineSeparator());
    }

    @Test
    @Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testGetLineSeparatorWithNoLineSeparatorAndNoPolicy_oLzW2() {
        Base32 base32 = new Base32(10, null, true, (byte) ' ', null);
        assertArrayEquals(new byte[0], base32.getLineSeparator());
    }

    @Test
    @Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testGetLineSeparatorWithNoLineSeparatorAndNoPolicyAndNoPad_KqIV3() {
        Base32 base32 = new Base32(10, null, true, (byte) 0, null);
        assertArrayEquals(new byte[0], base32.getLineSeparator());
    }

    @Test
    @Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testGetLineSeparatorWithNoLineSeparatorAndNoPolicyAndNoPadAndNoUseHex_hmgv4() {
        Base32 base32 = new Base32(10, null, false, (byte) 0, null);
        assertArrayEquals(new byte[0], base32.getLineSeparator());
    }

    @Test
    @Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testEncodeWithEmptyInput_Ndik0() {
        Base32 base32 = new Base32();
        byte[] input = new byte[0];
        byte[] expected = new byte[0];
        byte[] actual = base32.encode(input);
        assertEquals(expected, actual);
    }

    @Test
    @Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testDecode_dMAN0() {
        Base32 base32 = new Base32();
        String input = "ABCDEF";
        byte[] expected = {0, 1, 2, 3, 4, 5};
        assertArrayEquals(expected, base32.decode(input));
    }

    @Test
    @Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testDecodeWithLineSeparator_Wsua2() {
        Base32 base32 = new Base32(0, new byte[]{'\n'});
        String input = "ABCDEF\nGHIJKL";
        byte[] expected = {0, 1, 2, 3, 4, 5, 6, 7};
        assertArrayEquals(expected, base32.decode(input));
    }

    @Test
    @Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testDecodeWithHex_CAbF3() {
        Base32 base32 = new Base32(0, new byte[]{'\n'}, true);
        String input = "0123456789ABCDEF";
        byte[] expected = {0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15};
        assertArrayEquals(expected, base32.decode(input));
    }

    @Test
    @Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testDecodeWithPadding_DAGU4() {
        Base32 base32 = new Base32(0, new byte[]{'\n'}, false, (byte) '=', CodecPolicy.LENIENT);
        String input = "ABCDEF===";
        byte[] expected = {0, 1, 2, 3, 4, 5};
        assertArrayEquals(expected, base32.decode(input));
    }

    @Test
    @Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testEncodeAsStringWithLineLength_NBYI1() {
        Base32 base32 = new Base32(8);
        byte[] pArray = new byte[]{0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15};
        assertEquals("AAAQEAYEAUDAOCAJBIFQYDIOB4======", base32.encodeAsString(pArray));
    }

    @Test
    @Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testEncodeAsStringWithLineLengthAndSeparator_fdsp2() {
        Base32 base32 = new Base32(8, new byte[]{'\r', '\n'});
        byte[] pArray = new byte[]{0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15};
        assertEquals("ABCDEFGH\r\nIJKLMNOP\r\nQRSTUVWX\r\nYZ", base32.encodeAsString(pArray));
    }

    @Test
    @Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testEncode_MAXl0() throws EncoderException {
        Base32 base32 = new Base32();
        byte[] input = new byte[]{0, 1, 2, 3};
        String expected = "[65, 65, 65, 81, 69, 65, 89, 61]";
        assertEquals(expected, base32.encode(input));
    }

    @Test
    @Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testEncodeWithLineLength_Uwky1() throws EncoderException {
        Base32 base32 = new Base32(8);
        byte[] input = new byte[]{0, 1, 2, 3, 4, 5, 6, 7};
        String expected = "ABCDEFGH\nIJKLMNOP\nQRSTUVWX\nYZ234567";
        assertEquals(expected, base32.encode(input));
    }

    @Test
    @Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testEncodeWithPadding_TchS3() throws EncoderException {
        Base32 base32 = new Base32(false, (byte) '_');
        byte[] input = new byte[]{0, 1, 2, 3};
        String expected = "[65, 65, 65, 81, 69, 65, 89, 95]";
        assertEquals(expected, base32.encode(input));
    }

    @Test
    @Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testEncodeWithNonEmptyArray_mfRq1() {
        Base32 base32 = new Base32();
        byte[] input = {0, 1, 2, 3};
        byte[] expected = {48, 49, 50, 51};
        assertArrayEquals(expected, base32.encode(input));
    }

    @Test
    @Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testEncodeToStringWithLineLength_DJWX1() {
        Base32 base32 = new Base32(10);
        byte[] array = new byte[]{0, 1, 2, 3, 4, 5, 6, 7, 8, 9};
        String encodedString = base32.encodeToString(array);
        assertEquals("AAEC\nAwsQ\nAAEC", encodedString);
    }

    @Test
    @Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testEncodeToStringWithLineLengthAndSeparator_OsoP2() {
        Base32 base32 = new Base32(10, new byte[]{0x0A});
        byte[] array = new byte[]{0, 1, 2, 3, 4, 5, 6, 7, 8, 9};
        String encodedString = base32.encodeToString(array);
        assertEquals("AAEC\nAwsQ\nAAEC", encodedString);
    }

    @Test
    @Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testDecode_string_liZI1() throws DecoderException {
        Base32 base32 = new Base32();
        String input = "ABC";
        byte[] expected = new byte[]{4, 5, 6};
        byte[] actual = base32.decode(input);
        assertEquals(expected, actual);
    }

    @Test
    @Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testEncodeWithArrayOffsetAndLength_aKBv0() {
        Base32 base32 = new Base32();
        byte[] input = new byte[]{0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07};
        byte[] expected = new byte[]{0x48, 0x65, 0x6c, 0x6c, 0x6f};
        byte[] actual = base32.encode(input, 2, 4);
        assertArrayEquals(expected, actual);
    }

    @Test
    @Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testEncodeWithArrayOffsetAndLengthAndLineLength_KMgR1() {
        Base32 base32 = new Base32(8);
        byte[] input = new byte[]{0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07};
        byte[] expected = new byte[]{0x48, 0x65, 0x6c, 0x6c, 0x6f, 0x0a};
        byte[] actual = base32.encode(input, 2, 4);
        assertArrayEquals(expected, actual);
    }

    @Test
    @Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testEncodeWithArrayOffsetAndLengthAndLineLengthAndLineSeparator_vpmK2() {
        Base32 base32 = new Base32(8, new byte[]{0x0d, 0x0a});
        byte[] input = new byte[]{0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07};
        byte[] expected = new byte[]{0x48, 0x65, 0x6c, 0x6c, 0x6f, 0x0d, 0x0a};
        byte[] actual = base32.encode(input, 2, 4);
        assertArrayEquals(expected, actual);
    }

    @Test
    @Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testEncodeWithArrayOffsetAndLengthAndLineLengthAndLineSeparatorAndUseHex_BMXm3() {
        Base32 base32 = new Base32(8, new byte[]{0x0d, 0x0a}, true);
        byte[] input = new byte[]{0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07};
        byte[] expected = new byte[]{0x48, 0x65, 0x6c, 0x6c, 0x6f, 0x0d, 0x0a};
        byte[] actual = base32.encode(input, 2, 4);
        assertArrayEquals(expected, actual);
    }

    @Test
    @Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testEncodeWithArrayOffsetAndLengthAndLineLengthAndLineSeparatorAndUseHexAndPadding_SCyB4() {
        Base32 base32 = new Base32(8, new byte[]{0x0d, 0x0a}, true, (byte) 0x3d);
        byte[] input = new byte[]{0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07};
        byte[] expected = new byte[]{0x48, 0x65, 0x6c, 0x6c, 0x6f, 0x3d, 0x3d, 0x0d, 0x0a};
        byte[] actual = base32.encode(input, 2, 4);
        assertArrayEquals(expected, actual);
    }

    @Test
    @Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testGetChunkSeparator_CykQ0() {
        byte[] expected = new byte[]{10};
        byte[] actual = Base32.getChunkSeparator();
        assertArrayEquals(expected, actual);
    }

    @Test
    @Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testGetChunkSeparatorWithLineLength_Pciw1() {
        byte[] expected = new byte[]{10};
        Base32 base32 = new Base32(10);
        byte[] actual = base32.getChunkSeparator();
        assertArrayEquals(expected, actual);
    }

    @Test
    @Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testGetChunkSeparatorWithLineLengthAndLineSeparator_QIjk2() {
        byte[] expected = new byte[]{10};
        Base32 base32 = new Base32(10, new byte[]{10});
        byte[] actual = base32.getChunkSeparator();
        assertArrayEquals(expected, actual);
    }

    @Test
    @Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testGetChunkSeparatorWithLineLengthAndLineSeparatorAndUseHex_yYmN3() {
        byte[] expected = new byte[]{10};
        Base32 base32 = new Base32(10, new byte[]{10}, true);
        byte[] actual = base32.getChunkSeparator();
        assertArrayEquals(expected, actual);
    }

    @Test
    @Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testGetChunkSeparatorWithLineLengthAndLineSeparatorAndUseHexAndPadding_oSKE4() {
        byte[] expected = new byte[]{10};
        Base32 base32 = new Base32(10, new byte[]{10}, true, (byte) 0);
        byte[] actual = base32.getChunkSeparator();
        assertArrayEquals(expected, actual);
    }

    @Test
    @Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testGetChunkSeparatorWithLineLengthAndLineSeparatorAndUseHexAndPaddingAndDecodingPolicy_glNH5() {
        byte[] expected = new byte[]{10};
        Base32 base32 = new Base32(10, new byte[]{10}, true, (byte) 0, CodecPolicy.STRICT);
        byte[] actual = base32.getChunkSeparator();
        assertArrayEquals(expected, actual);
    }

    @Test
    @Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testGetChunkSeparatorWithUseHex_vfbS6() {
        byte[] expected = new byte[]{10};
        Base32 base32 = new Base32(true);
        byte[] actual = base32.getChunkSeparator();
        assertArrayEquals(expected, actual);
    }

    @Test
    @Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testGetChunkSeparatorWithLineLengthAndLineSeparatorAndUseHexAndPaddingAndDecodingPolicy_IhPJ7() {
        byte[] expected = new byte[]{10};
        Base32 base32 = new Base32(10, new byte[]{10}, true, (byte) 0, CodecPolicy.LENIENT);
        byte[] actual = base32.getChunkSeparator();
        assertArrayEquals(expected, actual);
    }

    @Test
    @Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testEncodeWithHex_EIBq2_WVat0() throws EncoderException {
        Base32 base32 = new Base32(false, (byte) 0);
        byte[] input = new byte[]{0, 1, 2, 3};
        String expected = "[65, 65, 65, 81, 69, 65, 89, 0]";
        assertEquals(expected, base32.encode(input));
    }

    @Test
    @Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testGetLineSeparatorWithNoLineSeparatorAndNoPolicyAndNoPadAndNoUseHexAndNoLineLength_abYF5() {
        Base32 base32 = new Base32();
        assertArrayEquals(new byte[0], base32.getLineSeparator());
    }

    @Test
    @Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testIsInAlphabetWith0_oaUv0_fid2() {
        Base32 base32 = new Base32();
        assertTrue(base32.isInAlphabet((byte) 0));
    }

    @Test
    @Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testIsInAlphabetWith255_Dpcg1_fid2() {
        Base32 base32 = new Base32();
        assertTrue(base32.isInAlphabet((byte) 255));
    }

    @Test
    @Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testDecodeWithLineLength_eMXP1() {
        Base32 base32 = new Base32(8);
        String input = "ABCDEFGHIJKLMNOPQRSTUVWXYZ";
        byte[] expected = {0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15};
        assertArrayEquals(expected, base32.decode(input));
    }

    @Test
    @Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testEncodeAsString_OeZv0_fid2() {
        Base32 base32 = new Base32();
        byte[] pArray = new byte[]{0, 1, 2, 3};
        assertEquals("ABCDEFG", base32.encodeAsString(pArray));
    }

    @Test
    @Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testEncodeAsStringWithLineLength_NBYI1_fid2() {
        Base32 base32 = new Base32(8);
        byte[] pArray = new byte[]{0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15};
        assertEquals("ABCDEFGHIJKLMNOPQRSTUV", base32.encodeAsString(pArray));
    }

    @Test
    @Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testEncodeAsStringWithHex_GiHX3_fid2() {
        Base32 base32 = new Base32(true);
        byte[] pArray = new byte[]{0, 1, 2, 3};
        assertEquals("0123456789ABCDEF", base32.encodeAsString(pArray));
    }

    @Test
    @Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testEncodeAsStringWithPadding_JNgF4_fid2() {
        Base32 base32 = new Base32(true, (byte) '=');
        byte[] pArray = new byte[]{0, 1, 2, 3};
        assertEquals("0123456789ABCDE=", base32.encodeAsString(pArray));
    }

    @Test
    @Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void isInAlphabet_WithStringParameter_ReturnsFalse_zZqU1_fid2() {
        Base32 base32 = new Base32();
        String basen = "test";
        boolean actual = base32.isInAlphabet(basen);
        assertFalse(actual);
    }

    @Test
    @Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void isInAlphabet_WithStringParameter_ReturnsFalse_ForLineLength_KWIO3_fid2() {
        Base32 base32 = new Base32(10);
        String basen = "test";
        boolean actual = base32.isInAlphabet(basen);
        assertFalse(actual);
    }

    @Test
    @Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void isInAlphabet_WithStringParameter_ReturnsFalse_ForLineLengthAndLineSeparator_rMNS5_fid2() {
        Base32 base32 = new Base32(10, new byte[]{0x0A});
        String basen = "test";
        boolean actual = base32.isInAlphabet(basen);
        assertFalse(actual);
    }

    @Test
    @Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void isInAlphabet_WithStringParameter_ReturnsFalse_ForLineLengthAndLineSeparatorAndUseHex_MYhL7_fid2() {
        Base32 base32 = new Base32(10, new byte[]{0x0A}, true);
        String basen = "test";
        boolean actual = base32.isInAlphabet(basen);
        assertFalse(actual);
    }

    @Test
    @Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void isInAlphabet_WithStringParameter_ReturnsFalse_ForLineLengthAndLineSeparatorAndUseHexAndPadding_zpQJ9_fid2() {
        Base32 base32 = new Base32(10, new byte[]{0x0A}, true, (byte) 0x3D);
        String basen = "test";
        boolean actual = base32.isInAlphabet(basen);
        assertFalse(actual);
    }

    @Test
    @Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void isInAlphabet_WithStringParameter_ReturnsFalse_ForUseHex_dtSV11_fid2() {
        Base32 base32 = new Base32(true);
        String basen = "test";
        boolean actual = base32.isInAlphabet(basen);
        assertFalse(actual);
    }

    @Test
    @Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testEncode_MAXl0_fid2() throws EncoderException {
        Base32 base32 = new Base32();
        byte[] input = new byte[]{0, 1, 2, 3};
        String expected = "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567";
        assertEquals(expected, base32.encode(input));
    }

    @Test
    @Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testEncodeWithPadding_TchS3_fid2() throws EncoderException {
        Base32 base32 = new Base32(false, (byte) '_');
        byte[] input = new byte[]{0, 1, 2, 3};
        String expected = "ABCDEFGHIJKLMNOPQRSTUV_______";
        assertEquals(expected, base32.encode(input));
    }

    @Test
    @Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testGetEncodedLengthWithLineLengthAndSeparator_wqiB2_fid2() {
        Base32 base32 = new Base32(8, new byte[]{'\r', '\n'});
        byte[] array = new byte[10];
        assertEquals(22, base32.getEncodedLength(array));
    }

    @Test
    @Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testGetEncodedLengthWithHex_luHZ3_fid2() {
        Base32 base32 = new Base32(true);
        byte[] array = new byte[10];
        assertEquals(20, base32.getEncodedLength(array));
    }

    @Test
    @Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testGetEncodedLengthWithCustomPadding_SrMy4_fid2() {
        Base32 base32 = new Base32(true, (byte) '$');
        byte[] array = new byte[10];
        assertEquals(20, base32.getEncodedLength(array));
    }

    @Test
    @Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testGetEncodedLengthWithAllOptions_aWKd5_fid2() {
        Base32 base32 = new Base32(8, new byte[]{'\r', '\n'}, true, (byte) '$', CodecPolicy.LENIENT);
        byte[] array = new byte[10];
        assertEquals(26, base32.getEncodedLength(array));
    }

    @Test
    @Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testGetDefaultBufferSize_kqSk0_fid2() {
        Base32 base32 = new Base32();
        assertEquals(1024, base32.getDefaultBufferSize());
    }

    @Test
    @Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testGetDefaultBufferSizeWithLineLength_axSm1_fid2() {
        Base32 base32 = new Base32(10);
        assertEquals(1024, base32.getDefaultBufferSize());
    }

    @Test
    @Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testGetDefaultBufferSizeWithLineLengthAndSeparator_mQDT2_fid2() {
        Base32 base32 = new Base32(10, new byte[]{'\n'});
        assertEquals(1024, base32.getDefaultBufferSize());
    }

    @Test
    @Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testGetDefaultBufferSizeWithLineLengthAndSeparatorAndUseHex_VBSV3_fid2() {
        Base32 base32 = new Base32(10, new byte[]{'\n'}, true);
        assertEquals(1024, base32.getDefaultBufferSize());
    }

    @Test
    @Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testGetDefaultBufferSizeWithLineLengthAndSeparatorAndUseHexAndPadding_bBMc4_fid2() {
        Base32 base32 = new Base32(10, new byte[]{'\n'}, true, (byte) '=', CodecPolicy.LENIENT);
        assertEquals(1024, base32.getDefaultBufferSize());
    }

    @Test
    @Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testGetDefaultBufferSizeWithUseHex_tRWs5_fid2() {
        Base32 base32 = new Base32(true);
        assertEquals(1024, base32.getDefaultBufferSize());
    }

    @Test
    @Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testGetDefaultBufferSizeWithLineLengthAndSeparatorAndUseHexAndPadding_wPHG6_fid2() {
        Base32 base32 = new Base32(10, new byte[]{'\n'}, true, (byte) '=');
        assertEquals(1024, base32.getDefaultBufferSize());
    }

    @Test
    @Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testGetDefaultBufferSizeWithPad_TaGB8_fid2() {
        Base32 base32 = new Base32((byte) '=');
        assertEquals(1024, base32.getDefaultBufferSize());
    }

    @Test
    @Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testGetDefaultBufferSizeWithUseHexAndPadding_ddmT9_fid2() {
        Base32 base32 = new Base32(true, (byte) '=');
        assertEquals(1024, base32.getDefaultBufferSize());
    }

    @Test
    @Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testIsInAlphabetWithArrayOctetAndAllowWSPad_LnTu0_fid2() {
        Base32 base32 = new Base32(true);
        byte[] arrayOctet = new byte[]{0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y', 'z', 'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z'};
        assertTrue(base32.isInAlphabet(arrayOctet, true));
    }

    @Test
    @Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testEncodeToString_rsAR0_fid2() {
        Base32 base32 = new Base32();
        byte[] array = new byte[]{0, 1, 2, 3};
        String encodedString = base32.encodeToString(array);
        assertEquals("AAECAwQ=", encodedString);
    }

    @Test
    @Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testEncodeToStringWithHex_zFjT3_fid2() {
        Base32 base32 = new Base32(true);
        byte[] array = new byte[]{0, 1, 2, 3};
        String encodedString = base32.encodeToString(array);
        assertEquals("010203", encodedString);
    }

    @Test
    @Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testEncodeToStringWithPadding_TIoA4_fid2() {
        Base32 base32 = new Base32(false, (byte) '=');
        byte[] array = new byte[]{0, 1, 2, 3};
        String encodedString = base32.encodeToString(array);
        assertEquals("AAECAwQ=", encodedString);
    }

    @Test
    @Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testDecode_byte_array_gUsZ0() throws DecoderException {
        Base32 base32 = new Base32();
        byte[] input = new byte[]{0, 1, 2, 3};
        byte[] expected = new byte[]{4, 5, 6, 7};
        byte[] actual = base32.decode(input);
        assertEquals(expected, actual);
    }

    @Test
    @Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testEncodeWithHex_EIBq2_WVat0_fid2() throws EncoderException {
        Base32 base32 = new Base32(false, (byte) 0);
        byte[] input = new byte[]{0, 1, 2, 3};
        String expected = "0123456789ABCDEFGHIJKLMNOPQRSTUV";
        assertEquals(expected, base32.encode(input));
    }
}