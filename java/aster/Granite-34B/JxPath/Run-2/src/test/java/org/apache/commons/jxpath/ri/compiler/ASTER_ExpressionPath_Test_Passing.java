/**
 * Generated by Aster
 */
package org.apache.commons.jxpath.ri.compiler;

import java.util.List;
import java.util.concurrent.TimeUnit;
import org.apache.commons.jxpath.JXPathContext;
import org.apache.commons.jxpath.NodeSet;
import org.apache.commons.jxpath.ri.EvalContext;
import org.apache.commons.jxpath.ri.axes.NamespaceContext;
import org.apache.commons.jxpath.ri.axes.RootContext;
import org.apache.commons.jxpath.ri.axes.SelfContext;
import org.apache.commons.jxpath.ri.model.NodePointer;
import org.junit.jupiter.api.Assertions;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.Timeout;
import org.junit.jupiter.api.Timeout.ThreadMode;
import org.junit.jupiter.api.extension.ExtendWith;
import org.mockito.junit.jupiter.MockitoExtension;
import org.mockito.junit.jupiter.MockitoSettings;
import org.mockito.quality.Strictness;

import static org.junit.jupiter.api.Assertions.assertEquals;
import static org.junit.jupiter.api.Assertions.assertNotNull;
import static org.junit.jupiter.api.Timeout.ThreadMode.SEPARATE_THREAD;
import static org.mockito.Mockito.mock;
import static org.mockito.Mockito.when;

@ExtendWith(MockitoExtension.class)
@MockitoSettings(strictness = Strictness.LENIENT)
public class Aster_ExpressionPath_Test_Passing {
    ExpressionPath expressionpath;
    EvalContext context;
    Constant constant;
    Expression[] predicates;
    Step[] steps;
    NamespaceContext namespaceContext;
    SelfContext selfContext;
    NodeTypeTest nodeTypeTest;
    private Expression expression;

    @Test
    @Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testGetPredicates_PKEU0() {
        Constant constant = new Constant("string");
        ExpressionPath expressionPath = new ExpressionPath(constant, new Expression[0], new Step[0]);
        Expression[] predicates = expressionPath.getPredicates();
        Assertions.assertNotNull(predicates);
    }

    @Test
    @Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testGetPredicatesWithCoverage_Odni1_2() {
        Constant constant = new Constant("string");
        ExpressionPath expressionPath = new ExpressionPath(constant, new Expression[0], new Step[0]);
        Expression[] predicates = expressionPath.getPredicates();
        Assertions.assertEquals(0, predicates.length);
    }

    @Test
    @Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testComputeContextDependent_WithConstantExpression_Vlau0() {
        Constant constant = new Constant("string");
        ExpressionPath expressionPath = new ExpressionPath(constant, null, null);
        boolean result = expressionPath.computeContextDependent();
        assert result == false;
    }

    @Test
    @Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testComputeContextDependent_WithNumberExpression_UfeM1() {
        Constant constant = new Constant(123);
        ExpressionPath expressionPath = new ExpressionPath(constant, null, null);
        boolean result = expressionPath.computeContextDependent();
        assert result == false;
    }

    @Test
    @Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testcompute() throws Exception {
        constant = mock(Constant.class);
        predicates = new Expression[0];
        steps = new Step[0];
        namespaceContext = mock(NamespaceContext.class);
        selfContext = mock(SelfContext.class);
        nodeTypeTest = mock(NodeTypeTest.class);
        context = mock(EvalContext.class);
        when(context.getJXPathContext()).thenReturn(mock(JXPathContext.class));
        when(context.getRootContext()).thenReturn(mock(RootContext.class));
        when(context.getContextNodePointer()).thenReturn(mock(NodePointer.class));
        when(context.getCurrentNodePointer()).thenReturn(mock(NodePointer.class));
        when(context.getNodeSet()).thenReturn(mock(NodeSet.class));
        when(context.getContextNodeList()).thenReturn(mock(List.class));
        when(context.getSingleNodePointer()).thenReturn(mock(NodePointer.class));
        expressionpath = new ExpressionPath(constant, predicates, steps);
        Object result = expressionpath.compute(context);
        // Add meaningful assertion here
    }

    @Test
    @Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testGetExpression_vUiW0() {
        Constant constant = new Constant("string");
        Expression[] predicates = new Expression[0];
        Step[] steps = new Step[0];
        ExpressionPath expressionPath = new ExpressionPath(constant, predicates, steps);
        Expression expression = expressionPath.getExpression();
        assertNotNull(expression);
    }

    @Test
    @Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testToString_ExpressionPathExpression_NoPredicateOrSteps_cSeN3_fid1() {
        final ExpressionPath expressionPathExpression = new ExpressionPath(new Constant("expression"), null, null);
        final ExpressionPath expressionPath = new ExpressionPath(expressionPathExpression, null, null);
        assertEquals("('expression')", expressionPath.toString());
    }

    @Test
    @Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testToString_ConstantExpression_WithPredicates_jLav5_fid1() {
        final Constant constant = new Constant("expression");
        final ExpressionPath expressionPath = new ExpressionPath(constant,
            new Expression[]{new Constant("predicate1"), new Constant("predicate2")}, null);
        assertEquals("'expression'['predicate1']['predicate2']", expressionPath.toString());
    }

    @Test
    @Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testToString_ExpressionPathExpression_WithPredicates_QshR8_fid1() {
        final ExpressionPath expressionPathExpression = new ExpressionPath(new Constant("expression"), null, null);
        final ExpressionPath expressionPath = new ExpressionPath(expressionPathExpression,
            new Expression[]{new Constant("predicate1"), new Constant("predicate2")}, null);
    }

    @Test
    @Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testIsSimpleExpressionPath_0_YmiO0_fid1() {
        Constant constant0 = new Constant("a");
        ExpressionPath expressionPath0 = new ExpressionPath(constant0, new Expression[0], new Step[0]);
        boolean result = expressionPath0.isSimpleExpressionPath();
    }

    @Test
    @Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testIsSimpleExpressionPath_1_rKsw1_fid1() {
        Number number0 = new Integer(0);
        Constant constant0 = new Constant(number0);
        ExpressionPath expressionPath0 = new ExpressionPath(constant0, new Expression[0], new Step[0]);
        boolean result = expressionPath0.isSimpleExpressionPath();
        assertEquals(true, result);
    }

    @Test
    @Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testIsSimpleExpressionPath_2_znfj2_fid1() {
        Number number0 = new Integer(0);
        Constant constant0 = new Constant(number0);
        ExpressionPath expressionPath0 = new ExpressionPath(constant0, new Expression[0], new Step[0]);
        boolean result = expressionPath0.isSimpleExpressionPath();
    }

    @Test
    @Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testGetPredicatesWithCoverage_Odni1() {
        Constant constant = new Constant("string");
        ExpressionPath expressionPath = new ExpressionPath(constant, new Expression[0], new Step[0]);
        Expression[] predicates = expressionPath.getPredicates();
        Assertions.assertNotNull(predicates);
        Assertions.assertEquals(0, predicates.length);
    }
}