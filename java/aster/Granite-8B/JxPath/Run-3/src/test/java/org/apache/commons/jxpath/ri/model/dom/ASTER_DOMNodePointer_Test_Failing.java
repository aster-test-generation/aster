/**
 * Generated by Aster
 */
package org.apache.commons.jxpath.ri.model.dom;

import java.util.Locale;
import java.util.Map;
import java.util.concurrent.TimeUnit;
import org.apache.commons.jxpath.JXPathException;
import org.apache.commons.jxpath.ri.Compiler;
import org.apache.commons.jxpath.ri.NamespaceResolver;
import org.apache.commons.jxpath.ri.QName;
import org.apache.commons.jxpath.ri.compiler.NodeNameTest;
import org.apache.commons.jxpath.ri.compiler.NodeTest;
import org.apache.commons.jxpath.ri.compiler.NodeTypeTest;
import org.apache.commons.jxpath.ri.compiler.ProcessingInstructionTest;
import org.apache.commons.jxpath.ri.model.NodeIterator;
import org.apache.commons.jxpath.ri.model.NodePointer;
import org.apache.commons.jxpath.ri.model.VariablePointer;
import org.apache.commons.jxpath.servlet.KeywordVariables;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.Timeout;
import org.junit.jupiter.api.Timeout.ThreadMode;
import org.junit.jupiter.api.extension.ExtendWith;
import org.mockito.Mock;
import org.mockito.Mockito;
import org.mockito.junit.jupiter.MockitoExtension;
import org.mockito.junit.jupiter.MockitoSettings;
import org.mockito.quality.Strictness;
import org.w3c.dom.*;

import static org.junit.jupiter.api.Assertions.*;
import static org.junit.jupiter.api.Timeout.ThreadMode.SEPARATE_THREAD;
import static org.mockito.Mockito.*;

@ExtendWith(MockitoExtension.class)
@MockitoSettings(strictness = Strictness.LENIENT)
public class Aster_DOMNodePointer_Test_Failing {
    Node node;
    DOMNodePointer domnodepointer;
    NodePointer nodepointer;
    NamedNodeMap namednodemap;
    private Attr attr;
    private NodeList nodelist;
    private Document document;
    private Locale locale;
    private VariablePointer parent;
    private DOMNodePointer domNodePointer;
    private VariablePointer variablePointer;
    private KeywordVariables keywordVariables;
    @Mock
    private Node mockNode;
    private Element element;
    private QName name;
    @Mock
    private Node parentNode;
    private NodeTest test;
    private boolean reverse;
    private NodePointer startWith;
    private NodeIterator nodeIterator;
    private String defaultNamespace;
    @Mock
    private Node removedNode;
    private String id;
    private KeywordVariables variables;
    private Map<String, String> namespaces;
    private NamespaceResolver localNamespaceResolver;
    @Mock
    private NamespaceResolver namespaceResolver;

    @Test
    @Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testsetValue() throws Exception {
        node = mock(Node.class);
        nodelist = mock(NodeList.class);
        document = mock(Document.class);
        domnodepointer = new DOMNodePointer(node, Locale.getDefault(), null);
        when(node.removeChild(any(Node.class))).thenReturn(node);
        when(node.cloneNode(any())).thenReturn(node);
        when(nodelist.item(any())).thenReturn(node);
        when(node.appendChild(any(Node.class))).thenReturn(node);
        when(node.getParentNode()).thenReturn(node);
        when(node.getOwnerDocument()).thenReturn(document);
        when(node.getChildNodes()).thenReturn(nodelist);
        // Test case 1: Setting value to a text or CDATA node
        String value = "Hello, World!";
        domnodepointer.setValue(value);
        verify(node, times(1)).setNodeValue(value);
        // Test case 2: Setting value to a non-text or CDATA node
        when(node.getNodeType()).thenReturn(Node.ELEMENT_NODE);
        domnodepointer.setValue(value);
        verify(node, times(1)).removeChild(any(Node.class));
        verify(node, times(1)).appendChild(any(Node.class));
        // Test case 3: Setting value to null
        domnodepointer.setValue(null);
        verify(node, times(1)).getParentNode();
        verify(node, times(1)).removeChild(any(Node.class));
    }

    @Test
    @Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testgetImmediateNode() throws Exception {
        node = mockNode;
        domnodepointer = new DOMNodePointer(node, Locale.getDefault(), "1");
        when(mockNode.getTextContent()).thenReturn("mockNode");
        assertEquals("mockNode", domnodepointer.getImmediateNode());
    }

    @Test
    @Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testFindEnclosingAttribute() {
        node = mock(Node.class);
        element = mock(Element.class);
        domNodePointer = new DOMNodePointer(node, Locale.getDefault(), null);
        when(node.getParentNode()).thenReturn(node);
        when(node.getNodeType()).thenReturn(Node.ELEMENT_NODE);
        when(element.getAttribute("attrName")).thenReturn("attrValue");
        when(node.getNodeValue()).thenReturn("nodeValue");
        String result = DOMNodePointer.findEnclosingAttribute(node, "attrName");
        assertEquals("attrValue", result);
    }

    @Test
    @Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testHashCode() throws Exception {
        node = mock(Node.class);
        domnodepointer = new DOMNodePointer(node, Locale.getDefault(), null);
        when(node.hashCode()).thenReturn(123);
        assertEquals(123, domnodepointer.hashCode());
    }

    @Test
    @Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testAttributeIterator() {
        locale = mock(Locale.class);
        node = mock(Node.class);
        variablePointer = mock(VariablePointer.class);
        keywordVariables = mock(KeywordVariables.class);
        name = mock(QName.class);
        domNodePointer = new DOMNodePointer(node, locale);
        when(domNodePointer.attributeIterator(name)).thenReturn(new DOMAttributeIterator(domNodePointer, name));
        NodeIterator actual = domNodePointer.attributeIterator(name);
        NodeIterator expected = new DOMAttributeIterator(domNodePointer, name);
        assertEquals(expected, actual);
    }

    @Test
    @Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testcreateAttribute() throws Exception {
        element = mock(Element.class);
        domnodepointer = new DOMNodePointer(element, Locale.getDefault(), null);
        when(element.hasAttribute("test")).thenReturn(false);
        when(element.hasAttributeNS("test", "test")).thenReturn(false);
        when(element.hasAttributes()).thenReturn(false);
        NodePointer nodePointer = domnodepointer.createAttribute(null, new QName("test"));
        verify(element, times(1)).setAttribute("test", "");
        verify(element, never()).setAttributeNS(any(), any(), any());
        assertEquals(element.getAttributes().item(0), nodePointer.getNode());
    }

    @Test
    @Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testGetValue_1() throws Exception {
        node = mock(Node.class);
        domnodepointer = new DOMNodePointer(node, Locale.getDefault(), null);
        when(node.getParentNode()).thenReturn(node);
        when(node.getChildNodes()).thenReturn(nodelist);
        // Test when node is a COMMENT_NODE
        when(node.getNodeType()).thenReturn(Node.COMMENT_NODE);
        when(((Comment) node).getData()).thenReturn("This is a comment");
        // Test when node is not a COMMENT_NODE
        when(node.getNodeType()).thenReturn(Node.ELEMENT_NODE);
        when(node.getTextContent()).thenReturn("This is a text node");
        assertEquals("This is a comment", domnodepointer.getValue());
    }

    @Test
    @Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testGetValue_2() throws Exception {
        node = mock(Node.class);
        domnodepointer = new DOMNodePointer(node, Locale.getDefault(), null);
        when(node.getParentNode()).thenReturn(node);
        when(node.getChildNodes()).thenReturn(nodelist);
        // Test when node is a COMMENT_NODE
        when(node.getNodeType()).thenReturn(Node.COMMENT_NODE);
        when(((Comment) node).getData()).thenReturn("This is a comment");
        // Test when node is not a COMMENT_NODE
        when(node.getNodeType()).thenReturn(Node.ELEMENT_NODE);
        when(node.getTextContent()).thenReturn("This is a text node");
        assertEquals("This is a text node", domnodepointer.getValue());
    }

    @Test
    @Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void remove_kksg0()
    {
        final Node parent = node.getParentNode();
        if (parent == null) {
            throw new JXPathException("Cannot remove root DOM node");
        }
        parent.removeChild(node);
    }

    @Test
    @Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testIsLanguage_1() {
        node = mock(Node.class);
        element = mock(Element.class);
        domnodepointer = new DOMNodePointer(node, Locale.ENGLISH);
        when(node.getParentNode()).thenReturn(node);
        when(node.getNodeType()).thenReturn(Node.ELEMENT_NODE);
        when(element.getTagName()).thenReturn("div");
        when(node.getLocalName()).thenReturn("div");
        when(node.getNodeName()).thenReturn("div");
        when(node.getNodeValue()).thenReturn("Hello World");
        assertTrue(domnodepointer.isLanguage("en"));
    }

    @Test
    @Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testIsLanguage_2() {
        node = mock(Node.class);
        element = mock(Element.class);
        domnodepointer = new DOMNodePointer(node, Locale.ENGLISH);
        when(node.getParentNode()).thenReturn(node);
        when(node.getNodeType()).thenReturn(Node.ELEMENT_NODE);
        when(element.getTagName()).thenReturn("div");
        when(node.getLocalName()).thenReturn("div");
        when(node.getNodeName()).thenReturn("div");
        when(node.getNodeValue()).thenReturn("Hello World");
        assertFalse(domnodepointer.isLanguage("fr"));
    }

    @Test
    @Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testNullNode_pEpF0() {
        assertNull(DOMNodePointer.getPrefix(null));
    }

    @Test
    @Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testtestNode_1() throws Exception {
        node = mock(Node.class);
        attr = mock(Attr.class);
        domnodepointer = new DOMNodePointer(node, Locale.getDefault(), null);
        when(node.getParentNode()).thenReturn(node);
        // Test case 1: Test when test is null
        boolean result = DOMNodePointer.testNode(node, null);
        // Test case 2: Test when test is a NodeNameTest and node is not an element node
        when(node.getNodeType()).thenReturn(Node.TEXT_NODE);
        NodeNameTest nodeNameTest = mock(NodeNameTest.class);
        when(nodeNameTest.getNodeName()).thenReturn(mock(QName.class));
        boolean result2 = DOMNodePointer.testNode(node, nodeNameTest);
        // Test case 3: Test when test is a NodeNameTest and node is an element node
        when(node.getNodeType()).thenReturn(Node.ELEMENT_NODE);
        when(nodeNameTest.getNodeName()).thenReturn(mock(QName.class));
        boolean result3 = DOMNodePointer.testNode(node, nodeNameTest);
        // Test case 4: Test when test is a NodeTypeTest and node type matches
        NodeTypeTest nodeTypeTest = mock(NodeTypeTest.class);
        when(nodeTypeTest.getNodeType()).thenReturn(Compiler.NODE_TYPE_NODE);
        boolean result4 = DOMNodePointer.testNode(node, nodeTypeTest);
        // Test case 5: Test when test is a ProcessingInstructionTest and node is a processing instruction node
        ProcessingInstructionTest processingInstructionTest = mock(ProcessingInstructionTest.class);
        when(processingInstructionTest.getTarget()).thenReturn("test");
        when(node.getNodeType()).thenReturn(Node.PROCESSING_INSTRUCTION_NODE);
        when(node.getNodeName()).thenReturn("test");
        boolean result5 = DOMNodePointer.testNode(node, processingInstructionTest);
        // Test case 6: Test when test is a ProcessingInstructionTest and node is not a processing instruction node
        when(node.getNodeType()).thenReturn(Node.TEXT_NODE);
        boolean result6 = DOMNodePointer.testNode(node, processingInstructionTest);
        assertTrue(result);
    }

    @Test
    @Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testtestNode_2() throws Exception {
        node = mock(Node.class);
        attr = mock(Attr.class);
        domnodepointer = new DOMNodePointer(node, Locale.getDefault(), null);
        when(node.getParentNode()).thenReturn(node);
        // Test case 1: Test when test is null
        boolean result = DOMNodePointer.testNode(node, null);
        // Test case 2: Test when test is a NodeNameTest and node is not an element node
        when(node.getNodeType()).thenReturn(Node.TEXT_NODE);
        NodeNameTest nodeNameTest = mock(NodeNameTest.class);
        when(nodeNameTest.getNodeName()).thenReturn(mock(QName.class));
        boolean result2 = DOMNodePointer.testNode(node, nodeNameTest);
        // Test case 3: Test when test is a NodeNameTest and node is an element node
        when(node.getNodeType()).thenReturn(Node.ELEMENT_NODE);
        when(nodeNameTest.getNodeName()).thenReturn(mock(QName.class));
        boolean result3 = DOMNodePointer.testNode(node, nodeNameTest);
        // Test case 4: Test when test is a NodeTypeTest and node type matches
        NodeTypeTest nodeTypeTest = mock(NodeTypeTest.class);
        when(nodeTypeTest.getNodeType()).thenReturn(Compiler.NODE_TYPE_NODE);
        boolean result4 = DOMNodePointer.testNode(node, nodeTypeTest);
        // Test case 5: Test when test is a ProcessingInstructionTest and node is a processing instruction node
        ProcessingInstructionTest processingInstructionTest = mock(ProcessingInstructionTest.class);
        when(processingInstructionTest.getTarget()).thenReturn("test");
        when(node.getNodeType()).thenReturn(Node.PROCESSING_INSTRUCTION_NODE);
        when(node.getNodeName()).thenReturn("test");
        boolean result5 = DOMNodePointer.testNode(node, processingInstructionTest);
        // Test case 6: Test when test is a ProcessingInstructionTest and node is not a processing instruction node
        when(node.getNodeType()).thenReturn(Node.TEXT_NODE);
        boolean result6 = DOMNodePointer.testNode(node, processingInstructionTest);
        assertFalse(result2);
    }

    @Test
    @Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testtestNode_3() throws Exception {
        node = mock(Node.class);
        attr = mock(Attr.class);
        domnodepointer = new DOMNodePointer(node, Locale.getDefault(), null);
        when(node.getParentNode()).thenReturn(node);
        // Test case 1: Test when test is null
        boolean result = DOMNodePointer.testNode(node, null);
        // Test case 2: Test when test is a NodeNameTest and node is not an element node
        when(node.getNodeType()).thenReturn(Node.TEXT_NODE);
        NodeNameTest nodeNameTest = mock(NodeNameTest.class);
        when(nodeNameTest.getNodeName()).thenReturn(mock(QName.class));
        boolean result2 = DOMNodePointer.testNode(node, nodeNameTest);
        // Test case 3: Test when test is a NodeNameTest and node is an element node
        when(node.getNodeType()).thenReturn(Node.ELEMENT_NODE);
        when(nodeNameTest.getNodeName()).thenReturn(mock(QName.class));
        boolean result3 = DOMNodePointer.testNode(node, nodeNameTest);
        // Test case 4: Test when test is a NodeTypeTest and node type matches
        NodeTypeTest nodeTypeTest = mock(NodeTypeTest.class);
        when(nodeTypeTest.getNodeType()).thenReturn(Compiler.NODE_TYPE_NODE);
        boolean result4 = DOMNodePointer.testNode(node, nodeTypeTest);
        // Test case 5: Test when test is a ProcessingInstructionTest and node is a processing instruction node
        ProcessingInstructionTest processingInstructionTest = mock(ProcessingInstructionTest.class);
        when(processingInstructionTest.getTarget()).thenReturn("test");
        when(node.getNodeType()).thenReturn(Node.PROCESSING_INSTRUCTION_NODE);
        when(node.getNodeName()).thenReturn("test");
        boolean result5 = DOMNodePointer.testNode(node, processingInstructionTest);
        // Test case 6: Test when test is a ProcessingInstructionTest and node is not a processing instruction node
        when(node.getNodeType()).thenReturn(Node.TEXT_NODE);
        boolean result6 = DOMNodePointer.testNode(node, processingInstructionTest);
        assertTrue(result3);
    }

    @Test
    @Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testtestNode_4() throws Exception {
        node = mock(Node.class);
        attr = mock(Attr.class);
        domnodepointer = new DOMNodePointer(node, Locale.getDefault(), null);
        when(node.getParentNode()).thenReturn(node);
        // Test case 1: Test when test is null
        boolean result = DOMNodePointer.testNode(node, null);
        // Test case 2: Test when test is a NodeNameTest and node is not an element node
        when(node.getNodeType()).thenReturn(Node.TEXT_NODE);
        NodeNameTest nodeNameTest = mock(NodeNameTest.class);
        when(nodeNameTest.getNodeName()).thenReturn(mock(QName.class));
        boolean result2 = DOMNodePointer.testNode(node, nodeNameTest);
        // Test case 3: Test when test is a NodeNameTest and node is an element node
        when(node.getNodeType()).thenReturn(Node.ELEMENT_NODE);
        when(nodeNameTest.getNodeName()).thenReturn(mock(QName.class));
        boolean result3 = DOMNodePointer.testNode(node, nodeNameTest);
        // Test case 4: Test when test is a NodeTypeTest and node type matches
        NodeTypeTest nodeTypeTest = mock(NodeTypeTest.class);
        when(nodeTypeTest.getNodeType()).thenReturn(Compiler.NODE_TYPE_NODE);
        boolean result4 = DOMNodePointer.testNode(node, nodeTypeTest);
        // Test case 5: Test when test is a ProcessingInstructionTest and node is a processing instruction node
        ProcessingInstructionTest processingInstructionTest = mock(ProcessingInstructionTest.class);
        when(processingInstructionTest.getTarget()).thenReturn("test");
        when(node.getNodeType()).thenReturn(Node.PROCESSING_INSTRUCTION_NODE);
        when(node.getNodeName()).thenReturn("test");
        boolean result5 = DOMNodePointer.testNode(node, processingInstructionTest);
        // Test case 6: Test when test is a ProcessingInstructionTest and node is not a processing instruction node
        when(node.getNodeType()).thenReturn(Node.TEXT_NODE);
        boolean result6 = DOMNodePointer.testNode(node, processingInstructionTest);
        assertTrue(result4);
    }

    @Test
    @Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testtestNode_5() throws Exception {
        node = mock(Node.class);
        attr = mock(Attr.class);
        domnodepointer = new DOMNodePointer(node, Locale.getDefault(), null);
        when(node.getParentNode()).thenReturn(node);
        // Test case 1: Test when test is null
        boolean result = DOMNodePointer.testNode(node, null);
        // Test case 2: Test when test is a NodeNameTest and node is not an element node
        when(node.getNodeType()).thenReturn(Node.TEXT_NODE);
        NodeNameTest nodeNameTest = mock(NodeNameTest.class);
        when(nodeNameTest.getNodeName()).thenReturn(mock(QName.class));
        boolean result2 = DOMNodePointer.testNode(node, nodeNameTest);
        // Test case 3: Test when test is a NodeNameTest and node is an element node
        when(node.getNodeType()).thenReturn(Node.ELEMENT_NODE);
        when(nodeNameTest.getNodeName()).thenReturn(mock(QName.class));
        boolean result3 = DOMNodePointer.testNode(node, nodeNameTest);
        // Test case 4: Test when test is a NodeTypeTest and node type matches
        NodeTypeTest nodeTypeTest = mock(NodeTypeTest.class);
        when(nodeTypeTest.getNodeType()).thenReturn(Compiler.NODE_TYPE_NODE);
        boolean result4 = DOMNodePointer.testNode(node, nodeTypeTest);
        // Test case 5: Test when test is a ProcessingInstructionTest and node is a processing instruction node
        ProcessingInstructionTest processingInstructionTest = mock(ProcessingInstructionTest.class);
        when(processingInstructionTest.getTarget()).thenReturn("test");
        when(node.getNodeType()).thenReturn(Node.PROCESSING_INSTRUCTION_NODE);
        when(node.getNodeName()).thenReturn("test");
        boolean result5 = DOMNodePointer.testNode(node, processingInstructionTest);
        // Test case 6: Test when test is a ProcessingInstructionTest and node is not a processing instruction node
        when(node.getNodeType()).thenReturn(Node.TEXT_NODE);
        boolean result6 = DOMNodePointer.testNode(node, processingInstructionTest);
        assertTrue(result5);
    }

    @Test
    @Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testtestNode_6() throws Exception {
        node = mock(Node.class);
        attr = mock(Attr.class);
        domnodepointer = new DOMNodePointer(node, Locale.getDefault(), null);
        when(node.getParentNode()).thenReturn(node);
        // Test case 1: Test when test is null
        boolean result = DOMNodePointer.testNode(node, null);
        // Test case 2: Test when test is a NodeNameTest and node is not an element node
        when(node.getNodeType()).thenReturn(Node.TEXT_NODE);
        NodeNameTest nodeNameTest = mock(NodeNameTest.class);
        when(nodeNameTest.getNodeName()).thenReturn(mock(QName.class));
        boolean result2 = DOMNodePointer.testNode(node, nodeNameTest);
        // Test case 3: Test when test is a NodeNameTest and node is an element node
        when(node.getNodeType()).thenReturn(Node.ELEMENT_NODE);
        when(nodeNameTest.getNodeName()).thenReturn(mock(QName.class));
        boolean result3 = DOMNodePointer.testNode(node, nodeNameTest);
        // Test case 4: Test when test is a NodeTypeTest and node type matches
        NodeTypeTest nodeTypeTest = mock(NodeTypeTest.class);
        when(nodeTypeTest.getNodeType()).thenReturn(Compiler.NODE_TYPE_NODE);
        boolean result4 = DOMNodePointer.testNode(node, nodeTypeTest);
        // Test case 5: Test when test is a ProcessingInstructionTest and node is a processing instruction node
        ProcessingInstructionTest processingInstructionTest = mock(ProcessingInstructionTest.class);
        when(processingInstructionTest.getTarget()).thenReturn("test");
        when(node.getNodeType()).thenReturn(Node.PROCESSING_INSTRUCTION_NODE);
        when(node.getNodeName()).thenReturn("test");
        boolean result5 = DOMNodePointer.testNode(node, processingInstructionTest);
        // Test case 6: Test when test is a ProcessingInstructionTest and node is not a processing instruction node
        when(node.getNodeType()).thenReturn(Node.TEXT_NODE);
        boolean result6 = DOMNodePointer.testNode(node, processingInstructionTest);
        assertFalse(result6);
    }

    @Test
    @Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testCreateChildWithIndex() throws Exception {
        node = mock(Node.class);
        locale = mock(Locale.class);
        parent = mock(VariablePointer.class);
        domnodepointer = new DOMNodePointer(parent, node);
        when(node.appendChild(any(Node.class))).thenReturn(node);
        when(node.removeChild(any(Node.class))).thenReturn(node);
        when(node.cloneNode(any())).thenReturn(node);
        when(node.getPreviousSibling()).thenReturn(node);
        when(node.getParentNode()).thenReturn(node);
        when(node.getOwnerDocument()).thenReturn(document);
        when(node.getChildNodes()).thenReturn(nodelist);
        NodePointer ptr = domnodepointer.createChild(null, null, 1);
        assertNotNull(ptr);
        verify(node, times(1)).insertBefore(any(Node.class), any(Node.class));
    }

    @Test
    @Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testCreateChildWithValue() throws Exception {
        node = mock(Node.class);
        locale = mock(Locale.class);
        parent = mock(VariablePointer.class);
        domnodepointer = new DOMNodePointer(parent, node);
        when(node.appendChild(any(Node.class))).thenReturn(node);
        when(node.removeChild(any(Node.class))).thenReturn(node);
        when(node.cloneNode(any())).thenReturn(node);
        when(node.getPreviousSibling()).thenReturn(node);
        when(node.getParentNode()).thenReturn(node);
        when(node.getOwnerDocument()).thenReturn(document);
        when(node.getChildNodes()).thenReturn(nodelist);
        NodePointer ptr = domnodepointer.createChild(null, null, 0, "value");
        assertNotNull(ptr);
        verify(node, times(1)).appendChild(any(Node.class));
    }

    @Test
    @Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testAsPathWithTextNode_oLLP2() {
        DOMNodePointer pointer = new DOMNodePointer(node, locale);
        assertEquals("/text()[1]", pointer.asPath());
    }

    @Test
    @Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testgetNamespaceResolver() throws Exception {
        domnodepointer = new DOMNodePointer(Mockito.mock(Node.class), Locale.getDefault(), null);
        localNamespaceResolver = Mockito.mock(NamespaceResolver.class);
        Mockito.when(domnodepointer.getNamespaceResolver()).thenReturn(localNamespaceResolver);
        NamespaceResolver result = domnodepointer.getNamespaceResolver();
        assertEquals(localNamespaceResolver, result);
    }

    @Test
    @Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testCreateChild_x_LdYR0() throws Exception {
        node = mock(Node.class);
        locale = mock(Locale.class);
        parent = mock(VariablePointer.class);
        domnodepointer = new DOMNodePointer(parent, node);
        when(node.appendChild(any(Node.class))).thenReturn(node);
        when(node.removeChild(any(Node.class))).thenReturn(node);
        when(node.cloneNode(any())).thenReturn(node);
        when(node.getPreviousSibling()).thenReturn(node);
        when(node.getParentNode()).thenReturn(node);
        when(node.getOwnerDocument()).thenReturn(document);
        when(node.getChildNodes()).thenReturn(nodelist);
        NodePointer ptr = domnodepointer.createChild(null, null, 0);
        assertNotNull(ptr);
        verify(node, times(1)).appendChild(any(Node.class));
    }

    @Test
    @Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testGetNamespaceURI_kquf0() {
        node = mock(Node.class);
        attr = mock(Attr.class);
        domNodePointer = new DOMNodePointer(node, Locale.getDefault(), null);
        when(node.getParentNode()).thenReturn(parentNode);
        when(node.getNodeType()).thenReturn(Node.ELEMENT_NODE);
        when(node.getNodeName()).thenReturn("nodeName");
        when(node.getNodeValue()).thenReturn("nodeValue");
        when(node.getTextContent()).thenReturn("textContent");
        when(node.getLocalName()).thenReturn("localName");
        when(node.getPrefix()).thenReturn("prefix");
        when(node.getNamespaceURI()).thenReturn("namespaceURI");
        when(node.getAttributes()).thenReturn(null);
        assertEquals("namespaceURI", domNodePointer.getNamespaceURI());
    }

    @Test
    @Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testAsPathWithParent_pmcP1_tIeW0() {
        VariablePointer parent = new VariablePointer(new KeywordVariables("keyword", new Object()), new QName(""));
        DOMNodePointer pointer = new DOMNodePointer(parent, node);
        assertEquals(parent.asPath() + "/element[1]", pointer.asPath());
    }

    @Test
    @Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testIsCollection_WhenNodeIsCollection_ReturnsTrue_fid1() {
        node = mock(Node.class);
        locale = mock(Locale.class);
        variablePointer = mock(VariablePointer.class);
        keywordVariables = mock(KeywordVariables.class);
        domNodePointer = new DOMNodePointer(node, locale);
        when(node.isSameNode(any())).thenReturn(true);
        boolean isCollection = domNodePointer.isCollection();
        assertTrue(isCollection);
    }

    @Test
    @Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testgetImmediateNode_fid1() throws Exception {
        node = mockNode;
        domnodepointer = new DOMNodePointer(node, Locale.getDefault(), "1");
        when(mockNode.getTextContent()).thenReturn("Node Text");
        assertEquals("Node Text", domnodepointer.getImmediateNode());
    }

    @Test
    @Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testAttributeIterator_nzug0() {
        DOMNodePointer domNodePointer = new DOMNodePointer(null, null, null);
        QName name = new QName("prefix", "localName");
        NodeIterator nodeIterator = domNodePointer.attributeIterator(name);
    }

    @Test
    @Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testIsLeaf_1_fid1() {
        node = mock(Node.class);
        domnodepointer = new DOMNodePointer(node, Locale.getDefault(), null);
        when(node.hasChildNodes()).thenReturn(true);
        when(node.hasChildNodes()).thenReturn(false);
        assertFalse(domnodepointer.isLeaf());
    }

    @Test
    @Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testEquals_2_fid1() throws Exception {
        node = mock(Node.class);
        domnodepointer = new DOMNodePointer(node, Locale.getDefault(), "id");
        // Test when object is same as this
        // Test when object is instanceof DOMNodePointer and node is same
        DOMNodePointer domNodePointerMock = mock(DOMNodePointer.class);
        when(domNodePointerMock.getNode()).thenReturn(node);
        // Test when object is not instanceof DOMNodePointer
        assertTrue(domnodepointer.equals(domNodePointerMock));
    }

    @Test
    @Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void test1_BxRy0_fid1() {
        QName qName = new QName("qualifiedName");
        DOMNodePointer domNodePointer = new DOMNodePointer(null, null, null);
        assertEquals("", domNodePointer.getDefaultNamespaceURI());
    }

    @Test
    @Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void test2_jUsl1_fid1() {
        QName qName = new QName("prefix", "localName");
        DOMNodePointer domNodePointer = new DOMNodePointer(null, null, null);
        assertEquals("", domNodePointer.getDefaultNamespaceURI());
    }

    @Test
    @Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testAsPathWithProcessingInstruction_uqmu3_fid1() {
        DOMNodePointer pointer = new DOMNodePointer(node, locale);
        assertEquals("/processing-instruction('target')[1]", pointer.asPath());
    }

    @Test
    @Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testAsPathWithDocumentNode_dJEO4_fid1() {
        DOMNodePointer pointer = new DOMNodePointer(node, locale);
        assertEquals("/", pointer.asPath());
    }

    @Test
    @Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testAsPathWithElementNodeAndNamespaceURI_iiuh5_fid1() {
        DOMNodePointer pointer = new DOMNodePointer(node, locale);
        assertEquals("/element[1]", pointer.asPath());
    }

    @Test
    @Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testAsPathWithElementNodeAndPrefix_eeLP7_fid1() {
        DOMNodePointer pointer = new DOMNodePointer(node, locale);
        assertEquals("/prefix:element[1]", pointer.asPath());
    }

    @Test
    @Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testgetPrefix_iitf0_1() throws Exception {
        node = mock(Node.class);
        Locale locale = mock(Locale.class);
        domnodepointer = new DOMNodePointer(node, locale);
        when(node.getPrefix()).thenReturn("prefix");
        when(node.getPrefix()).thenReturn(null);
        when(node.getNodeName()).thenReturn("prefix:localName");
        when(node.getPrefix()).thenReturn(null);
        when(node.getNodeName()).thenReturn("localName");
        assertEquals("prefix", DOMNodePointer.getPrefix(node));
    }

    @Test
    @Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testEquals() throws Exception {
        node = mock(Node.class);
        domnodepointer = new DOMNodePointer(node, Locale.getDefault(), "id");
        // Test when object is same as this
        assertTrue(domnodepointer.equals(domnodepointer));
        // Test when object is instanceof DOMNodePointer and node is same
        DOMNodePointer domNodePointerMock = mock(DOMNodePointer.class);
        when(domNodePointerMock.getNode()).thenReturn(node);
        assertTrue(domnodepointer.equals(domNodePointerMock));
        // Test when object is not instanceof DOMNodePointer
        assertFalse(domnodepointer.equals(new Object()));
    }

    @Test
    @Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testGetValue() throws Exception {
        node = mock(Node.class);
        domnodepointer = new DOMNodePointer(node, Locale.getDefault(), null);
        when(node.getParentNode()).thenReturn(node);
        when(node.getChildNodes()).thenReturn(nodelist);
        // Test when node is a COMMENT_NODE
        when(node.getNodeType()).thenReturn(Node.COMMENT_NODE);
        when(((Comment) node).getData()).thenReturn("This is a comment");
        assertEquals("This is a comment", domnodepointer.getValue());
        // Test when node is not a COMMENT_NODE
        when(node.getNodeType()).thenReturn(Node.ELEMENT_NODE);
        when(node.getTextContent()).thenReturn("This is a text node");
        assertEquals("This is a text node", domnodepointer.getValue());
    }

    @Test
    @Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testIsLanguage() {
        node = mock(Node.class);
        element = mock(Element.class);
        domnodepointer = new DOMNodePointer(node, Locale.ENGLISH);
        when(node.getParentNode()).thenReturn(node);
        when(node.getNodeType()).thenReturn(Node.ELEMENT_NODE);
        when(element.getTagName()).thenReturn("div");
        when(node.getLocalName()).thenReturn("div");
        when(node.getNodeName()).thenReturn("div");
        when(node.getNodeValue()).thenReturn("Hello World");
        assertTrue(domnodepointer.isLanguage("en"));
        assertFalse(domnodepointer.isLanguage("fr"));
    }

    @Test
    @Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testtestNode() throws Exception {
        node = mock(Node.class);
        attr = mock(Attr.class);
        domnodepointer = new DOMNodePointer(node, Locale.getDefault(), null);
        when(node.getParentNode()).thenReturn(node);
        // Test case 1: Test when test is null
        boolean result = DOMNodePointer.testNode(node, null);
        assertTrue(result);
        // Test case 2: Test when test is a NodeNameTest and node is not an element node
        when(node.getNodeType()).thenReturn(Node.TEXT_NODE);
        NodeNameTest nodeNameTest = mock(NodeNameTest.class);
        when(nodeNameTest.getNodeName()).thenReturn(mock(QName.class));
        boolean result2 = DOMNodePointer.testNode(node, nodeNameTest);
        assertFalse(result2);
        // Test case 3: Test when test is a NodeNameTest and node is an element node
        when(node.getNodeType()).thenReturn(Node.ELEMENT_NODE);
        when(nodeNameTest.getNodeName()).thenReturn(mock(QName.class));
        boolean result3 = DOMNodePointer.testNode(node, nodeNameTest);
        assertTrue(result3);
        // Test case 4: Test when test is a NodeTypeTest and node type matches
        NodeTypeTest nodeTypeTest = mock(NodeTypeTest.class);
        when(nodeTypeTest.getNodeType()).thenReturn(Compiler.NODE_TYPE_NODE);
        boolean result4 = DOMNodePointer.testNode(node, nodeTypeTest);
        assertTrue(result4);
        // Test case 5: Test when test is a ProcessingInstructionTest and node is a processing instruction node
        ProcessingInstructionTest processingInstructionTest = mock(ProcessingInstructionTest.class);
        when(processingInstructionTest.getTarget()).thenReturn("test");
        when(node.getNodeType()).thenReturn(Node.PROCESSING_INSTRUCTION_NODE);
        when(node.getNodeName()).thenReturn("test");
        boolean result5 = DOMNodePointer.testNode(node, processingInstructionTest);
        assertTrue(result5);
        // Test case 6: Test when test is a ProcessingInstructionTest and node is not a processing instruction node
        when(node.getNodeType()).thenReturn(Node.TEXT_NODE);
        boolean result6 = DOMNodePointer.testNode(node, processingInstructionTest);
        assertFalse(result6);
    }
}