/**
 * Generated by Aster
 */
package org.apache.commons.codec.binary;

import java.nio.ByteBuffer;
import java.nio.charset.Charset;
import java.nio.charset.StandardCharsets;
import java.util.concurrent.TimeUnit;
import org.apache.commons.codec.DecoderException;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.Timeout;
import org.junit.jupiter.api.Timeout.ThreadMode;

import static org.junit.jupiter.api.Assertions.*;
import static org.junit.jupiter.api.Timeout.ThreadMode.SEPARATE_THREAD;

public class Aster_Hex_Test_Passing {
    @Test
    @Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testEncodeHex_mwMl0() {
        byte[] data = {0x01, 0x02, 0x03};
        char[] expected = {'0', '1', '0', '2', '0', '3'};
        char[] actual = Hex.encodeHex(data, 0, 3, true);
        assertEquals(String.valueOf(expected), String.valueOf(actual));
    }

    @Test
    @Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testToDigitInvalidCharacter_FZEs1() {
        try {
            Hex.toDigit('G', 0);
            fail("Expected DecoderException");
        } catch (DecoderException e) {
            assertTrue(e.getMessage().startsWith("Illegal hexadecimal character G at index 0"));
        }
    }

    @Test
    @Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testEncodeHexString_zJYq0() {
        ByteBuffer data = ByteBuffer.allocate(4);
        data.putInt(123456789);
        data.flip();
        String encodedString = Hex.encodeHexString(data, true);
        assertEquals("075bcd15", encodedString);
    }

    @Test
    @Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testGetCharsetName_Irpj0_1() {
        Hex hex = new Hex(Charset.forName("UTF-8"));
        hex = new Hex("UTF-8");
        hex = new Hex();
        assertEquals("UTF-8", hex.getCharsetName());
    }

    @Test
    @Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testEncodeHexString_EmGF0() {
        byte[] data = {0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15};
        String expected = "000102030405060708090a0b0c0d0e0f";
        String actual = Hex.encodeHexString(data);
        assertEquals(expected, actual);
    }

    @Test
    @Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testEncodeHexString_RvVY0() {
        ByteBuffer data = ByteBuffer.allocate(10);
        String expected = "00000000000000000000";
        String actual = Hex.encodeHexString(data);
        assertEquals(expected, actual);
    }

    @Test
    @Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testEncodeHexString_lPdO0() {
        byte[] data = {0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15};
        boolean toLowerCase = true;
        String expected = "000102030405060708090a0b0c0d0e0f";
        String actual = Hex.encodeHexString(data, toLowerCase);
        assertEquals(expected, actual);
    }

    @Test
    @Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testEncodeHex_ylOB0() {
        byte[] data = new byte[]{1, 2, 3};
        char[] out = new char[6];
        Hex.encodeHex(data, 0, 3, true, out, 0);
        assertEquals("010203", new String(out));
    }

    @Test
    @Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testEncodeHex_NGrW0() {
        byte[] data = {0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15};
        char[] out = new char[data.length * 2];
        Hex.encodeHex(data, 0, data.length, false, out, 0);
        assertEquals("000102030405060708090A0B0C0D0E0F", new String(out));
    }

    @Test
    @Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void test_getCharset_charset_AklC0() {
        Hex hex = new Hex(Charset.forName("UTF-8"));
        assertEquals(Charset.forName("UTF-8"), hex.getCharset());
    }

    @Test
    @Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void test_getCharset_charsetName_SdMb1() {
        Hex hex = new Hex("UTF-8");
        assertEquals(Charset.forName("UTF-8"), hex.getCharset());
    }

    @Test
    @Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void test_getCharset_default_yCoP2() {
        Hex hex = new Hex();
        assertEquals(Charset.defaultCharset(), hex.getCharset());
    }

    @Test
    @Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testEncodeHex_nZZd0() {
        ByteBuffer data = ByteBuffer.allocate(10);
        char[] result = Hex.encodeHex(data);
    }

    @Test
    @Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testEncodeByteBuffer_vKXa1_ZpZN0() {
        Hex hex = new Hex("UTF-8");
        ByteBuffer input = ByteBuffer.wrap("Hello, World!".getBytes());
        String expectedOutput = "48656c6c6f2c20576f726c6421";
        byte[] actualOutput = hex.encode(input);
        assertEquals(expectedOutput, new String(actualOutput, StandardCharsets.UTF_8));
    }

    @Test
    @Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testDecodeByteArray_nSNF1_CMgn0() {
        Hex hex = new Hex();
        byte[] input = "48656C6C6F20576F726C64".getBytes();
        byte[] expected = "Hello World".getBytes();
        try {
            byte[] actual = (byte[]) hex.decode(input);
            assertArrayEquals(expected, actual);
        } catch (DecoderException e) {
            e.printStackTrace();
        }
    }

    @Test
    @Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testGetCharsetName_Irpj0() {
        Hex hex = new Hex(Charset.forName("UTF-8"));
        assertEquals("UTF-8", hex.getCharsetName());
        hex = new Hex("UTF-8");
        assertEquals("UTF-8", hex.getCharsetName());
        hex = new Hex();
        assertEquals("UTF-8", hex.getCharsetName());
    }
}