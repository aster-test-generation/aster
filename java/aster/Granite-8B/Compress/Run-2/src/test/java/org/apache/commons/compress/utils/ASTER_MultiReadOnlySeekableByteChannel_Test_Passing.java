/**
 * Generated by Aster
 */
package org.apache.commons.compress.utils;

import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.Timeout;

import java.io.IOException;
import java.nio.ByteBuffer;
import java.nio.channels.SeekableByteChannel;
import java.util.ArrayList;
import java.util.List;
import java.util.concurrent.TimeUnit;

import static org.junit.jupiter.api.Assertions.*;
import static org.junit.jupiter.api.Timeout.ThreadMode.SEPARATE_THREAD;
import static org.mockito.Mockito.mock;
import static org.mockito.Mockito.when;
public class Aster_MultiReadOnlySeekableByteChannel_Test_Passing {
    private MultiReadOnlySeekableByteChannel channel;
    private List<SeekableByteChannel> channels;
    private ByteBuffer dst;
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testTruncate_WvjM0() throws Exception {
        MultiReadOnlySeekableByteChannel channel = new MultiReadOnlySeekableByteChannel(null);
        long size = 10;
        SeekableByteChannel result = channel.truncate(size);
        assertNotNull(result);
    }
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testConstructorWithNullChannels_Fuos1() throws Exception {
        MultiReadOnlySeekableByteChannel channel = new MultiReadOnlySeekableByteChannel(null);
        assertNotNull(channel);
}
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testConstructorWithEmptyChannels_XowF2() throws Exception {
        List<SeekableByteChannel> channels = new ArrayList<>();
        MultiReadOnlySeekableByteChannel channel = new MultiReadOnlySeekableByteChannel(channels);
        assertNotNull(channel);
}
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testConstructorWithNonEmptyChannels_Essh3() throws Exception {
        List<SeekableByteChannel> channels = new ArrayList<>();
        channels.add(mock(SeekableByteChannel.class));
        MultiReadOnlySeekableByteChannel channel = new MultiReadOnlySeekableByteChannel(channels);
        assertNotNull(channel);
}
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testTruncateWithSizeZero_QTOa4() throws Exception {
        MultiReadOnlySeekableByteChannel channel = new MultiReadOnlySeekableByteChannel(null);
        long size = 0;
        SeekableByteChannel result = channel.truncate(size);
        assertNotNull(result);
}
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testPosition1_sEvf0() throws IOException {
        List<SeekableByteChannel> channels = new ArrayList<>();
        SeekableByteChannel channel1 = mock(SeekableByteChannel.class);
        SeekableByteChannel channel2 = mock(SeekableByteChannel.class);
        channels.add(channel1);
        channels.add(channel2);
        MultiReadOnlySeekableByteChannel multiChannel = new MultiReadOnlySeekableByteChannel(channels);
        when(channel1.size()).thenReturn(10L);
        when(channel2.size()).thenReturn(20L);
        SeekableByteChannel result = multiChannel.position(1, 5L);
        assertEquals(25L, result.position());
    }
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testPosition2_YBrz1() throws IOException {
        List<SeekableByteChannel> channels = new ArrayList<>();
        SeekableByteChannel channel1 = mock(SeekableByteChannel.class);
        SeekableByteChannel channel2 = mock(SeekableByteChannel.class);
        channels.add(channel1);
        channels.add(channel2);
        MultiReadOnlySeekableByteChannel multiChannel = new MultiReadOnlySeekableByteChannel(channels);
        when(channel1.size()).thenReturn(10L);
        when(channel2.size()).thenReturn(20L);
        SeekableByteChannel result = multiChannel.position(0, 5L);
        assertEquals(5L, result.position());
    }
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testPosition3_UBFM2() throws IOException {
        List<SeekableByteChannel> channels = new ArrayList<>();
        SeekableByteChannel channel1 = mock(SeekableByteChannel.class);
        SeekableByteChannel channel2 = mock(SeekableByteChannel.class);
        channels.add(channel1);
        channels.add(channel2);
        MultiReadOnlySeekableByteChannel multiChannel = new MultiReadOnlySeekableByteChannel(channels);
        when(channel1.size()).thenReturn(10L);
        when(channel2.size()).thenReturn(20L);
        SeekableByteChannel result = multiChannel.position(1, 25L);
        assertEquals(45L, result.position());
    }
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testIsOpen_BPmk0() throws Exception {
        List<SeekableByteChannel> channels = new ArrayList<>();
        channels.add(mock(SeekableByteChannel.class));
        channels.add(mock(SeekableByteChannel.class));
        MultiReadOnlySeekableByteChannel multiReadOnlySeekableByteChannel = new MultiReadOnlySeekableByteChannel(channels);
        assertTrue(multiReadOnlySeekableByteChannel.isOpen());
    }
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testWrite_BTZR0() throws Exception {
        List<SeekableByteChannel> channels = new ArrayList<>();
        MultiReadOnlySeekableByteChannel multiReadOnlySeekableByteChannel = new MultiReadOnlySeekableByteChannel(channels);
        ByteBuffer src = ByteBuffer.allocate(10);
        int bytesWritten = multiReadOnlySeekableByteChannel.write(src);
        assert bytesWritten == 10;
    }
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testPosition_FhAg0() throws Exception {
        List<SeekableByteChannel> channels = new ArrayList<>();
        SeekableByteChannel channel1 = mock(SeekableByteChannel.class);
        when(channel1.position()).thenReturn(10L);
        channels.add(channel1);
        SeekableByteChannel channel2 = mock(SeekableByteChannel.class);
        when(channel2.position()).thenReturn(20L);
        channels.add(channel2);
        MultiReadOnlySeekableByteChannel multiChannel = new MultiReadOnlySeekableByteChannel(channels);
        long position = multiChannel.position();
        assertEquals(30L, position);
    }
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void setup_gaGj0() throws Exception {
        channels = new ArrayList<>();
        channel = new MultiReadOnlySeekableByteChannel(channels);
        dst = ByteBuffer.allocate(10);
    }
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void close_isXi3() throws IOException {
        IOException first = null;
        for (final SeekableByteChannel ch : channels) {
            try {
                ch.close();
            } catch (final IOException ex) {
                if (first == null) {
                    first = ex;
                }
            }
        }
        if (first != null) {
            throw new IOException("failed to close wrapped channel", first);
        }
    }
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testSizeWithEmptyChannels_cioj0() throws IOException {
        List<SeekableByteChannel> channels = new ArrayList<>();
        MultiReadOnlySeekableByteChannel channel = new MultiReadOnlySeekableByteChannel(channels);
        long size = channel.size();
        assertEquals(0, size);
    }
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testSizeWithOneChannel_oSIX1() throws IOException {
        SeekableByteChannel channel1 = mock(SeekableByteChannel.class);
        when(channel1.size()).thenReturn(100L);
        List<SeekableByteChannel> channels = new ArrayList<>();
        channels.add(channel1);
        MultiReadOnlySeekableByteChannel multiChannel = new MultiReadOnlySeekableByteChannel(channels);
        long size = multiChannel.size();
        assertEquals(100L, size);
    }
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testSizeWithMultipleChannels_LRWd2() throws IOException {
        SeekableByteChannel channel1 = mock(SeekableByteChannel.class);
        when(channel1.size()).thenReturn(100L);
        SeekableByteChannel channel2 = mock(SeekableByteChannel.class);
        when(channel2.size()).thenReturn(200L);
        List<SeekableByteChannel> channels = new ArrayList<>();
        channels.add(channel1);
        channels.add(channel2);
        MultiReadOnlySeekableByteChannel multiChannel = new MultiReadOnlySeekableByteChannel(channels);
        long size = multiChannel.size();
        assertEquals(300L, size);
    }
}