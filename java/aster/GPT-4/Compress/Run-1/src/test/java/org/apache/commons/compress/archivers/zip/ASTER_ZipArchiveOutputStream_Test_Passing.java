/**
 * Generated by Aster
 */
package org.apache.commons.compress.archivers.zip;

import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.Timeout;
import org.junit.jupiter.api.extension.ExtendWith;
import org.mockito.InjectMocks;
import org.mockito.Mock;
import org.mockito.junit.jupiter.MockitoExtension;
import org.mockito.junit.jupiter.MockitoSettings;
import org.mockito.quality.Strictness;

import java.io.*;
import java.nio.charset.Charset;
import java.nio.file.Path;
import java.util.LinkedList;
import java.util.List;
import java.util.concurrent.TimeUnit;
import java.util.zip.Deflater;

import static org.junit.jupiter.api.Assertions.*;
import static org.junit.jupiter.api.Timeout.ThreadMode.SEPARATE_THREAD;
import static org.mockito.Mockito.*;
@ExtendWith(MockitoExtension.class)
@MockitoSettings(strictness = Strictness.LENIENT)
public class Aster_ZipArchiveOutputStream_Test_Passing {
@Mock
    private OutputStream outputStream;
@Mock
    private StreamCompressor streamCompressor;
@InjectMocks
    private ZipArchiveOutputStream zipArchiveOutputStream;
@Mock
    private ByteArrayOutputStream mockOutputStream;
@Mock
    private ZipArchiveEntry zipArchiveEntry;
@Mock
    private InputStream mockInputStream;
@Mock
    private ZipArchiveEntry mockZipArchiveEntry;
@Mock
    private Path mockPath;
    private long cdLength;
    private final List<ZipArchiveEntry> entries = new LinkedList<>();
    private long eocdLength;
    private String comment = "";
    private long cdOffset;
    private long cdDiskNumberStart;
        private long bytesRead;
        private long dataStart;
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
public void testIsSeekableWithRandomAccessOutputStream_pKjH0() {
    ByteArrayOutputStream baos = new ByteArrayOutputStream();
    ZipArchiveOutputStream zaos = new ZipArchiveOutputStream(baos);
    assertFalse(zaos.isSeekable());
}
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testFinishAlreadyFinished_TJny0() throws IOException {
        File file = new File("test.zip");
        ZipArchiveOutputStream zipOut = new ZipArchiveOutputStream(file);
        zipOut.finish(); // Mark as finished
        try {
            zipOut.finish();
            fail("Should have thrown IOException because the archive is already finished.");
        } catch (IOException e) {
            assertEquals("This archive has already been finished", e.getMessage());
        }
    }
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testFinishAlreadyFinished_dMAK0() throws IOException {
        File tempFile = File.createTempFile("testZip", ".zip");
        ZipArchiveOutputStream zaos = new ZipArchiveOutputStream(tempFile);
        zaos.finish(); // First finish to set finished = true
        try {
            zaos.finish();
            fail("Should have thrown IOException because the archive is already finished");
        } catch (IOException e) {
            assertEquals("This archive has already been finished", e.getMessage());
        }
    }
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testFinish_AlreadyFinished_zxpz3() throws IOException {
        ByteArrayOutputStream out = new ByteArrayOutputStream();
        ZipArchiveOutputStream zaos = new ZipArchiveOutputStream(out);
        zaos.finish();
        assertThrows(IOException.class, zaos::finish);
    }
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testFinish_UnclosedEntry_GuvK4() throws IOException {
        ByteArrayOutputStream out = new ByteArrayOutputStream();
        ZipArchiveOutputStream zaos = new ZipArchiveOutputStream(out);
        ZipArchiveEntry entry = new ZipArchiveEntry("testEntry.txt");
        zaos.putArchiveEntry(entry);
        assertThrows(IOException.class, zaos::finish);
    }
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testFinishAlreadyFinished_LiEa0() throws IOException {
        File tempFile = File.createTempFile("testZip", ".zip");
        ZipArchiveOutputStream zaos = new ZipArchiveOutputStream(tempFile);
        zaos.finish();
        try {
            zaos.finish();
            fail("Should have thrown IOException because the archive is already finished.");
        } catch (IOException e) {
            assertEquals("This archive has already been finished", e.getMessage());
        }
    }
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testFinishWithUnclosedEntries_VJTc1() throws IOException {
        File tempFile = File.createTempFile("testZip", ".zip");
        ZipArchiveOutputStream zaos = new ZipArchiveOutputStream(tempFile);
        zaos.putArchiveEntry(new ZipArchiveEntry("testEntry.txt"));
        try {
            zaos.finish();
            fail("Should have thrown IOException because there are unclosed entries.");
        } catch (IOException e) {
            assertEquals("This archive contains unclosed entries.", e.getMessage());
        }
    }
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testFinishWithZip64_yzNa4() throws IOException {
        File tempFile = File.createTempFile("testZip", ".zip");
        ZipArchiveOutputStream zaos = new ZipArchiveOutputStream(tempFile);
        ZipArchiveEntry entry = new ZipArchiveEntry("largeFile");
        entry.setSize(ZipConstants.ZIP64_MAGIC + 1); // Force Zip64 format
        zaos.putArchiveEntry(entry);
        zaos.closeArchiveEntry();
        zaos.finish();
    }
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testFinishAlreadyFinished_bLgG0_1() throws IOException {
        File tempFile = File.createTempFile("testZip", ".zip");
        ZipArchiveOutputStream zos = new ZipArchiveOutputStream(tempFile);
        zos.finish(); // First finish to set finished = true
        Exception exception = assertThrows(IOException.class, zos::finish);}
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testFinishWithUnclosedEntries_fxfc1_1() throws IOException {
        File tempFile = File.createTempFile("testZip", ".zip");
        ZipArchiveOutputStream zos = new ZipArchiveOutputStream(tempFile);
        zos.putArchiveEntry(new ZipArchiveEntry("testEntry.txt")); // Open an entry without closing
        Exception exception = assertThrows(IOException.class, zos::finish);}
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testFinishWithOpenEntry_qvQP1_1() throws IOException {
        File tempFile = File.createTempFile("testZip", ".zip");
        ZipArchiveOutputStream zos = new ZipArchiveOutputStream(tempFile);
        zos.putArchiveEntry(new ZipArchiveEntry("testEntry"));
        Exception exception = assertThrows(IOException.class, () -> zos.finish());}
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testFinishAlreadyFinished_RpUX2_1() throws IOException {
        ByteArrayOutputStream out = new ByteArrayOutputStream();
        ZipArchiveOutputStream zos = new ZipArchiveOutputStream(out);
        zos.finish();
        Exception exception = assertThrows(IOException.class, () -> zos.finish());}
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testFinishAlreadyFinished_cjFx0() throws IOException {
        File tempFile = File.createTempFile("testZip", ".zip");
        ZipArchiveOutputStream zos = new ZipArchiveOutputStream(tempFile);
        zos.finish(); // Mark as finished
        try {
            zos.finish();
            fail("Should have thrown IOException because the archive is already finished.");
        } catch (IOException e) {
            assertEquals("This archive has already been finished", e.getMessage());
        }
    }
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testFinishWithUnclosedEntries_QVwa1() throws IOException {
        File tempFile = File.createTempFile("testZip", ".zip");
        ZipArchiveOutputStream zos = new ZipArchiveOutputStream(tempFile);
        ZipArchiveEntry entry = new ZipArchiveEntry("testEntry");
        zos.putArchiveEntry(entry); // Open an entry but do not close
        try {
            zos.finish();
            fail("Should have thrown IOException because the archive contains unclosed entries.");
        } catch (IOException e) {
            assertEquals("This archive contains unclosed entries.", e.getMessage());
        }
    }
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testFinishAlreadyFinished_qGJP0() throws IOException {
        File tempFile = File.createTempFile("testZip", ".zip");
        ZipArchiveOutputStream zos = new ZipArchiveOutputStream(tempFile);
        zos.finish(); // First finish to set finished = true
        try {
            zos.finish();
            fail("Expected an IOException to be thrown");
        } catch (IOException e) {
            assertEquals("This archive has already been finished", e.getMessage());
        }
    }
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testFinishWithUnclosedEntries_yiec1() throws IOException {
        File tempFile = File.createTempFile("testZip", ".zip");
        ZipArchiveOutputStream zos = new ZipArchiveOutputStream(tempFile);
        zos.putArchiveEntry(new ZipArchiveEntry("testEntry.txt")); // Open an entry but do not close
        try {
            zos.finish();
            fail("Expected an IOException to be thrown");
        } catch (IOException e) {
            assertEquals("This archive contains unclosed entries.", e.getMessage());
        }
    }
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testFinishAlreadyFinished_uQgd0() throws IOException {
        File tempFile = File.createTempFile("testZip", ".zip");
        ZipArchiveOutputStream zaos = new ZipArchiveOutputStream(tempFile);
        zaos.finish(); // Mark as finished
        try {
            zaos.finish();
            fail("Should have thrown IOException because the archive is already finished.");
        } catch (IOException e) {
            assertEquals("This archive has already been finished", e.getMessage());
        }
    }
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testFinishWithUnclosedEntries_OCSU1() throws IOException {
        File tempFile = File.createTempFile("testZip", ".zip");
        ZipArchiveOutputStream zaos = new ZipArchiveOutputStream(tempFile);
        zaos.putArchiveEntry(new ZipArchiveEntry("testEntry.txt")); // Open an entry but do not close
        try {
            zaos.finish();
            fail("Should have thrown IOException because there is an unclosed entry.");
        } catch (IOException e) {
            assertEquals("This archive contains unclosed entries.", e.getMessage());
        }
    }
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testFinishNormal_zBSB2() throws IOException {
        File tempFile = File.createTempFile("testZip", ".zip");
        ZipArchiveOutputStream zaos = new ZipArchiveOutputStream(tempFile);
        zaos.putArchiveEntry(new ZipArchiveEntry("testEntry.txt"));
        zaos.closeArchiveEntry();
        zaos.finish();
    }
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testFinishWithComment_EPDA4() throws IOException {
        File tempFile = File.createTempFile("testZip", ".zip");
        ZipArchiveOutputStream zaos = new ZipArchiveOutputStream(tempFile);
        zaos.setComment("Test archive comment");
        zaos.putArchiveEntry(new ZipArchiveEntry("testEntry.txt"));
        zaos.closeArchiveEntry();
        zaos.finish();
    }
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testFinishAlreadyFinished_Zcft0_1() throws IOException {
        ByteArrayOutputStream baos = new ByteArrayOutputStream();
        ZipArchiveOutputStream zaos = new ZipArchiveOutputStream(baos);
        zaos.finish();
        Exception exception = assertThrows(IOException.class, zaos::finish);}
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testFinishWithUnclosedEntries_lPmV1_1() throws IOException {
        ByteArrayOutputStream baos = new ByteArrayOutputStream();
        ZipArchiveOutputStream zaos = new ZipArchiveOutputStream(baos);
        zaos.putArchiveEntry(new ZipArchiveEntry("test.txt"));
        Exception exception = assertThrows(IOException.class, zaos::finish);}
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testFinishNormalOperation_tgXL2() throws IOException {
        File file = File.createTempFile("test", ".zip");
        ZipArchiveOutputStream zaos = new ZipArchiveOutputStream(file);
        zaos.finish();
        assertTrue(file.exists());
    }
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testFinishWithComment_fjYV4() throws IOException {
        ByteArrayOutputStream baos = new ByteArrayOutputStream();
        ZipArchiveOutputStream zaos = new ZipArchiveOutputStream(baos);
        zaos.setComment("Test archive");
        zaos.finish();
        String resultContent = baos.toString();
        assertTrue(resultContent.contains("Test archive"));
    }
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testFinishAlreadyFinished_TWqx0_1() throws IOException {
        File tempFile = File.createTempFile("testZip", ".zip");
        ZipArchiveOutputStream zipOut = new ZipArchiveOutputStream(tempFile);
        zipOut.finish();
        Exception exception = assertThrows(IOException.class, zipOut::finish);}
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testFinishWithUnclosedEntries_zgDQ1_1() throws IOException {
        File tempFile = File.createTempFile("testZip", ".zip");
        ZipArchiveOutputStream zipOut = new ZipArchiveOutputStream(tempFile);
        ZipArchiveEntry entry = new ZipArchiveEntry("testEntry.txt");
        zipOut.putArchiveEntry(entry);
        Exception exception = assertThrows(IOException.class, zipOut::finish);}
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testFinishAlreadyFinished_Yxnj0() throws IOException {
        File tempFile = File.createTempFile("testZip", ".zip");
        ZipArchiveOutputStream zaos = new ZipArchiveOutputStream(tempFile);
        zaos.finish(); // First finish to set finished = true
        try {
            zaos.finish();
            fail("Should have thrown IOException because the archive is already finished.");
        } catch (IOException e) {
            assertEquals("This archive has already been finished", e.getMessage());
        }
    }
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testDestroy_whenOutputStreamIsNotNull_AdoM0() throws IOException {
        ByteArrayOutputStream baos = new ByteArrayOutputStream();
        ZipArchiveOutputStream zipArchiveOutputStream = new ZipArchiveOutputStream(baos);
        zipArchiveOutputStream.destroy();
        assertTrue(baos.size() == 0); // Check if the stream is closed properly
    }
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testDestroy_whenOutputStreamIsNull_OSfd1() throws IOException {
        ZipArchiveOutputStream zipArchiveOutputStream = new ZipArchiveOutputStream(new ByteArrayOutputStream());
        zipArchiveOutputStream.destroy(); // No exception should be thrown
        assertTrue(true); // Just to have an assertion
    }
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
public void testWriteOut_validData_writtenSuccessfully_XOYw0() throws IOException {
    ByteArrayOutputStream baos = new ByteArrayOutputStream();
    ZipArchiveOutputStream zaos = new ZipArchiveOutputStream(baos);
    byte[] data = new byte[] {1, 2, 3, 4, 5};
    zaos.writeOut(data, 0, data.length);
    assertArrayEquals(data, baos.toByteArray());
}
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testPutArchiveEntry_mZvV0() throws IOException {
        ByteArrayOutputStream baos = new ByteArrayOutputStream();
        ZipArchiveOutputStream zaos = new ZipArchiveOutputStream(baos);
        ZipArchiveEntry entry = new ZipArchiveEntry("testEntry");
        zaos.putArchiveEntry(entry);
        assertTrue(true);
    }
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testPutArchiveEntry_kMTe0() throws IOException {
        ByteArrayOutputStream baos = new ByteArrayOutputStream();
        ZipArchiveOutputStream zaos = new ZipArchiveOutputStream(baos);
        ZipArchiveEntry entry = new ZipArchiveEntry("testEntry");
        entry.setSize(100); // Setting a known size
}
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testPutArchiveEntry_KsBw0() throws IOException {
        ByteArrayOutputStream baos = new ByteArrayOutputStream();
        ZipArchiveOutputStream zaos = new ZipArchiveOutputStream(baos);
        ZipArchiveEntry entry = new ZipArchiveEntry("testEntry");
}
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
public void testGetEncodingWhenCharsetIsNull_IGqq0() {
    ZipArchiveOutputStream zipArchiveOutputStream = new ZipArchiveOutputStream(System.out);
    String encoding = zipArchiveOutputStream.getEncoding();
    assertNull(encoding);
}
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testCloseArchiveEntry_NoCurrentEntry_FGgK0() {
        ByteArrayOutputStream baos = new ByteArrayOutputStream();
        ZipArchiveOutputStream zaos = new ZipArchiveOutputStream(baos);
        try {
            zaos.closeArchiveEntry();
        } catch (IOException e) {
            assertEquals("No current entry to close", e.getMessage());
        }
    }
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testCloseArchiveEntry_FhXi0_1() throws IOException {
        File tempFile = File.createTempFile("testZip", ".zip");
        ZipArchiveOutputStream zaos = new ZipArchiveOutputStream(tempFile, 1024);
        zaos.closeArchiveEntry();
        assertNotNull(zaos);}
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testCloseArchiveEntry_FhXi0_2() throws IOException {
        File tempFile = File.createTempFile("testZip", ".zip");
        ZipArchiveOutputStream zaos = new ZipArchiveOutputStream(tempFile, 1024);
        zaos.closeArchiveEntry();
        assertTrue(tempFile.exists());}
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testCloseArchiveEntry_hulo0() throws IOException {
        ByteArrayOutputStream baos = new ByteArrayOutputStream();
        ZipArchiveOutputStream zaos = new ZipArchiveOutputStream(baos);
        zaos.closeArchiveEntry();
    }
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
public void testFlushWithOutputStream_JgGu0() throws IOException {
    ByteArrayOutputStream baos = new ByteArrayOutputStream();
    ZipArchiveOutputStream zaos = new ZipArchiveOutputStream(baos);
    zaos.flush();
    assertEquals(0, baos.size(), "Buffer should be flushed and still empty");
}
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
public void testFlushWithFile_UUwk1() throws IOException {
    File tempFile = File.createTempFile("temp", ".zip");
    tempFile.deleteOnExit();
    ZipArchiveOutputStream zaos = new ZipArchiveOutputStream(tempFile);
    zaos.flush();
    assertTrue(tempFile.exists(), "File should exist after flush");
}
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
public void testWriteLocalFileHeader_rxCE0_1() throws IOException {
    ZipArchiveEntry ze = new ZipArchiveEntry("testEntry");
    ByteArrayOutputStream baos = new ByteArrayOutputStream();
    ZipArchiveOutputStream zaos = new ZipArchiveOutputStream(baos);
    zaos.writeLocalFileHeader(ze);
    byte[] outputBytes = baos.toByteArray();
    assertNotNull(outputBytes);}
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
public void testWriteLocalFileHeader_rxCE0_2() throws IOException {
    ZipArchiveEntry ze = new ZipArchiveEntry("testEntry");
    ByteArrayOutputStream baos = new ByteArrayOutputStream();
    ZipArchiveOutputStream zaos = new ZipArchiveOutputStream(baos);
    zaos.writeLocalFileHeader(ze);
    byte[] outputBytes = baos.toByteArray();
    assertTrue(outputBytes.length > 0);}
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
public void testWriteOutWithValidData_zvXc0() throws IOException {
    ByteArrayOutputStream baos = new ByteArrayOutputStream();
    ZipArchiveOutputStream zaos = new ZipArchiveOutputStream(baos);
    byte[] testData = "Sample data".getBytes();
    zaos.writeOut(testData);
    assertArrayEquals(testData, baos.toByteArray());
}
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
public void testGetBytesWritten_uNDD0() throws IOException {
    ByteArrayOutputStream baos = new ByteArrayOutputStream();
    ZipArchiveOutputStream zaos = new ZipArchiveOutputStream(baos);
    zaos.close();
    assertEquals(0, zaos.getBytesWritten());
}
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
public void testDeflate_oLmV0() throws IOException {
    ByteArrayOutputStream baos = new ByteArrayOutputStream();
    ZipArchiveOutputStream zaos = new ZipArchiveOutputStream(baos);
    zaos.deflate();
    assertNotNull(baos.toByteArray());
}
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
public void testWriteCentralFileHeader_JKKT0() throws IOException {
    ByteArrayOutputStream baos = new ByteArrayOutputStream();
    ZipArchiveOutputStream zaos = new ZipArchiveOutputStream(baos);
    ZipArchiveEntry entry = new ZipArchiveEntry("testEntry");
    zaos.writeCentralFileHeader(entry);
    assertNotEquals(0, baos.size());
}
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
public void testCreateArchiveEntry_ValidInput_TiaH0_1() throws IOException {
    File inputFile = new File("test.zip");
    String entryName = "testEntry";
    ZipArchiveOutputStream zaos = new ZipArchiveOutputStream(inputFile);
    ZipArchiveEntry result = zaos.createArchiveEntry(inputFile, entryName);
    assertNotNull(result);}
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
public void testCreateArchiveEntry_ValidInput_TiaH0_2() throws IOException {
    File inputFile = new File("test.zip");
    String entryName = "testEntry";
    ZipArchiveOutputStream zaos = new ZipArchiveOutputStream(inputFile);
    ZipArchiveEntry result = zaos.createArchiveEntry(inputFile, entryName);
    assertEquals(entryName, result.getName());}
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
public void testCreateArchiveEntry_StreamFinished_gOre1() throws IOException {
    File inputFile = new File("test.zip");
    String entryName = "testEntry";
    ZipArchiveOutputStream zaos = new ZipArchiveOutputStream(inputFile);
    zaos.close();
    assertThrows(IOException.class, () -> {
        zaos.createArchiveEntry(inputFile, entryName);
    });
}
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testClose() throws Exception {
        zipArchiveOutputStream = new ZipArchiveOutputStream(mockPath, 1024);
        // Setup
        doNothing().when(zipArchiveOutputStream).finish();
        doNothing().when(zipArchiveOutputStream).destroy();
        // Execution
        zipArchiveOutputStream.close();
        // Verification
        verify(zipArchiveOutputStream, times(1)).finish();
        verify(zipArchiveOutputStream, times(1)).destroy();
    }
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
public void testWritePreamble_RFaB0() throws IOException {
    ByteArrayOutputStream baos = new ByteArrayOutputStream();
    ZipArchiveOutputStream zaos = new ZipArchiveOutputStream(baos);
    byte[] preamble = "Hello, World!".getBytes();
    zaos.writePreamble(preamble);
    assertArrayEquals(preamble, baos.toByteArray());
}
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testCanWriteEntryData_WithZipArchiveEntryUsingImpodingMethod_aUXO0() {
        ZipArchiveOutputStream zaos = new ZipArchiveOutputStream(System.out);
        ZipArchiveEntry entry = new ZipArchiveEntry("entry.zip");
        entry.setMethod(ZipMethod.IMPLODING.getCode());
        assertFalse(zaos.canWriteEntryData(entry));
    }
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testCanWriteEntryData_WithZipArchiveEntryUsingUnshrinkingMethod_Jueg1() {
        ZipArchiveOutputStream zaos = new ZipArchiveOutputStream(System.out);
        ZipArchiveEntry entry = new ZipArchiveEntry("entry.zip");
        entry.setMethod(ZipMethod.UNSHRINKING.getCode());
        assertFalse(zaos.canWriteEntryData(entry));
    }
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testCanWriteEntryData_WithZipArchiveEntryUsingSupportedMethod_pvgK2() {
        ZipArchiveOutputStream zaos = new ZipArchiveOutputStream(System.out);
        ZipArchiveEntry entry = new ZipArchiveEntry("entry.zip");
        entry.setMethod(ZipMethod.DEFLATED.getCode());
        assertTrue(zaos.canWriteEntryData(entry));
    }
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testCanWriteEntryData_WithZipArchiveEntryUsingUnsupportedMethod_ZDbu4() {
        ZipArchiveOutputStream zaos = new ZipArchiveOutputStream(System.out);
        ZipArchiveEntry entry = new ZipArchiveEntry("entry.zip");
        entry.setMethod(999); // Assuming 999 is an unsupported method code
        assertFalse(zaos.canWriteEntryData(entry));
    }
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
public void testWritePreambleWithValidData_EHNm0() throws IOException {
    ByteArrayOutputStream baos = new ByteArrayOutputStream();
    ZipArchiveOutputStream zaos = new ZipArchiveOutputStream(baos);
    byte[] preamble = new byte[] {1, 2, 3, 4, 5};
    zaos.writePreamble(preamble, 0, preamble.length);
    assertNotEquals(0, baos.size()); // Check that something was written
}
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
public void testWritePreambleThrowsIllegalStateException_iSRa1() {
    ByteArrayOutputStream baos = new ByteArrayOutputStream();
    ZipArchiveOutputStream zaos = new ZipArchiveOutputStream(baos);
    byte[] preamble = new byte[] {1, 2, 3, 4, 5};
    assertThrows(IllegalStateException.class, () -> {
        zaos.writePreamble(preamble, 0, preamble.length);
    });
}
@Test
    @Timeout(value = 1, unit = TimeUnit.SECONDS)
    public void testSetLevelAboveValidRange_gvmB3_KtgG0() {
        assertThrows(IllegalArgumentException.class, () -> {
            ZipArchiveOutputStream zos = new ZipArchiveOutputStream(new File("test.zip"), 1024);
            zos.setLevel(Deflater.BEST_COMPRESSION + 1);
        });
    }
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
public void testSetEncodingWithValidUTF8Encoding_BuFO0_hAyZ0() {
    ByteArrayOutputStream baos = new ByteArrayOutputStream();
    ZipArchiveOutputStream zaos = new ZipArchiveOutputStream(baos);
    zaos.setEncoding("UTF-8");
    assertEquals("UTF-8", zaos.getEncoding());
}
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
public void testFinish_ObSk0() throws Exception {
    zipArchiveOutputStream = new ZipArchiveOutputStream(outputStream);
    when(streamCompressor.getTotalBytesWritten()).thenReturn(100L);
    doNothing().when(streamCompressor).close();
    doNothing().when(outputStream).close();
    zipArchiveOutputStream.finish();
    verify(streamCompressor, times(1)).getTotalBytesWritten();
    verify(streamCompressor, times(1)).close();
    verify(outputStream, never()).close(); // outputStream should not be closed if not a split zip
}
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
public void testFinishWithSplitZip_vGRU0() throws Exception {
    zipArchiveOutputStream = new ZipArchiveOutputStream(outputStream);
    when(streamCompressor.getTotalBytesWritten()).thenReturn(100L);
    doNothing().when(streamCompressor).close();
    doNothing().when(outputStream).close();
    zipArchiveOutputStream.finish();
    verify(streamCompressor, times(1)).getTotalBytesWritten();
    verify(streamCompressor, times(1)).close();
    verify(outputStream, times(1)).close(); // outputStream should be closed if it is a split zip
}
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
public void testFinishNormalOperation_heKx2_EThX0() throws IOException {
    File file = new File("test.zip");
    ZipArchiveOutputStream zipOut = new ZipArchiveOutputStream(file);
    zipOut.putArchiveEntry(new ZipArchiveEntry("entry1.txt"));
    zipOut.closeArchiveEntry();
    zipOut.putArchiveEntry(new ZipArchiveEntry("entry2.txt"));
    zipOut.closeArchiveEntry();
    zipOut.finish();
    assertTrue(zipOut.finished, "Archive should be marked as finished");
}
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
public void testFinishWithUnclosedEntries_SyUT1_wLYR0() throws IOException {
    File tempFile = File.createTempFile("testZip", ".zip");
    ZipArchiveOutputStream zaos = new ZipArchiveOutputStream(tempFile);
    ZipArchiveEntry entry = new ZipArchiveEntry("testEntry");
    zaos.putArchiveEntry(entry); // Correct way to start an entry
    try {
        zaos.finish();
        fail("Should have thrown IOException because there are unclosed entries");
    } catch (IOException e) {
        assertEquals("This archive contains unclosed entries.", e.getMessage());
    }
}
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
public void testFinishNormalOperation_iKQy2_Pzna0() throws IOException {
    File tempFile = File.createTempFile("testZip", ".zip");
    ZipArchiveOutputStream zaos = new ZipArchiveOutputStream(tempFile);
    zaos.finish();
    assertTrue(zaos.finished, "Finish should set finished to true");
}
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
public void testFinishWithZip64_TkAY4_mfql0() throws IOException {
    File tempFile = File.createTempFile("testZip", ".zip");
    ZipArchiveOutputStream zaos = new ZipArchiveOutputStream(tempFile);
    ZipArchiveEntry entry = new ZipArchiveEntry("largeFile");
    entry.setSize(ZipConstants.ZIP64_MAGIC + 1); // Force zip64 usage
    zaos.putArchiveEntry(entry); // Correct way to add entries
    zaos.closeArchiveEntry();
    zaos.finish();
    assertTrue(zaos.finished, "Finish should handle Zip64 format");
}
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
public void testFinish_WithEntriesAndNoSplit_hTmW1_NoUT0() throws IOException {
    File tempFile = File.createTempFile("testZip", ".zip");
    ZipArchiveOutputStream zaos = new ZipArchiveOutputStream(tempFile);
    ZipArchiveEntry entry = new ZipArchiveEntry("testEntry.txt");
    zaos.putArchiveEntry(entry);
    zaos.closeArchiveEntry();
    zaos.finish();
    assertTrue(zaos.finished, "Archive should be marked as finished");
}
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
public void testFinish_WithSplitZip_hrgC2_XBFT0() throws IOException {
    File tempFile = File.createTempFile("testZip", ".zip");
    long zipSplitSize = 1024 * 1024; // 1MB
    ZipArchiveOutputStream zaos = new ZipArchiveOutputStream(tempFile, zipSplitSize);
    ZipArchiveEntry entry = new ZipArchiveEntry("testEntry.txt");
    zaos.putArchiveEntry(entry);
    zaos.closeArchiveEntry();
    zaos.finish();
    assertTrue(zaos.finished);
}
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
public void testFinishNormal_bEyA2_Axan0() throws IOException {
    File tempFile = File.createTempFile("testZip", ".zip");
    ZipArchiveOutputStream zos = new ZipArchiveOutputStream(tempFile);
    zos.putArchiveEntry(new ZipArchiveEntry("testEntry.txt"));
    zos.closeArchiveEntry();
    zos.finish();
    zos.close();
    assertTrue(java.nio.file.Files.size(tempFile.toPath()) > 0);
}
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
public void testFinishWithZip64_rTqi4_xbUN0() throws IOException {
    File tempFile = File.createTempFile("testZip", ".zip");
    ZipArchiveOutputStream zos = new ZipArchiveOutputStream(tempFile, Long.MAX_VALUE); // Use a large split size to trigger ZIP64
    zos.putArchiveEntry(new ZipArchiveEntry("testEntry.txt"));
    zos.closeArchiveEntry();
    zos.finish();
    assertTrue(java.nio.file.Files.size(tempFile.toPath()) > 0);
}
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
public void testFinishWithSplitZip_rrtA3_Ikej0() throws IOException {
    File tempFile = File.createTempFile("testZip", ".zip");
    ZipArchiveOutputStream zos = new ZipArchiveOutputStream(tempFile, 512);
    zos.finish();
    assertTrue(zos.finished);
}
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
public void testFinishNormal_oRIU2_ErTJ0() throws IOException {
    File tempFile = File.createTempFile("testZip", ".zip");
    ZipArchiveOutputStream zos = new ZipArchiveOutputStream(tempFile);
    zos.finish();
    assertTrue(zos.finished);
}
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
public void testFinishNormalOperation_Svfa2_pbxk0() throws IOException {
    File tempFile = File.createTempFile("testZip", ".zip");
    ZipArchiveOutputStream zipOut = new ZipArchiveOutputStream(tempFile);
    zipOut.finish();
    assertTrue(zipOut.finished);
}
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
public void testFinishWithSplitZip_QsSi3_Acqb0() throws IOException {
    File tempFile = File.createTempFile("testZip", ".zip");
    ZipArchiveOutputStream zipOut = new ZipArchiveOutputStream(tempFile, 1024);
    zipOut.finish();
    assertTrue(zipOut.finished);
}
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
public void testFinishWithEntriesAndSplitZip_VVkl4_pcYF0() throws IOException {
    File tempFile = File.createTempFile("testZip", ".zip");
    ZipArchiveOutputStream zipOut = new ZipArchiveOutputStream(tempFile, 1024);
    ZipArchiveEntry entry = new ZipArchiveEntry("testEntry.txt");
    zipOut.putArchiveEntry(entry);
    zipOut.closeArchiveEntry();
    zipOut.finish();
    assertTrue(zipOut.finished, "Stream should be marked as finished");
}
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
public void testGetEncodingWhenCharsetIsNotNull_aSOO1_ByHO0() {
    Charset charset = Charset.forName("UTF-8");
    ByteArrayOutputStream baos = new ByteArrayOutputStream();
    ZipArchiveOutputStream zipArchiveOutputStream = new ZipArchiveOutputStream(baos);
    zipArchiveOutputStream.setEncoding(charset.name());
    String encoding = zipArchiveOutputStream.getEncoding();
    assertEquals("UTF-8", encoding);
}
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
public void testCloseArchiveEntry_HTjI0_rAhs0() throws IOException {
    File tempFile = File.createTempFile("testZip", ".zip");
    tempFile.deleteOnExit();
    ZipArchiveOutputStream zaos = new ZipArchiveOutputStream(tempFile, 1024);
    zaos.putArchiveEntry(new ZipArchiveEntry("testEntry.txt"));
    byte[] data = "Hello, World!".getBytes();
    zaos.write(data);
    zaos.closeArchiveEntry();
    zaos.close();
}
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
public void testCloseArchiveEntry_TfTZ0_FEyi0() throws IOException {
    File tempFile = File.createTempFile("testZip", ".zip");
    ZipArchiveOutputStream zaos = new ZipArchiveOutputStream(tempFile);
    zaos.closeArchiveEntry();
    assertTrue(true);
}
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
public void testCloseArchiveEntry_RVIL0_XIJq0() throws IOException {
    File tempFile = File.createTempFile("testZip", ".zip");
    ZipArchiveOutputStream zaos = new ZipArchiveOutputStream(tempFile);
    zaos.closeArchiveEntry(); // Assuming other necessary setup and method calls are handled as needed
    assertTrue(true); // Correct assertion
}
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
public void testWriteLocalFileHeader_HokI0() throws Exception {
    zipArchiveOutputStream = new ZipArchiveOutputStream(mockOutputStream);
    ZipArchiveEntry zipEntry = new ZipArchiveEntry("entryName");
    zipArchiveOutputStream.putArchiveEntry(zipEntry); // Assuming this method internally calls writeLocalFileHeader
    zipArchiveOutputStream.closeArchiveEntry();
}
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
public void testWriteDataDescriptor_SkipsWhenNotUsingDataDescriptor_HxFf0() throws Exception {
    zipArchiveOutputStream = new ZipArchiveOutputStream(mockOutputStream);
    ZipArchiveEntry ze = mock(ZipArchiveEntry.class);
    when(ze.getMethod()).thenReturn(ZipArchiveEntry.DEFLATED);
    zipArchiveOutputStream.writeDataDescriptor(ze);
    verify(mockOutputStream, never()).write(any(byte[].class), anyInt(), anyInt());
}
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
public void testWriteDataDescriptorWithNonZip64_gFCS0_ooBZ0_1() throws IOException {
    ZipArchiveEntry entry = new ZipArchiveEntry("testEntry");
    entry.setMethod(ZipMethod.DEFLATED.getCode());
    entry.setSize(1024);
    entry.setCompressedSize(512);
    entry.setCrc(123456789L);
    ByteArrayOutputStream baos = new ByteArrayOutputStream();
    ZipArchiveOutputStream zaos = new ZipArchiveOutputStream(baos);
    zaos.writeDataDescriptor(entry);
    byte[] data = baos.toByteArray();
    assertEquals(16, data.length);}
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testFinishAlreadyFinished_bLgG0() throws IOException {
        File tempFile = File.createTempFile("testZip", ".zip");
        ZipArchiveOutputStream zos = new ZipArchiveOutputStream(tempFile);
        zos.finish(); // First finish to set finished = true
        Exception exception = assertThrows(IOException.class, zos::finish);
        assertEquals("This archive has already been finished", exception.getMessage());
    }
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testFinishWithUnclosedEntries_fxfc1() throws IOException {
        File tempFile = File.createTempFile("testZip", ".zip");
        ZipArchiveOutputStream zos = new ZipArchiveOutputStream(tempFile);
        zos.putArchiveEntry(new ZipArchiveEntry("testEntry.txt")); // Open an entry without closing
        Exception exception = assertThrows(IOException.class, zos::finish);
        assertEquals("This archive contains unclosed entries.", exception.getMessage());
    }
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testFinishWithOpenEntry_qvQP1() throws IOException {
        File tempFile = File.createTempFile("testZip", ".zip");
        ZipArchiveOutputStream zos = new ZipArchiveOutputStream(tempFile);
        zos.putArchiveEntry(new ZipArchiveEntry("testEntry"));
        Exception exception = assertThrows(IOException.class, () -> zos.finish());
        assertEquals("This archive contains unclosed entries.", exception.getMessage());
    }
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testFinishAlreadyFinished_RpUX2() throws IOException {
        ByteArrayOutputStream out = new ByteArrayOutputStream();
        ZipArchiveOutputStream zos = new ZipArchiveOutputStream(out);
        zos.finish();
        Exception exception = assertThrows(IOException.class, () -> zos.finish());
        assertEquals("This archive has already been finished", exception.getMessage());
    }
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testFinishAlreadyFinished_Zcft0() throws IOException {
        ByteArrayOutputStream baos = new ByteArrayOutputStream();
        ZipArchiveOutputStream zaos = new ZipArchiveOutputStream(baos);
        zaos.finish();
        Exception exception = assertThrows(IOException.class, zaos::finish);
        assertEquals("This archive has already been finished", exception.getMessage());
    }
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testFinishWithUnclosedEntries_lPmV1() throws IOException {
        ByteArrayOutputStream baos = new ByteArrayOutputStream();
        ZipArchiveOutputStream zaos = new ZipArchiveOutputStream(baos);
        zaos.putArchiveEntry(new ZipArchiveEntry("test.txt"));
        Exception exception = assertThrows(IOException.class, zaos::finish);
        assertEquals("This archive contains unclosed entries.", exception.getMessage());
    }
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testFinishAlreadyFinished_TWqx0() throws IOException {
        File tempFile = File.createTempFile("testZip", ".zip");
        ZipArchiveOutputStream zipOut = new ZipArchiveOutputStream(tempFile);
        zipOut.finish();
        Exception exception = assertThrows(IOException.class, zipOut::finish);
        assertEquals("This archive has already been finished", exception.getMessage());
    }
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testFinishWithUnclosedEntries_zgDQ1() throws IOException {
        File tempFile = File.createTempFile("testZip", ".zip");
        ZipArchiveOutputStream zipOut = new ZipArchiveOutputStream(tempFile);
        ZipArchiveEntry entry = new ZipArchiveEntry("testEntry.txt");
        zipOut.putArchiveEntry(entry);
        Exception exception = assertThrows(IOException.class, zipOut::finish);
        assertEquals("This archive contains unclosed entries.", exception.getMessage());
    }
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testCloseArchiveEntry_FhXi0() throws IOException {
        File tempFile = File.createTempFile("testZip", ".zip");
        ZipArchiveOutputStream zaos = new ZipArchiveOutputStream(tempFile, 1024);
        zaos.closeArchiveEntry();
        assertNotNull(zaos);
        assertTrue(tempFile.exists());
    }
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
public void testWriteLocalFileHeader_rxCE0() throws IOException {
    ZipArchiveEntry ze = new ZipArchiveEntry("testEntry");
    ByteArrayOutputStream baos = new ByteArrayOutputStream();
    ZipArchiveOutputStream zaos = new ZipArchiveOutputStream(baos);
    zaos.writeLocalFileHeader(ze);
    byte[] outputBytes = baos.toByteArray();
    assertNotNull(outputBytes);
    assertTrue(outputBytes.length > 0);
}
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
public void testCreateArchiveEntry_ValidInput_TiaH0() throws IOException {
    File inputFile = new File("test.zip");
    String entryName = "testEntry";
    ZipArchiveOutputStream zaos = new ZipArchiveOutputStream(inputFile);
    ZipArchiveEntry result = zaos.createArchiveEntry(inputFile, entryName);
    assertNotNull(result);
    assertEquals(entryName, result.getName());
}
}