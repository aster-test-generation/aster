/**
 * Generated by Aster
 */
package org.apache.commons.compress.archivers.zip;

import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.Timeout;
import org.junit.jupiter.api.extension.ExtendWith;
import org.mockito.InjectMocks;
import org.mockito.Mock;
import org.mockito.junit.jupiter.MockitoExtension;
import org.mockito.junit.jupiter.MockitoSettings;
import org.mockito.quality.Strictness;

import java.io.ByteArrayInputStream;
import java.io.File;
import java.io.IOException;
import java.io.InputStream;
import java.lang.reflect.Field;
import java.util.*;
import java.util.concurrent.TimeUnit;

import static org.junit.jupiter.api.Assertions.*;
import static org.junit.jupiter.api.Timeout.ThreadMode.SEPARATE_THREAD;
import static org.mockito.Mockito.*;
@ExtendWith(MockitoExtension.class)
@MockitoSettings(strictness = Strictness.LENIENT)
public class Aster_ZipFile_Test_Passing {
@Mock
    private ZipArchiveEntry entry;
@Mock
    private GeneralPurposeBit generalPurposeBit;
@InjectMocks
    private ZipFile zipfile;
@Mock
    private ZipArchiveEntry zipArchiveEntry;
@Mock
    private ZipEncoding zipEncoding;
@Mock
    private ZipArchiveEntry zipEntry;
@Mock
    private ZipArchiveOutputStream mockTarget;
@Mock
    private ZipArchiveEntryPredicate mockPredicate;
@Mock
    private Enumeration<ZipArchiveEntry> mockEntries;
@Mock
    private InputStream mockInputStream;
    private static final byte[] ONE_ZERO_BYTE = new byte[1];
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testGetInputStreamForDeflatedMethod() throws Exception {
        when(entry.getMethod()).thenReturn(ZipMethod.DEFLATED.getCode());
        when(entry.getGeneralPurposeBit()).thenReturn(generalPurposeBit);
        // Setup
        InputStream mockInputStream = new ByteArrayInputStream(new byte[]{});
        when(zipfile.getRawInputStream(entry)).thenReturn(mockInputStream);
        // Execute
        InputStream result = zipfile.getInputStream(entry);
        // Verify
        assertNotNull(result);
        assertTrue(result instanceof InflaterInputStreamWithStatistics);
    }
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testGetInputStreamForUnsupportedMethod() {
        when(entry.getMethod()).thenReturn(ZipMethod.DEFLATED.getCode());
        when(entry.getGeneralPurposeBit()).thenReturn(generalPurposeBit);
        // Setup
        when(entry.getMethod()).thenReturn(ZipMethod.UNKNOWN.getCode());
        // Execute and Verify
        assertThrows(UnsupportedZipFeatureException.class, () -> {
            zipfile.getInputStream(entry);
        });
    }
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testGetInputStreamReturnsNullForNonEntryInstance() throws Exception {
        when(entry.getMethod()).thenReturn(ZipMethod.DEFLATED.getCode());
        when(entry.getGeneralPurposeBit()).thenReturn(generalPurposeBit);
        // Setup
        ZipArchiveEntry nonEntry = new ZipArchiveEntry("nonEntry");
        when(zipfile.getRawInputStream(nonEntry)).thenReturn(null);
        // Execute
        InputStream result = zipfile.getInputStream(nonEntry);
        // Verify
        assertNull(result);
    }
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testCanReadEntryData_WhenEntryIsReadable_ReturnsTrue() throws Exception {
        zipfile = new ZipFile("dummyPath"); // Assuming a constructor that doesn't do much
        // Setup
        when(ZipUtil.canHandleEntryData(zipArchiveEntry)).thenReturn(true);
        // Execution
        boolean result = zipfile.canReadEntryData(zipArchiveEntry);
        // Assertion
        assertTrue(result, "Expected canReadEntryData to return true for a readable entry");
    }
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testCanReadEntryData_WhenEntryIsNotReadable_ReturnsFalse() throws Exception {
        zipfile = new ZipFile("dummyPath"); // Assuming a constructor that doesn't do much
        // Setup
        when(ZipUtil.canHandleEntryData(zipArchiveEntry)).thenReturn(false);
        // Execution
        boolean result = zipfile.canReadEntryData(zipArchiveEntry);
        // Assertion
        assertFalse(result, "Expected canReadEntryData to return false for a non-readable entry");
    }
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
public void testGetEncoding_SuOA0() throws IOException {
    ZipFile zipFile = new ZipFile("test.zip", "UTF-8");
    assertEquals("UTF-8", zipFile.getEncoding());
}
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testGetUnixSymlink_SymlinkEntry_ReturnsDecodedString() throws Exception {
        // Initialize ZipFile with mocked ZipEncoding
        zipfile = new ZipFile(mock(java.nio.file.Path.class)); // Assuming constructor does not affect the test
        // Setup
        String expectedLink = "target/path";
        byte[] symlinkData = expectedLink.getBytes();
        InputStream symlinkInputStream = new ByteArrayInputStream(symlinkData);
        when(zipEntry.isUnixSymlink()).thenReturn(true);
        when(zipfile.getInputStream(zipEntry)).thenReturn(symlinkInputStream);
        when(zipEncoding.decode(symlinkData)).thenReturn(expectedLink);
        // Execute
        String actualLink = zipfile.getUnixSymlink(zipEntry);
        // Verify
        assertEquals(expectedLink, actualLink);
        verify(zipEntry).isUnixSymlink();
        verify(zipfile).getInputStream(zipEntry);
        verify(zipEncoding).decode(symlinkData);
    }
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testGetUnixSymlink_NonSymlinkEntry_ReturnsNull() throws Exception {
        // Initialize ZipFile with mocked ZipEncoding
        zipfile = new ZipFile(mock(java.nio.file.Path.class)); // Assuming constructor does not affect the test
        // Setup
        when(zipEntry.isUnixSymlink()).thenReturn(false);
        // Execute
        String actualLink = zipfile.getUnixSymlink(zipEntry);
        // Verify
        assertNull(actualLink);
        verify(zipEntry).isUnixSymlink();
        verify(zipfile, never()).getInputStream(zipEntry);
    }
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testGetUnixSymlink_NullEntry_ReturnsNull() throws Exception {
        // Initialize ZipFile with mocked ZipEncoding
        zipfile = new ZipFile(mock(java.nio.file.Path.class)); // Assuming constructor does not affect the test
        // Execute
        String actualLink = zipfile.getUnixSymlink(null);
        // Verify
        assertNull(actualLink);
    }
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
public void testGetUnixSymlink_NullEntry_lqRR0() throws IOException {
    ZipFile zipFile = new ZipFile("test.zip");
    ZipArchiveEntry entry = null;
    String result = zipFile.getUnixSymlink(entry);
    assertNull(result);
}
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
public void testGetUnixSymlink_NotASymlink_TFvR1() throws IOException {
    ZipFile zipFile = new ZipFile("test.zip");
    ZipArchiveEntry entry = new ZipArchiveEntry("testEntry");
    String result = zipFile.getUnixSymlink(entry);
    assertNull(result);
}
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
public void testGetUnixSymlink_ValidSymlink_wWsE2() throws IOException {
    ZipFile zipFile = new ZipFile("test.zip");
    ZipArchiveEntry entry = new ZipArchiveEntry("symlink");
    entry.setUnixMode(0120000); // Unix symlink mode
    when(entry.isUnixSymlink()).thenReturn(true);
    when(zipFile.getInputStream(entry)).thenReturn(new ByteArrayInputStream("targetPath".getBytes()));
    String result = zipFile.getUnixSymlink(entry);
    assertEquals("targetPath", result);
}
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
public void testGetUnixSymlink_IOException_ADhQ3() throws IOException {
    ZipFile zipFile = new ZipFile("test.zip");
    ZipArchiveEntry entry = new ZipArchiveEntry("symlink");
    entry.setUnixMode(0120000); // Unix symlink mode
    when(entry.isUnixSymlink()).thenReturn(true);
    when(zipFile.getInputStream(entry)).thenThrow(new IOException("Failed to read"));
    assertThrows(IOException.class, () -> zipFile.getUnixSymlink(entry));
}
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
public void testGetUnixSymlink_EmptySymlink_zIZZ4() throws IOException {
    ZipFile zipFile = new ZipFile("test.zip");
    ZipArchiveEntry entry = new ZipArchiveEntry("emptySymlink");
    entry.setUnixMode(0120000); // Unix symlink mode
    when(entry.isUnixSymlink()).thenReturn(true);
    when(zipFile.getInputStream(entry)).thenReturn(new ByteArrayInputStream(new byte[0]));
    String result = zipFile.getUnixSymlink(entry);
    assertEquals("", result);
}
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
public void testGetEntries_emptyZipFile_dofT0() throws IOException {
    File tempFile = File.createTempFile("empty", ".zip");
    ZipFile zipFile = new ZipFile(tempFile);
    Enumeration<ZipArchiveEntry> entries = zipFile.getEntries();
    assertFalse(entries.hasMoreElements());
}
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
public void testCloseQuietlyWithNullZipFile_MslU0() {
    ZipFile zipFile = null;
    ZipFile.closeQuietly(zipFile);
    assertNull(zipFile, "ZipFile should be null after closeQuietly with null input.");
}
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
public void testGetRawInputStreamWithNonEntryInstance_QfHi0() throws IOException {
    ZipFile zipFile = new ZipFile("test.zip");
    ZipArchiveEntry entry = new ZipArchiveEntry("entryName");
    InputStream result = zipFile.getRawInputStream(entry);
    assertNull(result);
}
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testCopyRawEntries() throws Exception {
        // Prepare a list of entries to simulate the Enumeration
        Vector<ZipArchiveEntry> entriesVector = new Vector<>();
        entriesVector.add(new ZipArchiveEntry("entry1.txt"));
        entriesVector.add(new ZipArchiveEntry("entry2.txt"));
        entriesVector.add(new ZipArchiveEntry("entry3.txt"));
        mockEntries = entriesVector.elements();
        // Setup the zipfile to return the mock entries and input streams
        when(zipfile.getEntriesInPhysicalOrder()).thenReturn(mockEntries);
        when(zipfile.getRawInputStream(any(ZipArchiveEntry.class))).thenReturn(mockInputStream);
        // Setup the predicate to return true for all entries
        when(mockPredicate.test(any(ZipArchiveEntry.class))).thenReturn(true);
        // Execute the method under test
        zipfile.copyRawEntries(mockTarget, mockPredicate);
        // Verify that addRawArchiveEntry was called for each entry
        verify(mockTarget, times(3)).addRawArchiveEntry(any(ZipArchiveEntry.class), eq(mockInputStream));
        // Verify that the predicate was called for each entry
        verify(mockPredicate, times(3)).test(any(ZipArchiveEntry.class));
    }
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
public void testGetEntryWhenEntryDoesNotExist_isTV1() {
    try {
        ZipFile zipFile = new ZipFile("test.zip");
        ZipArchiveEntry result = zipFile.getEntry("nonExistingEntry");
        assertNull(result);
    } catch (IOException e) {
        fail("IOException should not be thrown");
    }
}
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testGetInputStreamForDeflatedMethod_1() throws Exception {
        when(entry.getMethod()).thenReturn(ZipMethod.DEFLATED.getCode());
        when(entry.getGeneralPurposeBit()).thenReturn(generalPurposeBit);
        // Setup
        InputStream mockInputStream = new ByteArrayInputStream(new byte[]{});
        when(zipfile.getRawInputStream(entry)).thenReturn(mockInputStream);
        // Execute
        InputStream result = zipfile.getInputStream(entry);
        // Verify
        assertNotNull(result);}
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testGetInputStreamForDeflatedMethod_2() throws Exception {
        when(entry.getMethod()).thenReturn(ZipMethod.DEFLATED.getCode());
        when(entry.getGeneralPurposeBit()).thenReturn(generalPurposeBit);
        // Setup
        InputStream mockInputStream = new ByteArrayInputStream(new byte[]{});
        when(zipfile.getRawInputStream(entry)).thenReturn(mockInputStream);
        // Execute
        InputStream result = zipfile.getInputStream(entry);
        // Verify
        assertTrue(result instanceof InflaterInputStreamWithStatistics);}
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
public void testGetInputStreamWithDeflatedMethod_LNdh1_wtYr0_1() throws IOException {
    java.nio.file.Path path = java.nio.file.Paths.get("test.zip");
    ZipFile zipFile = new ZipFile(path);
    ZipArchiveEntry entry = new ZipArchiveEntry("testEntry");
    entry.setMethod(ZipMethod.DEFLATED.getCode());
    GeneralPurposeBit gpBit = new GeneralPurposeBit();
    entry.setGeneralPurposeBit(gpBit);
    InputStream result = zipFile.getInputStream(entry);
    assertNotNull(result);}
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
public void testGetInputStreamWithDeflatedMethod_LNdh1_wtYr0_2() throws IOException {
    java.nio.file.Path path = java.nio.file.Paths.get("test.zip");
    ZipFile zipFile = new ZipFile(path);
    ZipArchiveEntry entry = new ZipArchiveEntry("testEntry");
    entry.setMethod(ZipMethod.DEFLATED.getCode());
    GeneralPurposeBit gpBit = new GeneralPurposeBit();
    entry.setGeneralPurposeBit(gpBit);
    InputStream result = zipFile.getInputStream(entry);
    assertTrue(result instanceof InflaterInputStreamWithStatistics);}
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
public void testGetRawInputStream_InvalidEntry_jyBC0() throws Exception {
    File tempFile = File.createTempFile("tempZipFile", ".zip");
    ZipFile zipfile = new ZipFile(tempFile);
    ZipArchiveEntry entry = mock(ZipArchiveEntry.class);
    when(entry.getName()).thenReturn("nonExistentEntry");
    InputStream resultStream = zipfile.getRawInputStream(entry);
    assertNull(resultStream, "Stream should be null for invalid entries");
}
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
public void testGetRawInputStreamWithUnknownOffset_Gfip1_ubFj0() throws IOException {
    java.nio.file.Path path = java.nio.file.Paths.get("test.zip");
    ZipFile zipFile = new ZipFile(path);
    ZipArchiveEntry entry = new ZipArchiveEntry("entry");
    entry.setLocalHeaderOffset(100);
    entry.setDiskNumberStart(0);
    entry.setCompressedSize(50);
    InputStream result = zipFile.getRawInputStream(entry);
    assertNotNull(result);
}
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
public void testGetEntryWhenEntryExists_Ayaf0_RcLj0() {
    try {
        ZipFile zipFile = new ZipFile("test.zip");
        ZipArchiveEntry expectedEntry = new ZipArchiveEntry();
        LinkedList<ZipArchiveEntry> entries = new LinkedList<>();
        entries.add(expectedEntry);
        Field nameMapField = ZipFile.class.getDeclaredField("nameMap");
        nameMapField.setAccessible(true);
        Map<String, LinkedList<ZipArchiveEntry>> nameMap = (Map<String, LinkedList<ZipArchiveEntry>>) nameMapField.get(zipFile);
        nameMap.put("existingEntry", entries);
        ZipArchiveEntry result = zipFile.getEntry("existingEntry");
        assertEquals(expectedEntry, result);
    } catch (IOException | NoSuchFieldException | IllegalAccessException e) {
        fail("Exception should not be thrown");
    }
}
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
public void testGetContentBeforeFirstLocalFileHeader_WithZeroOffset_vKVk1_IzFV0() throws IOException, NoSuchFieldException, IllegalAccessException {
    File testFile = new File("empty.zip");
    ZipFile zipFile = new ZipFile(testFile);
    Field field = ZipFile.class.getDeclaredField("nameMap"); // Assuming 'nameMap' is a valid field in ZipFile
    field.setAccessible(true);
    field.set(zipFile, new HashMap<String, LinkedList<ZipArchiveEntry>>()); // Set an empty map to simulate no entries
    InputStream result = zipFile.getContentBeforeFirstLocalFileHeader();
    assertNull(result);
}
}