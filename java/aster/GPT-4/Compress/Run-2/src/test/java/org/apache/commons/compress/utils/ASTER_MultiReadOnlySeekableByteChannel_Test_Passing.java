/**
 * Generated by Aster
 */
package org.apache.commons.compress.utils;

import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.Timeout;

import java.io.IOException;
import java.nio.ByteBuffer;
import java.nio.channels.NonWritableChannelException;
import java.nio.channels.SeekableByteChannel;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collections;
import java.util.List;
import java.util.concurrent.TimeUnit;

import static org.junit.jupiter.api.Assertions.*;
import static org.junit.jupiter.api.Timeout.ThreadMode.SEPARATE_THREAD;
import static org.mockito.Mockito.*;
public class Aster_MultiReadOnlySeekableByteChannel_Test_Passing {
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
public void testTruncateThrowsNonWritableChannelException_bQJg0() throws Exception {
    List<SeekableByteChannel> channels = new ArrayList<>();
    MultiReadOnlySeekableByteChannel multiChannel = new MultiReadOnlySeekableByteChannel(channels);
    assertThrows(NonWritableChannelException.class, () -> multiChannel.truncate(100));
}
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
public void testIsOpen_AllChannelsOpen_ReturnsTrue_fSWj0() throws Exception {
    List<SeekableByteChannel> channels = Arrays.asList(
        mock(SeekableByteChannel.class),
        mock(SeekableByteChannel.class),
        mock(SeekableByteChannel.class)
    );
    when(channels.get(0).isOpen()).thenReturn(true);
    when(channels.get(1).isOpen()).thenReturn(true);
    when(channels.get(2).isOpen()).thenReturn(true);
    MultiReadOnlySeekableByteChannel multiChannel = new MultiReadOnlySeekableByteChannel(channels);
    assertTrue(multiChannel.isOpen());
}
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
public void testWriteThrowsNonWritableChannelException_tsZW0() throws Exception {
    List<SeekableByteChannel> channels = new ArrayList<>();
    MultiReadOnlySeekableByteChannel channel = new MultiReadOnlySeekableByteChannel(channels);
    ByteBuffer buffer = ByteBuffer.allocate(10);
    assertThrows(NonWritableChannelException.class, () -> channel.write(buffer));
}
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
public void testPositionInitial_rvaB0() throws Exception {
    List<SeekableByteChannel> channels = new ArrayList<>();
    MultiReadOnlySeekableByteChannel multiChannel = new MultiReadOnlySeekableByteChannel(channels);
    assertEquals(0, multiChannel.position());
}
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
public void testClose_AllChannelsCloseSuccessfully_SqnF0() throws IOException {
    List<SeekableByteChannel> channels = Arrays.asList(
        mock(SeekableByteChannel.class),
        mock(SeekableByteChannel.class),
        mock(SeekableByteChannel.class)
    );
    MultiReadOnlySeekableByteChannel multiChannel = new MultiReadOnlySeekableByteChannel(channels);
    multiChannel.close();
    for (SeekableByteChannel ch : channels) {
        verify(ch).close();
    }
}
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
public void testClose_OneChannelThrowsIOException_AKsk1_1() throws Exception {
    List<SeekableByteChannel> channels = Arrays.asList(
        mock(SeekableByteChannel.class),
        mock(SeekableByteChannel.class)
    );
    IOException ioException = new IOException("Test exception");
    doThrow(ioException).when(channels.get(1)).close();
    MultiReadOnlySeekableByteChannel multiChannel = new MultiReadOnlySeekableByteChannel(channels);
    Exception exception = assertThrows(IOException.class, multiChannel::close);}
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
public void testClose_MultipleChannelsThrowIOException_dFBV2_1() throws Exception {
    List<SeekableByteChannel> channels = Arrays.asList(
        mock(SeekableByteChannel.class),
        mock(SeekableByteChannel.class),
        mock(SeekableByteChannel.class)
    );
    IOException ioException1 = new IOException("Test exception 1");
    IOException ioException2 = new IOException("Test exception 2");
    doThrow(ioException1).when(channels.get(0)).close();
    doThrow(ioException2).when(channels.get(2)).close();
    MultiReadOnlySeekableByteChannel multiChannel = new MultiReadOnlySeekableByteChannel(channels);
    Exception exception = assertThrows(IOException.class, multiChannel::close);}
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
public void testClose_NoChannels_FyKp3() throws IOException {
    List<SeekableByteChannel> channels = Collections.emptyList();
    MultiReadOnlySeekableByteChannel multiChannel = new MultiReadOnlySeekableByteChannel(channels);
    multiChannel.close();
}
}