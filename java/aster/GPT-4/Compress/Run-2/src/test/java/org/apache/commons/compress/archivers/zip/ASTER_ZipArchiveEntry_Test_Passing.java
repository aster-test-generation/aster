/**
 * Generated by Aster
 */
package org.apache.commons.compress.archivers.zip;

import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.Timeout;
import org.junit.jupiter.api.extension.ExtendWith;
import org.mockito.Mock;
import org.mockito.junit.jupiter.MockitoExtension;
import org.mockito.junit.jupiter.MockitoSettings;
import org.mockito.quality.Strictness;

import java.io.File;
import java.lang.reflect.Field;
import java.nio.file.attribute.FileTime;
import java.util.Arrays;
import java.util.Date;
import java.util.concurrent.TimeUnit;
import java.util.zip.ZipEntry;
import java.util.zip.ZipException;

import static org.junit.jupiter.api.Assertions.*;
import static org.junit.jupiter.api.Timeout.ThreadMode.SEPARATE_THREAD;
import static org.mockito.Mockito.*;
@ExtendWith(MockitoExtension.class)
@MockitoSettings(strictness = Strictness.LENIENT)
public class Aster_ZipArchiveEntry_Test_Passing {
private ZipArchiveEntry zipArchiveEntry;
private final int versionRequired = 20;
private GeneralPurposeBit generalPurposeBit;
private static final int PLATFORM_FAT = 0;
private static final int PLATFORM_UNIX = 3;
private static final int SHORT_SHIFT = 16;
@Mock
    private ZipArchiveEntry mockZipArchiveEntry;
private static final long OFFSET_UNKNOWN = -1L;
private ZipArchiveEntry zipArchiveEntry1;
private ZipArchiveEntry zipArchiveEntry2;
@Mock
    private UnparseableExtraFieldData unparseableExtra;
@Mock
    private ZipEntry mockZipEntry;
private String name = "testName";
private byte[] rawName = new byte[]{0x01, 0x02, 0x03};
@Mock
    private ExtraFieldUtils extraFieldUtils;
private static final long TEST_OFFSET = 1234L;
private ZipExtraField[] extraFields;
private static final long SIZE_UNKNOWN = -1L;
private static final int NEW_PLATFORM = 1;
@Mock
    private ZipArchiveEntry baseEntry;
private static final int UNKNOWN_CODE = ZipMethod.UNKNOWN_CODE;
@Mock
    private ZipExtraField extraField1;
@Mock
    private ZipExtraField extraField2;
@Mock
    private ZipShort headerId1;
@Mock
    private ZipShort headerId2;
@Mock
    private FileTime fileTime;
private long expectedDiskNumberStart = 12345L;
private static final int SHORT_MASK = 0xFFFF;
@Mock
    private ZipShort zipShortMock;
@Mock
    private ZipExtraField zipExtraField;
@Mock
    private ZipExtraField mockExtraField;
@Mock
    private UnparseableExtraFieldData mockUnparseableExtraFieldData;
@Mock
    private ZipExtraField[] mockExtraFields;
    private long externalAttributes;
    private long dataOffset = OFFSET_UNKNOWN;
    private long localHeaderOffset = OFFSET_UNKNOWN;
    private int internalAttributes;
    private int rawFlag;
    private long time = -1;
    private long diskNumberStart;
    private int alignment;
    private long size = SIZE_UNKNOWN;
    private boolean isStreamContiguous;
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testGetVersionRequired() {
        zipArchiveEntry = new ZipArchiveEntry("testEntry");
        // Retrieve the private field using reflection to verify it was set correctly
        GeneralPurposeBit retrievedBit = null;
        try {
            java.lang.reflect.Field field = zipArchiveEntry.getClass().getDeclaredField("generalPurposeBit");
            field.setAccessible(true);
            retrievedBit = (GeneralPurposeBit) field.get(zipArchiveEntry);
        } catch (NoSuchFieldException | IllegalAccessException e) {
            e.printStackTrace();
        }
        // Assert that the set GeneralPurposeBit is the same as the one we put in
        assertSame(generalPurposeBit, retrievedBit, "The GeneralPurposeBit should be the same as the one set.");
    }
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
public void testSetUnixMode_ReadAndWritePermissions_NTzc0_1() {
    ZipArchiveEntry zipEntry = new ZipArchiveEntry("testEntry");
    zipEntry.setUnixMode(0666); // Read and write permissions for user, group, and others
    assertEquals(0666, zipEntry.getExternalAttributes() >> SHORT_SHIFT);}
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
public void testSetUnixMode_ReadAndWritePermissions_NTzc0_2() {
    ZipArchiveEntry zipEntry = new ZipArchiveEntry("testEntry");
    zipEntry.setUnixMode(0666); // Read and write permissions for user, group, and others
    assertEquals(PLATFORM_UNIX, zipEntry.getPlatform());}
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
public void testSetUnixMode_ExecutePermissions_ljXJ1_1() {
    ZipArchiveEntry zipEntry = new ZipArchiveEntry("testEntry");
    zipEntry.setUnixMode(0111); // Execute permissions for user, group, and others
    assertEquals(0111, zipEntry.getExternalAttributes() >> SHORT_SHIFT);}
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
public void testSetUnixMode_ExecutePermissions_ljXJ1_2() {
    ZipArchiveEntry zipEntry = new ZipArchiveEntry("testEntry");
    zipEntry.setUnixMode(0111); // Execute permissions for user, group, and others
    assertEquals(PLATFORM_UNIX, zipEntry.getPlatform());}
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
public void testSetUnixMode_NoPermissions_zJTL2_1() {
    ZipArchiveEntry zipEntry = new ZipArchiveEntry("testEntry");
    zipEntry.setUnixMode(0000); // No permissions
    assertEquals(0000, zipEntry.getExternalAttributes() >> SHORT_SHIFT);}
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
public void testSetUnixMode_NoPermissions_zJTL2_2() {
    ZipArchiveEntry zipEntry = new ZipArchiveEntry("testEntry");
    zipEntry.setUnixMode(0000); // No permissions
    assertEquals(PLATFORM_UNIX, zipEntry.getPlatform());}
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testGetExternalAttributes() {
        // Since we cannot directly set private fields without a setter and we are using @InjectMocks,
        // we need to use reflection to set the externalAttributes field if necessary.
        // However, for simplicity, we'll assume the default value for a new ZipArchiveEntry is sufficient for this test.
        // If specific initialization is needed, consider adding a constructor or method in ZipArchiveEntry to set externalAttributes.
        // Assuming the default value of externalAttributes is 0 (since it's a long and not explicitly initialized in the constructor).
        long expected = 0;
        long actual = zipArchiveEntry.getExternalAttributes();
        assertEquals(expected, actual, "The externalAttributes should match the expected default value.");
    }
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
public void testGetExternalAttributes_DefaultConstructor_svdw0() {
    ZipArchiveEntry zipEntry = new ZipArchiveEntry();
    long expectedAttributes = 0; // Assuming default is 0 since not set in the constructor
    assertEquals(expectedAttributes, zipEntry.getExternalAttributes());
}
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testEquals_SameObject() {
        zipArchiveEntry1 = mock(ZipArchiveEntry.class, CALLS_REAL_METHODS);
        zipArchiveEntry2 = mock(ZipArchiveEntry.class, CALLS_REAL_METHODS);
        when(zipArchiveEntry1.getName()).thenReturn("entry1");
        when(zipArchiveEntry2.getName()).thenReturn("entry1");
        when(zipArchiveEntry1.getComment()).thenReturn("comment1");
        when(zipArchiveEntry2.getComment()).thenReturn("comment1");
        FileTime fileTime = FileTime.fromMillis(System.currentTimeMillis());
        when(zipArchiveEntry1.getLastModifiedTime()).thenReturn(fileTime);
        when(zipArchiveEntry2.getLastModifiedTime()).thenReturn(fileTime);
        when(zipArchiveEntry1.getLastAccessTime()).thenReturn(fileTime);
        when(zipArchiveEntry2.getLastAccessTime()).thenReturn(fileTime);
        when(zipArchiveEntry1.getCreationTime()).thenReturn(fileTime);
        when(zipArchiveEntry2.getCreationTime()).thenReturn(fileTime);
        when(zipArchiveEntry1.getInternalAttributes()).thenReturn(1);
        when(zipArchiveEntry2.getInternalAttributes()).thenReturn(1);
        when(zipArchiveEntry1.getPlatform()).thenReturn(1);
        when(zipArchiveEntry2.getPlatform()).thenReturn(1);
        when(zipArchiveEntry1.getExternalAttributes()).thenReturn(1L);
        when(zipArchiveEntry2.getExternalAttributes()).thenReturn(1L);
        when(zipArchiveEntry1.getMethod()).thenReturn(1);
        when(zipArchiveEntry2.getMethod()).thenReturn(1);
        when(zipArchiveEntry1.getSize()).thenReturn(100L);
        when(zipArchiveEntry2.getSize()).thenReturn(100L);
        when(zipArchiveEntry1.getCrc()).thenReturn(100L);
        when(zipArchiveEntry2.getCrc()).thenReturn(100L);
        when(zipArchiveEntry1.getCompressedSize()).thenReturn(100L);
        when(zipArchiveEntry2.getCompressedSize()).thenReturn(100L);
        byte[] extra = new byte[] {1, 2, 3};
        when(zipArchiveEntry1.getCentralDirectoryExtra()).thenReturn(extra);
        when(zipArchiveEntry2.getCentralDirectoryExtra()).thenReturn(extra);
        when(zipArchiveEntry1.getLocalFileDataExtra()).thenReturn(extra);
        when(zipArchiveEntry2.getLocalFileDataExtra()).thenReturn(extra);
        when(zipArchiveEntry1.getLocalHeaderOffset()).thenReturn(OFFSET_UNKNOWN);
        when(zipArchiveEntry2.getLocalHeaderOffset()).thenReturn(OFFSET_UNKNOWN);
        when(zipArchiveEntry1.getDataOffset()).thenReturn(OFFSET_UNKNOWN);
        when(zipArchiveEntry2.getDataOffset()).thenReturn(OFFSET_UNKNOWN);
        GeneralPurposeBit generalPurposeBit = new GeneralPurposeBit();
        when(zipArchiveEntry1.getGeneralPurposeBit()).thenReturn(generalPurposeBit);
        when(zipArchiveEntry2.getGeneralPurposeBit()).thenReturn(generalPurposeBit);
        assertTrue(zipArchiveEntry1.equals(zipArchiveEntry1));
    }
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testEquals_DifferentObjectsSameValues() {
        zipArchiveEntry1 = mock(ZipArchiveEntry.class, CALLS_REAL_METHODS);
        zipArchiveEntry2 = mock(ZipArchiveEntry.class, CALLS_REAL_METHODS);
        when(zipArchiveEntry1.getName()).thenReturn("entry1");
        when(zipArchiveEntry2.getName()).thenReturn("entry1");
        when(zipArchiveEntry1.getComment()).thenReturn("comment1");
        when(zipArchiveEntry2.getComment()).thenReturn("comment1");
        FileTime fileTime = FileTime.fromMillis(System.currentTimeMillis());
        when(zipArchiveEntry1.getLastModifiedTime()).thenReturn(fileTime);
        when(zipArchiveEntry2.getLastModifiedTime()).thenReturn(fileTime);
        when(zipArchiveEntry1.getLastAccessTime()).thenReturn(fileTime);
        when(zipArchiveEntry2.getLastAccessTime()).thenReturn(fileTime);
        when(zipArchiveEntry1.getCreationTime()).thenReturn(fileTime);
        when(zipArchiveEntry2.getCreationTime()).thenReturn(fileTime);
        when(zipArchiveEntry1.getInternalAttributes()).thenReturn(1);
        when(zipArchiveEntry2.getInternalAttributes()).thenReturn(1);
        when(zipArchiveEntry1.getPlatform()).thenReturn(1);
        when(zipArchiveEntry2.getPlatform()).thenReturn(1);
        when(zipArchiveEntry1.getExternalAttributes()).thenReturn(1L);
        when(zipArchiveEntry2.getExternalAttributes()).thenReturn(1L);
        when(zipArchiveEntry1.getMethod()).thenReturn(1);
        when(zipArchiveEntry2.getMethod()).thenReturn(1);
        when(zipArchiveEntry1.getSize()).thenReturn(100L);
        when(zipArchiveEntry2.getSize()).thenReturn(100L);
        when(zipArchiveEntry1.getCrc()).thenReturn(100L);
        when(zipArchiveEntry2.getCrc()).thenReturn(100L);
        when(zipArchiveEntry1.getCompressedSize()).thenReturn(100L);
        when(zipArchiveEntry2.getCompressedSize()).thenReturn(100L);
        byte[] extra = new byte[] {1, 2, 3};
        when(zipArchiveEntry1.getCentralDirectoryExtra()).thenReturn(extra);
        when(zipArchiveEntry2.getCentralDirectoryExtra()).thenReturn(extra);
        when(zipArchiveEntry1.getLocalFileDataExtra()).thenReturn(extra);
        when(zipArchiveEntry2.getLocalFileDataExtra()).thenReturn(extra);
        when(zipArchiveEntry1.getLocalHeaderOffset()).thenReturn(OFFSET_UNKNOWN);
        when(zipArchiveEntry2.getLocalHeaderOffset()).thenReturn(OFFSET_UNKNOWN);
        when(zipArchiveEntry1.getDataOffset()).thenReturn(OFFSET_UNKNOWN);
        when(zipArchiveEntry2.getDataOffset()).thenReturn(OFFSET_UNKNOWN);
        GeneralPurposeBit generalPurposeBit = new GeneralPurposeBit();
        when(zipArchiveEntry1.getGeneralPurposeBit()).thenReturn(generalPurposeBit);
        when(zipArchiveEntry2.getGeneralPurposeBit()).thenReturn(generalPurposeBit);
        assertTrue(zipArchiveEntry1.equals(zipArchiveEntry2));
    }
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testEquals_DifferentNames() {
        zipArchiveEntry1 = mock(ZipArchiveEntry.class, CALLS_REAL_METHODS);
        zipArchiveEntry2 = mock(ZipArchiveEntry.class, CALLS_REAL_METHODS);
        when(zipArchiveEntry1.getName()).thenReturn("entry1");
        when(zipArchiveEntry2.getName()).thenReturn("entry1");
        when(zipArchiveEntry1.getComment()).thenReturn("comment1");
        when(zipArchiveEntry2.getComment()).thenReturn("comment1");
        FileTime fileTime = FileTime.fromMillis(System.currentTimeMillis());
        when(zipArchiveEntry1.getLastModifiedTime()).thenReturn(fileTime);
        when(zipArchiveEntry2.getLastModifiedTime()).thenReturn(fileTime);
        when(zipArchiveEntry1.getLastAccessTime()).thenReturn(fileTime);
        when(zipArchiveEntry2.getLastAccessTime()).thenReturn(fileTime);
        when(zipArchiveEntry1.getCreationTime()).thenReturn(fileTime);
        when(zipArchiveEntry2.getCreationTime()).thenReturn(fileTime);
        when(zipArchiveEntry1.getInternalAttributes()).thenReturn(1);
        when(zipArchiveEntry2.getInternalAttributes()).thenReturn(1);
        when(zipArchiveEntry1.getPlatform()).thenReturn(1);
        when(zipArchiveEntry2.getPlatform()).thenReturn(1);
        when(zipArchiveEntry1.getExternalAttributes()).thenReturn(1L);
        when(zipArchiveEntry2.getExternalAttributes()).thenReturn(1L);
        when(zipArchiveEntry1.getMethod()).thenReturn(1);
        when(zipArchiveEntry2.getMethod()).thenReturn(1);
        when(zipArchiveEntry1.getSize()).thenReturn(100L);
        when(zipArchiveEntry2.getSize()).thenReturn(100L);
        when(zipArchiveEntry1.getCrc()).thenReturn(100L);
        when(zipArchiveEntry2.getCrc()).thenReturn(100L);
        when(zipArchiveEntry1.getCompressedSize()).thenReturn(100L);
        when(zipArchiveEntry2.getCompressedSize()).thenReturn(100L);
        byte[] extra = new byte[] {1, 2, 3};
        when(zipArchiveEntry1.getCentralDirectoryExtra()).thenReturn(extra);
        when(zipArchiveEntry2.getCentralDirectoryExtra()).thenReturn(extra);
        when(zipArchiveEntry1.getLocalFileDataExtra()).thenReturn(extra);
        when(zipArchiveEntry2.getLocalFileDataExtra()).thenReturn(extra);
        when(zipArchiveEntry1.getLocalHeaderOffset()).thenReturn(OFFSET_UNKNOWN);
        when(zipArchiveEntry2.getLocalHeaderOffset()).thenReturn(OFFSET_UNKNOWN);
        when(zipArchiveEntry1.getDataOffset()).thenReturn(OFFSET_UNKNOWN);
        when(zipArchiveEntry2.getDataOffset()).thenReturn(OFFSET_UNKNOWN);
        GeneralPurposeBit generalPurposeBit = new GeneralPurposeBit();
        when(zipArchiveEntry1.getGeneralPurposeBit()).thenReturn(generalPurposeBit);
        when(zipArchiveEntry2.getGeneralPurposeBit()).thenReturn(generalPurposeBit);
        when(zipArchiveEntry2.getName()).thenReturn("entry2");
        assertFalse(zipArchiveEntry1.equals(zipArchiveEntry2));
    }
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testEquals_NullObject() {
        zipArchiveEntry1 = mock(ZipArchiveEntry.class, CALLS_REAL_METHODS);
        zipArchiveEntry2 = mock(ZipArchiveEntry.class, CALLS_REAL_METHODS);
        when(zipArchiveEntry1.getName()).thenReturn("entry1");
        when(zipArchiveEntry2.getName()).thenReturn("entry1");
        when(zipArchiveEntry1.getComment()).thenReturn("comment1");
        when(zipArchiveEntry2.getComment()).thenReturn("comment1");
        FileTime fileTime = FileTime.fromMillis(System.currentTimeMillis());
        when(zipArchiveEntry1.getLastModifiedTime()).thenReturn(fileTime);
        when(zipArchiveEntry2.getLastModifiedTime()).thenReturn(fileTime);
        when(zipArchiveEntry1.getLastAccessTime()).thenReturn(fileTime);
        when(zipArchiveEntry2.getLastAccessTime()).thenReturn(fileTime);
        when(zipArchiveEntry1.getCreationTime()).thenReturn(fileTime);
        when(zipArchiveEntry2.getCreationTime()).thenReturn(fileTime);
        when(zipArchiveEntry1.getInternalAttributes()).thenReturn(1);
        when(zipArchiveEntry2.getInternalAttributes()).thenReturn(1);
        when(zipArchiveEntry1.getPlatform()).thenReturn(1);
        when(zipArchiveEntry2.getPlatform()).thenReturn(1);
        when(zipArchiveEntry1.getExternalAttributes()).thenReturn(1L);
        when(zipArchiveEntry2.getExternalAttributes()).thenReturn(1L);
        when(zipArchiveEntry1.getMethod()).thenReturn(1);
        when(zipArchiveEntry2.getMethod()).thenReturn(1);
        when(zipArchiveEntry1.getSize()).thenReturn(100L);
        when(zipArchiveEntry2.getSize()).thenReturn(100L);
        when(zipArchiveEntry1.getCrc()).thenReturn(100L);
        when(zipArchiveEntry2.getCrc()).thenReturn(100L);
        when(zipArchiveEntry1.getCompressedSize()).thenReturn(100L);
        when(zipArchiveEntry2.getCompressedSize()).thenReturn(100L);
        byte[] extra = new byte[] {1, 2, 3};
        when(zipArchiveEntry1.getCentralDirectoryExtra()).thenReturn(extra);
        when(zipArchiveEntry2.getCentralDirectoryExtra()).thenReturn(extra);
        when(zipArchiveEntry1.getLocalFileDataExtra()).thenReturn(extra);
        when(zipArchiveEntry2.getLocalFileDataExtra()).thenReturn(extra);
        when(zipArchiveEntry1.getLocalHeaderOffset()).thenReturn(OFFSET_UNKNOWN);
        when(zipArchiveEntry2.getLocalHeaderOffset()).thenReturn(OFFSET_UNKNOWN);
        when(zipArchiveEntry1.getDataOffset()).thenReturn(OFFSET_UNKNOWN);
        when(zipArchiveEntry2.getDataOffset()).thenReturn(OFFSET_UNKNOWN);
        GeneralPurposeBit generalPurposeBit = new GeneralPurposeBit();
        when(zipArchiveEntry1.getGeneralPurposeBit()).thenReturn(generalPurposeBit);
        when(zipArchiveEntry2.getGeneralPurposeBit()).thenReturn(generalPurposeBit);
        assertFalse(zipArchiveEntry1.equals(null));
    }
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testEquals_DifferentClass() {
        zipArchiveEntry1 = mock(ZipArchiveEntry.class, CALLS_REAL_METHODS);
        zipArchiveEntry2 = mock(ZipArchiveEntry.class, CALLS_REAL_METHODS);
        when(zipArchiveEntry1.getName()).thenReturn("entry1");
        when(zipArchiveEntry2.getName()).thenReturn("entry1");
        when(zipArchiveEntry1.getComment()).thenReturn("comment1");
        when(zipArchiveEntry2.getComment()).thenReturn("comment1");
        FileTime fileTime = FileTime.fromMillis(System.currentTimeMillis());
        when(zipArchiveEntry1.getLastModifiedTime()).thenReturn(fileTime);
        when(zipArchiveEntry2.getLastModifiedTime()).thenReturn(fileTime);
        when(zipArchiveEntry1.getLastAccessTime()).thenReturn(fileTime);
        when(zipArchiveEntry2.getLastAccessTime()).thenReturn(fileTime);
        when(zipArchiveEntry1.getCreationTime()).thenReturn(fileTime);
        when(zipArchiveEntry2.getCreationTime()).thenReturn(fileTime);
        when(zipArchiveEntry1.getInternalAttributes()).thenReturn(1);
        when(zipArchiveEntry2.getInternalAttributes()).thenReturn(1);
        when(zipArchiveEntry1.getPlatform()).thenReturn(1);
        when(zipArchiveEntry2.getPlatform()).thenReturn(1);
        when(zipArchiveEntry1.getExternalAttributes()).thenReturn(1L);
        when(zipArchiveEntry2.getExternalAttributes()).thenReturn(1L);
        when(zipArchiveEntry1.getMethod()).thenReturn(1);
        when(zipArchiveEntry2.getMethod()).thenReturn(1);
        when(zipArchiveEntry1.getSize()).thenReturn(100L);
        when(zipArchiveEntry2.getSize()).thenReturn(100L);
        when(zipArchiveEntry1.getCrc()).thenReturn(100L);
        when(zipArchiveEntry2.getCrc()).thenReturn(100L);
        when(zipArchiveEntry1.getCompressedSize()).thenReturn(100L);
        when(zipArchiveEntry2.getCompressedSize()).thenReturn(100L);
        byte[] extra = new byte[] {1, 2, 3};
        when(zipArchiveEntry1.getCentralDirectoryExtra()).thenReturn(extra);
        when(zipArchiveEntry2.getCentralDirectoryExtra()).thenReturn(extra);
        when(zipArchiveEntry1.getLocalFileDataExtra()).thenReturn(extra);
        when(zipArchiveEntry2.getLocalFileDataExtra()).thenReturn(extra);
        when(zipArchiveEntry1.getLocalHeaderOffset()).thenReturn(OFFSET_UNKNOWN);
        when(zipArchiveEntry2.getLocalHeaderOffset()).thenReturn(OFFSET_UNKNOWN);
        when(zipArchiveEntry1.getDataOffset()).thenReturn(OFFSET_UNKNOWN);
        when(zipArchiveEntry2.getDataOffset()).thenReturn(OFFSET_UNKNOWN);
        GeneralPurposeBit generalPurposeBit = new GeneralPurposeBit();
        when(zipArchiveEntry1.getGeneralPurposeBit()).thenReturn(generalPurposeBit);
        when(zipArchiveEntry2.getGeneralPurposeBit()).thenReturn(generalPurposeBit);
        assertFalse(zipArchiveEntry1.equals(new Object()));
    }
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
public void testEquals_SameObject_AMTO0() {
    ZipArchiveEntry entry = new ZipArchiveEntry("testEntry");
    assertTrue(entry.equals(entry));
}
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
public void testEquals_NullObject_Cthv1() {
    ZipArchiveEntry entry = new ZipArchiveEntry("testEntry");
    assertFalse(entry.equals(null));
}
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
public void testEquals_DifferentClass_XfiT2() {
    ZipArchiveEntry entry = new ZipArchiveEntry("testEntry");
    Object other = new Object();
    assertFalse(entry.equals(other));
}
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
public void testEquals_DifferentName_snvw3() {
    ZipArchiveEntry entry1 = new ZipArchiveEntry("testEntry1");
    ZipArchiveEntry entry2 = new ZipArchiveEntry("testEntry2");
    assertFalse(entry1.equals(entry2));
}
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
public void testEquals_SameName_rdhd4() {
    ZipArchiveEntry entry1 = new ZipArchiveEntry("testEntry");
    ZipArchiveEntry entry2 = new ZipArchiveEntry("testEntry");
    assertTrue(entry1.equals(entry2));
}
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
public void testEquals_DifferentComment_DBdI5() {
    ZipArchiveEntry entry1 = new ZipArchiveEntry("testEntry");
    ZipArchiveEntry entry2 = new ZipArchiveEntry("testEntry");
    entry1.setComment("Comment1");
    entry2.setComment("Comment2");
    assertFalse(entry1.equals(entry2));
}
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
public void testEquals_SameComment_PjFZ6() {
    ZipArchiveEntry entry1 = new ZipArchiveEntry("testEntry");
    ZipArchiveEntry entry2 = new ZipArchiveEntry("testEntry");
    entry1.setComment("Comment");
    entry2.setComment("Comment");
    assertTrue(entry1.equals(entry2));
}
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
public void testEquals_DifferentLastModifiedTime_cyqr7() {
    ZipArchiveEntry entry1 = new ZipArchiveEntry("testEntry");
    ZipArchiveEntry entry2 = new ZipArchiveEntry("testEntry");
    entry1.setLastModifiedTime(FileTime.fromMillis(1000));
    entry2.setLastModifiedTime(FileTime.fromMillis(2000));
    assertFalse(entry1.equals(entry2));
}
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
public void testEquals_SameLastModifiedTime_MDIt8() {
    ZipArchiveEntry entry1 = new ZipArchiveEntry("testEntry");
    ZipArchiveEntry entry2 = new ZipArchiveEntry("testEntry");
    FileTime time = FileTime.fromMillis(1000);
    entry1.setLastModifiedTime(time);
    entry2.setLastModifiedTime(time);
    assertTrue(entry1.equals(entry2));
}
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
public void testEquals_DifferentLastAccessTime_EJub9() {
    ZipArchiveEntry entry1 = new ZipArchiveEntry("testEntry");
    ZipArchiveEntry entry2 = new ZipArchiveEntry("testEntry");
    entry1.setLastAccessTime(FileTime.fromMillis(1000));
    entry2.setLastAccessTime(FileTime.fromMillis(2000));
    assertFalse(entry1.equals(entry2));
}
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
public void testEquals_SameLastAccessTime_Qmhr10() {
    ZipArchiveEntry entry1 = new ZipArchiveEntry("testEntry");
    ZipArchiveEntry entry2 = new ZipArchiveEntry("testEntry");
    FileTime time = FileTime.fromMillis(1000);
    entry1.setLastAccessTime(time);
    entry2.setLastAccessTime(time);
    assertTrue(entry1.equals(entry2));
}
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
public void testEquals_DifferentCreationTime_AqbS11() {
    ZipArchiveEntry entry1 = new ZipArchiveEntry("testEntry");
    ZipArchiveEntry entry2 = new ZipArchiveEntry("testEntry");
    entry1.setCreationTime(FileTime.fromMillis(1000));
    entry2.setCreationTime(FileTime.fromMillis(2000));
    assertFalse(entry1.equals(entry2));
}
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
public void testEquals_SameCreationTime_yFLH12() {
    ZipArchiveEntry entry1 = new ZipArchiveEntry("testEntry");
    ZipArchiveEntry entry2 = new ZipArchiveEntry("testEntry");
    FileTime time = FileTime.fromMillis(1000);
    entry1.setCreationTime(time);
    entry2.setCreationTime(time);
    assertTrue(entry1.equals(entry2));
}
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
public void testEquals_DifferentInternalAttributes_PVZr13() {
    ZipArchiveEntry entry1 = new ZipArchiveEntry("testEntry");
    ZipArchiveEntry entry2 = new ZipArchiveEntry("testEntry");
    entry1.setInternalAttributes(1);
    entry2.setInternalAttributes(2);
    assertFalse(entry1.equals(entry2));
}
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
public void testEquals_SameInternalAttributes_DbpP14() {
    ZipArchiveEntry entry1 = new ZipArchiveEntry("testEntry");
    ZipArchiveEntry entry2 = new ZipArchiveEntry("testEntry");
    entry1.setInternalAttributes(1);
    entry2.setInternalAttributes(1);
    assertTrue(entry1.equals(entry2));
}
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
public void testEquals_DifferentPlatform_qBbt15() {
    ZipArchiveEntry entry1 = new ZipArchiveEntry("testEntry");
    ZipArchiveEntry entry2 = new ZipArchiveEntry("testEntry");
    entry1.setPlatform(1);
    entry2.setPlatform(2);
    assertFalse(entry1.equals(entry2));
}
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
public void testEquals_SamePlatform_dvEP16() {
    ZipArchiveEntry entry1 = new ZipArchiveEntry("testEntry");
    ZipArchiveEntry entry2 = new ZipArchiveEntry("testEntry");
    entry1.setPlatform(1);
    entry2.setPlatform(1);
    assertTrue(entry1.equals(entry2));
}
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
public void testEquals_DifferentExternalAttributes_qdbb17() {
    ZipArchiveEntry entry1 = new ZipArchiveEntry("testEntry");
    ZipArchiveEntry entry2 = new ZipArchiveEntry("testEntry");
    entry1.setExternalAttributes(1L);
    entry2.setExternalAttributes(2L);
    assertFalse(entry1.equals(entry2));
}
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
public void testEquals_SameExternalAttributes_hzhl18() {
    ZipArchiveEntry entry1 = new ZipArchiveEntry("testEntry");
    ZipArchiveEntry entry2 = new ZipArchiveEntry("testEntry");
    entry1.setExternalAttributes(1L);
    entry2.setExternalAttributes(1L);
    assertTrue(entry1.equals(entry2));
}
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
public void testEquals_DifferentMethod_ylyp19() {
    ZipArchiveEntry entry1 = new ZipArchiveEntry("testEntry");
    ZipArchiveEntry entry2 = new ZipArchiveEntry("testEntry");
    entry1.setMethod(ZipEntry.STORED);
    entry2.setMethod(ZipEntry.DEFLATED);
    assertFalse(entry1.equals(entry2));
}
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
public void testEquals_SameMethod_AVxY20() {
    ZipArchiveEntry entry1 = new ZipArchiveEntry("testEntry");
    ZipArchiveEntry entry2 = new ZipArchiveEntry("testEntry");
    entry1.setMethod(ZipEntry.STORED);
    entry2.setMethod(ZipEntry.STORED);
    assertTrue(entry1.equals(entry2));
}
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
public void testEquals_DifferentSize_appq21() {
    ZipArchiveEntry entry1 = new ZipArchiveEntry("testEntry");
    ZipArchiveEntry entry2 = new ZipArchiveEntry("testEntry");
    entry1.setSize(100);
    entry2.setSize(200);
    assertFalse(entry1.equals(entry2));
}
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
public void testEquals_SameSize_xWyA22() {
    ZipArchiveEntry entry1 = new ZipArchiveEntry("testEntry");
    ZipArchiveEntry entry2 = new ZipArchiveEntry("testEntry");
    entry1.setSize(100);
    entry2.setSize(100);
    assertTrue(entry1.equals(entry2));
}
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
public void testEquals_DifferentCrc_FBnY23() {
    ZipArchiveEntry entry1 = new ZipArchiveEntry("testEntry");
    ZipArchiveEntry entry2 = new ZipArchiveEntry("testEntry");
    entry1.setCrc(123456789L);
    entry2.setCrc(987654321L);
    assertFalse(entry1.equals(entry2));
}
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
public void testEquals_SameCrc_zRAt24() {
    ZipArchiveEntry entry1 = new ZipArchiveEntry("testEntry");
    ZipArchiveEntry entry2 = new ZipArchiveEntry("testEntry");
    entry1.setCrc(123456789L);
    entry2.setCrc(123456789L);
    assertTrue(entry1.equals(entry2));
}
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testGetLastModifiedDate() throws Exception {
        // Initialize the ZipArchiveEntry mock
        when(zipArchiveEntry.getTime()).thenReturn(1609459200000L); // Mock the getTime method to return a fixed timestamp
        // Expected Date from the timestamp
        Date expectedDate = new Date(1609459200000L);
        // Call the method under test
        Date actualDate = zipArchiveEntry.getLastModifiedDate();
        // Assert that the dates are equal
        assertEquals(expectedDate, actualDate);
    }
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
public void testGetLastModifiedDate_ozZN0() {
    ZipArchiveEntry zipEntry = new ZipArchiveEntry("testEntry");
    Date expectedDate = new Date();
    zipEntry.setTime(expectedDate.getTime());
    Date actualDate = zipEntry.getLastModifiedDate();
    assertEquals(expectedDate, actualDate);
}
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testGetInternalAttributes() throws Exception {
        zipArchiveEntry = new ZipArchiveEntry("testEntry");
        // Using reflection to set the internalAttributes since it's private and has no setter
        Field internalAttributesField = ZipArchiveEntry.class.getDeclaredField("internalAttributes");
        internalAttributesField.setAccessible(true);
        internalAttributesField.set(zipArchiveEntry, 12345);
        // Test the getInternalAttributes method
        int expected = 12345;
        int actual = zipArchiveEntry.getInternalAttributes();
        assertEquals(expected, actual, "The internalAttributes should match the expected value");
    }
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
public void testGetInternalAttributes_DefaultConstructor_UDJV0() {
    ZipArchiveEntry zipArchiveEntry = new ZipArchiveEntry();
    assertEquals(0, zipArchiveEntry.getInternalAttributes());
}
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testGetRawFlag() {
        zipArchiveEntry = new ZipArchiveEntry("testEntry");
        // Using reflection to set the private field `rawFlag`
        try {
            java.lang.reflect.Field field = ZipArchiveEntry.class.getDeclaredField("rawFlag");
            field.setAccessible(true);
            field.setInt(zipArchiveEntry, 123); // example rawFlag value
        } catch (NoSuchFieldException | IllegalAccessException e) {
            throw new RuntimeException(e);
        }
        int expected = 123;
        int actual = zipArchiveEntry.getRawFlag();
        assertEquals(expected, actual, "The rawFlag should match the expected value");
    }
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
public void testGetRawFlag_DefaultConstructor_tihk0() {
    ZipArchiveEntry zipEntry = new ZipArchiveEntry();
    assertEquals(0, zipEntry.getRawFlag());
}
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testSetCreationTime_1() throws Exception {
        // Assuming ZipArchiveEntry extends from ZipEntry or similar behavior
        zipArchiveEntry = new ZipArchiveEntry("testEntry");
        // Prepare
        FileTime fileTime = FileTime.fromMillis(System.currentTimeMillis());
        // Mock the behavior of the superclass method if necessary
        doCallRealMethod().when(mockZipEntry).setCreationTime(fileTime);
        // Act
        ZipEntry result = zipArchiveEntry.setCreationTime(fileTime);
        // Assert
        verify(mockZipEntry, times(1)).setCreationTime(fileTime);
        assertNotNull(result, "Result should not be null");}
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testSetCreationTime_2() throws Exception {
        // Assuming ZipArchiveEntry extends from ZipEntry or similar behavior
        zipArchiveEntry = new ZipArchiveEntry("testEntry");
        // Prepare
        FileTime fileTime = FileTime.fromMillis(System.currentTimeMillis());
        // Mock the behavior of the superclass method if necessary
        doCallRealMethod().when(mockZipEntry).setCreationTime(fileTime);
        // Act
        ZipEntry result = zipArchiveEntry.setCreationTime(fileTime);
        // Assert
        verify(mockZipEntry, times(1)).setCreationTime(fileTime);
        assertEquals(zipArchiveEntry, result, "Should return the same ZipArchiveEntry object");}
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
public void testSetCreationTime_MQVY0() {
    ZipArchiveEntry zipEntry = new ZipArchiveEntry("testEntry");
    FileTime creationTime = FileTime.fromMillis(System.currentTimeMillis());
    zipEntry.setCreationTime(creationTime);
    assertEquals(creationTime, zipEntry.getCreationTime());
}
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
public void testSetCreationTime_Xiho0() {
    ZipArchiveEntry zipEntry = new ZipArchiveEntry("testEntry");
    FileTime creationTime = FileTime.fromMillis(System.currentTimeMillis());
    ZipEntry result = zipEntry.setCreationTime(creationTime);
    assertEquals(creationTime, result.getCreationTime());
}
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testSetDiskNumberStart() {
        zipArchiveEntry = new ZipArchiveEntry("testEntry");
        long expectedDiskNumberStart = 12345L;
        zipArchiveEntry.setDiskNumberStart(expectedDiskNumberStart);
        assertEquals(expectedDiskNumberStart, zipArchiveEntry.getDiskNumberStart(), "Disk number start should match the set value");
    }
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testSetName() throws Exception {
        zipArchiveEntry = new ZipArchiveEntry("initialName");
        // Call the method under test
        zipArchiveEntry.setName(name, rawName);
        // Use reflection to access the private fields
        java.lang.reflect.Field nameField = ZipArchiveEntry.class.getDeclaredField("name");
        nameField.setAccessible(true);
        String actualName = (String) nameField.get(zipArchiveEntry);
        java.lang.reflect.Field rawNameField = ZipArchiveEntry.class.getDeclaredField("rawName");
        rawNameField.setAccessible(true);
        byte[] actualRawName = (byte[]) rawNameField.get(zipArchiveEntry);
        // Assertions
        assert actualName.equals(name) : "The name was not set correctly";
        assert java.util.Arrays.equals(actualRawName, rawName) : "The rawName was not set correctly";
    }
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testGetAlignment() throws Exception {
        zipArchiveEntry = new ZipArchiveEntry("testEntry");
        // Using reflection to set the private field 'alignment'
        Field alignmentField = ZipArchiveEntry.class.getDeclaredField("alignment");
        alignmentField.setAccessible(true);
        alignmentField.set(zipArchiveEntry, 256);  // Setting a test value
        // Act
        int result = zipArchiveEntry.getAlignment();
        // Assert
        assertEquals(256, result, "The alignment should be 256");
    }
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
public void testGetAlignment_DefaultConstructor_Tdcv0() {
    ZipArchiveEntry zipEntry = new ZipArchiveEntry();
    int expectedAlignment = 0; // Assuming default alignment is 0
    assertEquals(expectedAlignment, zipEntry.getAlignment());
}
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testSetExtra_XCgz0() {
        ZipArchiveEntry zipEntry = new ZipArchiveEntry("testEntry");
        zipEntry.setExtra();
        assertNotNull(zipEntry.getExtra());
    }
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testSetExtra_SBOn0() {
        ZipArchiveEntry entry = new ZipArchiveEntry("testEntry");
        entry.setExtra();
        assertNotNull(entry.getExtra());
    }
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testSetDataOffset() {
        zipArchiveEntry = new ZipArchiveEntry("testEntry");
        zipArchiveEntry.setDataOffset(TEST_OFFSET);
        assertEquals(TEST_OFFSET, zipArchiveEntry.getDataOffset(), "Data offset should match the set value");
    }
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testSetExtraFieldsWithUnparseableData_1() throws Exception {
        zipArchiveEntry = new ZipArchiveEntry("testEntry");
        unparseableExtra = mock(UnparseableExtraFieldData.class);
        extraFields = new ZipExtraField[] {
            mock(ZipExtraField.class),
            unparseableExtra,
            mock(ZipExtraField.class)
        };
        zipArchiveEntry.setExtraFields(extraFields);
        // Verify that the unparseable extra field is set correctly
        // Verify that other fields are added correctly
        ZipExtraField[] fields = zipArchiveEntry.getExtraFields();
        assertSame(unparseableExtra, zipArchiveEntry.getUnparseableExtraFieldData(), "Unparseable extra field should be set");}
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testSetExtraFieldsWithUnparseableData_2() throws Exception {
        zipArchiveEntry = new ZipArchiveEntry("testEntry");
        unparseableExtra = mock(UnparseableExtraFieldData.class);
        extraFields = new ZipExtraField[] {
            mock(ZipExtraField.class),
            unparseableExtra,
            mock(ZipExtraField.class)
        };
        zipArchiveEntry.setExtraFields(extraFields);
        // Verify that the unparseable extra field is set correctly
        // Verify that other fields are added correctly
        ZipExtraField[] fields = zipArchiveEntry.getExtraFields();
        assertEquals(2, fields.length, "There should be two parseable fields");}
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testSetExtraFieldsWithUnparseableData_3() throws Exception {
        zipArchiveEntry = new ZipArchiveEntry("testEntry");
        unparseableExtra = mock(UnparseableExtraFieldData.class);
        extraFields = new ZipExtraField[] {
            mock(ZipExtraField.class),
            unparseableExtra,
            mock(ZipExtraField.class)
        };
        zipArchiveEntry.setExtraFields(extraFields);
        // Verify that the unparseable extra field is set correctly
        // Verify that other fields are added correctly
        ZipExtraField[] fields = zipArchiveEntry.getExtraFields();
        assertFalse(Arrays.asList(fields).contains(unparseableExtra), "Unparseable field should not be in the extraFields array");}
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testSetExtraFieldsWithNull_1() throws Exception {
        zipArchiveEntry = new ZipArchiveEntry("testEntry");
        unparseableExtra = mock(UnparseableExtraFieldData.class);
        extraFields = new ZipExtraField[] {
            mock(ZipExtraField.class),
            unparseableExtra,
            mock(ZipExtraField.class)
        };
        zipArchiveEntry.setExtraFields(null);
        // Verify that no fields are set
        ZipExtraField[] fields = zipArchiveEntry.getExtraFields();
        assertNotNull(fields, "Extra fields array should not be null");}
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testSetExtraFieldsWithNull_2() throws Exception {
        zipArchiveEntry = new ZipArchiveEntry("testEntry");
        unparseableExtra = mock(UnparseableExtraFieldData.class);
        extraFields = new ZipExtraField[] {
            mock(ZipExtraField.class),
            unparseableExtra,
            mock(ZipExtraField.class)
        };
        zipArchiveEntry.setExtraFields(null);
        // Verify that no fields are set
        ZipExtraField[] fields = zipArchiveEntry.getExtraFields();
        assertEquals(0, fields.length, "Extra fields array should be empty");}
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testSetExtraFieldsWithNoUnparseableData_1() throws Exception {
        zipArchiveEntry = new ZipArchiveEntry("testEntry");
        unparseableExtra = mock(UnparseableExtraFieldData.class);
        extraFields = new ZipExtraField[] {
            mock(ZipExtraField.class),
            unparseableExtra,
            mock(ZipExtraField.class)
        };
        ZipExtraField[] onlyParseableFields = { mock(ZipExtraField.class), mock(ZipExtraField.class) };
        zipArchiveEntry.setExtraFields(onlyParseableFields);
        // Verify that all fields are parseable
        ZipExtraField[] fields = zipArchiveEntry.getExtraFields();
        assertEquals(2, fields.length, "There should be two parseable fields");}
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testSetExtraFieldsWithNoUnparseableData_2() throws Exception {
        zipArchiveEntry = new ZipArchiveEntry("testEntry");
        unparseableExtra = mock(UnparseableExtraFieldData.class);
        extraFields = new ZipExtraField[] {
            mock(ZipExtraField.class),
            unparseableExtra,
            mock(ZipExtraField.class)
        };
        ZipExtraField[] onlyParseableFields = { mock(ZipExtraField.class), mock(ZipExtraField.class) };
        zipArchiveEntry.setExtraFields(onlyParseableFields);
        // Verify that all fields are parseable
        ZipExtraField[] fields = zipArchiveEntry.getExtraFields();
        assertTrue(Arrays.asList(fields).containsAll(Arrays.asList(onlyParseableFields)), "All provided fields should be in the extraFields array");}
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testSetExtraFieldsWithNoUnparseableData_3() throws Exception {
        zipArchiveEntry = new ZipArchiveEntry("testEntry");
        unparseableExtra = mock(UnparseableExtraFieldData.class);
        extraFields = new ZipExtraField[] {
            mock(ZipExtraField.class),
            unparseableExtra,
            mock(ZipExtraField.class)
        };
        ZipExtraField[] onlyParseableFields = { mock(ZipExtraField.class), mock(ZipExtraField.class) };
        zipArchiveEntry.setExtraFields(onlyParseableFields);
        // Verify that all fields are parseable
        ZipExtraField[] fields = zipArchiveEntry.getExtraFields();
        assertNull(zipArchiveEntry.getUnparseableExtraFieldData(), "There should be no unparseable extra field data");}
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testSetExtraFieldsWithNull_IDXz0() {
        ZipArchiveEntry entry = new ZipArchiveEntry("testEntry");
        entry.setExtraFields(null);
        assertNull(entry.getExtraFields());
    }
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testSetExtraFieldsWithEmptyArray_RKRS1() {
        ZipArchiveEntry entry = new ZipArchiveEntry("testEntry");
        entry.setExtraFields(new ZipExtraField[0]);
        assertEquals(0, entry.getExtraFields().length);
    }
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testSetExtraFieldsWithRegularFields_Wmnv3() {
        ZipArchiveEntry entry = new ZipArchiveEntry("testEntry");
        ZipExtraField[] fields = new ZipExtraField[] { new AsiExtraField(), new X5455_ExtendedTimestamp() };
        entry.setExtraFields(fields);
        assertEquals(2, entry.getExtraFields().length);
    }
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testGetUnparseableExtraFieldData_1() throws Exception {
        // The setup is already handled by Mockito annotations
        // Setup the mock to return a specific value when getUnparseableExtraFieldData is called
        when(zipArchiveEntry.getUnparseableExtraFieldData()).thenReturn(unparseableExtra);
        // Execute the method on the class under test
        UnparseableExtraFieldData result = zipArchiveEntry.getUnparseableExtraFieldData();
        // Assert the result
        assertNotNull(result, "The result should not be null.");}
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testGetUnparseableExtraFieldData_2() throws Exception {
        // The setup is already handled by Mockito annotations
        // Setup the mock to return a specific value when getUnparseableExtraFieldData is called
        when(zipArchiveEntry.getUnparseableExtraFieldData()).thenReturn(unparseableExtra);
        // Execute the method on the class under test
        UnparseableExtraFieldData result = zipArchiveEntry.getUnparseableExtraFieldData();
        // Assert the result
        assertEquals(unparseableExtra, result, "The returned object should be the same as the mock.");}
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
public void testGetUnparseableExtraFieldData_LFWf0() {
    ZipArchiveEntry zipEntry = new ZipArchiveEntry("testEntry");
    UnparseableExtraFieldData result = zipEntry.getUnparseableExtraFieldData();
    assertNotNull(result);
}
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testSetName_WithNonNullNameAndPlatformFat_ShouldReplaceBackslashes() {
        zipArchiveEntry = new ZipArchiveEntry("initialName");
        // Arrange
        String inputName = "folder\\file";
        when(mockZipArchiveEntry.getPlatform()).thenReturn(ZipArchiveEntry.PLATFORM_FAT);
        // Act
        zipArchiveEntry.setName(inputName);
        // Assert
        assertEquals("folder/file", zipArchiveEntry.getName());
    }
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testSetName_WithNonNullNameAndNonFatPlatform_ShouldNotReplaceBackslashes() {
        zipArchiveEntry = new ZipArchiveEntry("initialName");
        // Arrange
        String inputName = "folder\\file";
        when(mockZipArchiveEntry.getPlatform()).thenReturn(ZipArchiveEntry.PLATFORM_UNIX);
        // Act
        zipArchiveEntry.setName(inputName);
        // Assert
        assertEquals("folder\\file", zipArchiveEntry.getName());
    }
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testSetName_WithNullName_ShouldSetNullName() {
        zipArchiveEntry = new ZipArchiveEntry("initialName");
        // Act
        zipArchiveEntry.setName(null);
        // Assert
        assertNull(zipArchiveEntry.getName());
    }
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testSetNameWithNullName_AhKy0() {
        ZipArchiveEntry entry = new ZipArchiveEntry("testEntry");
        entry.setName(null);
        assertNull(entry.getName());
    }
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testSetSizeWithValidSize() {
        zipArchiveEntry = new ZipArchiveEntry("testEntry");
        long validSize = 100L;
        zipArchiveEntry.setSize(validSize);
        assertEquals(validSize, zipArchiveEntry.getSize(), "The size should be set correctly.");
    }
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testSetSizeWithNegativeSize_1() {
        zipArchiveEntry = new ZipArchiveEntry("testEntry");
        long negativeSize = -1L;
        Exception exception = assertThrows(IllegalArgumentException.class, () -> {
            zipArchiveEntry.setSize(negativeSize);
        });}
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testSetSizeWithZero() {
        zipArchiveEntry = new ZipArchiveEntry("testEntry");
        long zeroSize = 0L;
        zipArchiveEntry.setSize(zeroSize);
        assertEquals(zeroSize, zipArchiveEntry.getSize(), "The size should be set correctly even if it is zero.");
    }
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
public void testSetSizeWithNegativeSize_CZMQ1() {
    ZipArchiveEntry zipEntry = new ZipArchiveEntry("testEntry");
    assertThrows(IllegalArgumentException.class, () -> zipEntry.setSize(-1));
}
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testIsStreamContiguousTrue() throws Exception {
        // Since isStreamContiguous is a private field, we need to set it up via reflection or constructor if available
        // Assuming we are using reflection to modify it directly for the purpose of the test
        java.lang.reflect.Field field = ZipArchiveEntry.class.getDeclaredField("isStreamContiguous");
        field.setAccessible(true);
        field.set(zipArchiveEntry, true); // Setting isStreamContiguous to true
        assertTrue(zipArchiveEntry.isStreamContiguous(), "The isStreamContiguous should return true when set to true");
    }
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testIsStreamContiguousFalse() throws Exception {
        // Use reflection to access the private field 'platform'
        try {
            java.lang.reflect.Field field = zipArchiveEntry.getClass().getDeclaredField("platform");
            field.setAccessible(true);
            int platformValue = (int) field.get(zipArchiveEntry);
            // Assert that the platform was set correctly
            assertEquals(NEW_PLATFORM, platformValue, "Platform should be updated to the new value");
        } catch (NoSuchFieldException | IllegalAccessException e) {
            throw new RuntimeException("Reflection operation failed", e);
        }
    }
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testSetVersionMadeBy() {
        zipArchiveEntry = new ZipArchiveEntry("testEntry");
        int expectedVersion = 20;
        zipArchiveEntry.setVersionMadeBy(expectedVersion);
        assertEquals(expectedVersion, zipArchiveEntry.getVersionMadeBy(), "The versionMadeBy should match the set value");
    }
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
public void testSetVersionMadeBy_QZjy0() {
    ZipArchiveEntry zipEntry = new ZipArchiveEntry("testEntry");
    zipEntry.setVersionMadeBy(20);
    assertEquals(20, zipEntry.getVersionMadeBy());
}
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testGetLocalHeaderOffset_InitiallyUnknown() {
        zipArchiveEntry = new ZipArchiveEntry("testEntry");
        // Assuming there's a way to set the localHeaderOffset, since it's private and no setter is shown
        // For the purpose of this test, we'll assume it's set through some internal mechanism or constructor
        // Test the initial state of localHeaderOffset to ensure it is OFFSET_UNKNOWN
        assertEquals(OFFSET_UNKNOWN, zipArchiveEntry.getLocalHeaderOffset(), "The localHeaderOffset should initially be unknown");
    }
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
public void testGetLocalHeaderOffset_Lqyi0() {
    ZipArchiveEntry zipEntry = new ZipArchiveEntry("testEntry");
    long expectedOffset = 0; // Assuming default constructor sets offset to 0
    long actualOffset = zipEntry.getLocalHeaderOffset();
    assertEquals(expectedOffset, actualOffset);
}
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testSetLocalHeaderOffset_1() {
        zipArchiveEntry = new ZipArchiveEntry("testEntry");
        // Initially, should be unknown offset
        // Set to a known offset
        zipArchiveEntry.setLocalHeaderOffset(TEST_OFFSET);
        assertEquals(OFFSET_UNKNOWN, zipArchiveEntry.getLocalHeaderOffset(), "Initial offset should be unknown");}
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testSetLocalHeaderOffset_2() {
        zipArchiveEntry = new ZipArchiveEntry("testEntry");
        // Initially, should be unknown offset
        // Set to a known offset
        zipArchiveEntry.setLocalHeaderOffset(TEST_OFFSET);
        assertEquals(TEST_OFFSET, zipArchiveEntry.getLocalHeaderOffset(), "Offset should match the set value");}
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testSetExternalAttributes() {
        zipArchiveEntry = new ZipArchiveEntry("testEntry");
        long expectedAttributes = 0xFF;
        zipArchiveEntry.setExternalAttributes(expectedAttributes);
        // Assuming getExternalAttributes method exists to retrieve the value
        // Since it's not in the provided code, this line is hypothetical
        assertEquals(expectedAttributes, zipArchiveEntry.getExternalAttributes(), "The external attributes were not set correctly.");
    }
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
public void testSetExternalAttributes_EwiU0() {
    ZipArchiveEntry zipEntry = new ZipArchiveEntry("testEntry");
    zipEntry.setExternalAttributes(12345L);
    assertEquals(12345L, zipEntry.getExternalAttributes());
}
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testSetCentralDirectoryExtraWithInvalidDataThrowsException_1() {
        zipArchiveEntry = new ZipArchiveEntry("testEntry");
        // Assuming this data causes parseExtraFields to throw a ZipException
        byte[] invalidExtraData = new byte[]{0x7F, (byte) 0xFF, (byte) 0xFF, (byte) 0xFF};
        Exception exception = assertThrows(IllegalArgumentException.class, () -> zipArchiveEntry.setCentralDirectoryExtra(invalidExtraData));}
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
public void testSetCentralDirectoryExtraWithValidData_HBtJ0() {
    ZipArchiveEntry zipEntry = new ZipArchiveEntry("testEntry");
    byte[] validExtraData = new byte[]{0x01, 0x02, 0x03}; // Assuming this is valid data for the test case
    try {
        zipEntry.setCentralDirectoryExtra(validExtraData);
    } catch (IllegalArgumentException e) {
        fail("Should not have thrown an IllegalArgumentException");
    }
}
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
public void testSetExtraWithValidData_rZAZ0() {
    ZipArchiveEntry entry = new ZipArchiveEntry("testEntry");
    byte[] extraData = new byte[]{1, 2, 3, 4};
    entry.setExtra(extraData);
    assertNotNull(entry.getExtra());
}
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
public void testSetExtraWithNull_SxVM1() {
    ZipArchiveEntry entry = new ZipArchiveEntry("testEntry");
    entry.setExtra(null);
    assertNull(entry.getExtra());
}
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
public void testSetExtraWithEmptyArray_eqDO2() {
    ZipArchiveEntry entry = new ZipArchiveEntry("testEntry");
    entry.setExtra(new byte[]{});
    assertArrayEquals(new byte[]{}, entry.getExtra());
}
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
public void testSetExtraWithInvalidData_KFni3() {
    ZipArchiveEntry entry = new ZipArchiveEntry("testEntry");
    byte[] extraData = new byte[]{127, -128, 0, 1}; // Assuming this data could be invalid
    try {
        entry.setExtra(extraData);
        fail("Expected an IllegalArgumentException to be thrown");
    } catch (IllegalArgumentException e) {
        assertEquals("Error parsing extra fields for entry: testEntry - Invalid extra field data", e.getMessage());
    }
}
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
public void testSetExtraWithLargeData_Xtst4() {
    ZipArchiveEntry entry = new ZipArchiveEntry("testEntry");
    byte[] extraData = new byte[1024]; // Large data array
    Arrays.fill(extraData, (byte) 1);
    entry.setExtra(extraData);
    assertEquals(1024, entry.getExtra().length);
}
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
public void testSetExtraWithBoundaryData_NKfF5() {
    ZipArchiveEntry entry = new ZipArchiveEntry("testEntry");
    byte[] extraData = new byte[]{Byte.MAX_VALUE, Byte.MIN_VALUE};
    entry.setExtra(extraData);
    assertArrayEquals(new byte[]{Byte.MAX_VALUE, Byte.MIN_VALUE}, entry.getExtra());
}
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
public void testSetExtraWithFileInput_ZIvS6() {
    File file = new File("testFile.txt");
    ZipArchiveEntry entry = new ZipArchiveEntry(file, "testEntry");
    byte[] extraData = new byte[]{5, 10, 15, 20};
    entry.setExtra(extraData);
    assertArrayEquals(new byte[]{5, 10, 15, 20}, entry.getExtra());
}
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
public void testSetExtraWithZipEntryInput_nPCn8() throws ZipException {
    java.util.zip.ZipEntry zipEntry = new java.util.zip.ZipEntry("zipEntry");
    ZipArchiveEntry entry = new ZipArchiveEntry(zipEntry);
    byte[] extraData = new byte[]{21, 22, 23, 24};
    entry.setExtra(extraData);
    assertArrayEquals(new byte[]{21, 22, 23, 24}, entry.getExtra());
}
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
public void testSetExtraWithCopyConstructor_uNyR9() throws ZipException {
    ZipArchiveEntry originalEntry = new ZipArchiveEntry("originalEntry");
    byte[] extraData = new byte[]{11, 12, 13, 14};
    originalEntry.setExtra(extraData);
    ZipArchiveEntry copiedEntry = new ZipArchiveEntry(originalEntry);
    assertArrayEquals(new byte[]{11, 12, 13, 14}, copiedEntry.getExtra());
}
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
public void testGetExtraFieldsIncludeUnparseableTrue_xEsb0_1() {
    ZipArchiveEntry zipArchiveEntry = new ZipArchiveEntry("testEntry");
    ZipExtraField[] result = zipArchiveEntry.getExtraFields(true);
    assertNotNull(result);}
}