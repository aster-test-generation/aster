/**
 * Generated by Aster
 */
package org.apache.commons.compress.archivers.tar;
import java.nio.charset.StandardCharsets.UTF_8;
import java.io.File;
import java.io.IOException;
import java.io.OutputStream;
import java.io.StringWriter;
import java.math.BigDecimal;
import java.math.RoundingMode;
import java.nio.ByteBuffer;
import java.nio.charset.StandardCharsets;
import java.nio.file.LinkOption;
import java.nio.file.Path;
import java.nio.file.attribute.FileTime;
import java.time.Instant;
import java.util.Arrays;
import java.util.HashMap;
import java.util.Map;
import org.apache.commons.compress.archivers.ArchiveOutputStream;
import org.apache.commons.compress.archivers.zip.ZipEncoding;
import org.apache.commons.compress.archivers.zip.ZipEncodingHelper;
import org.apache.commons.compress.utils.FixedLengthBlockOutputStream;
import org.apache.commons.compress.utils.TimeUtils;
import org.apache.commons.io.Charsets;
import org.apache.commons.io.output.CountingOutputStream;
import org.apache.commons.compress.compressors.lz77support.Parameters;
import org.apache.commons.compress.archivers.zip.ZipEightByteInteger;
import org.apache.commons.compress.harmony.unpack200.bytecode.RuntimeVisibleorInvisibleAnnotationsAttribute;
import org.apache.commons.compress.archivers.sevenz.Archive;
import org.apache.commons.compress.archivers.ar.ArArchiveEntry;
import org.apache.commons.compress.compressors.bzip2.BlockSort;
import org.apache.commons.compress.archivers.zip.ZipArchiveEntryRequestSupplier;
import org.apache.commons.compress.archivers.cpio.CpioArchiveInputStream;
import org.apache.commons.compress.compressors.CompressorException;
import org.apache.commons.compress.archivers.zip.ZipFile;
import org.apache.commons.compress.compressors.deflate64.Deflate64CompressorInputStream;
import org.apache.commons.compress.compressors.brotli.BrotliCompressorInputStream;
import org.apache.commons.compress.archivers.dump.DumpArchiveUtil;
import org.apache.commons.compress.compressors.bzip2.CRC;
import org.apache.commons.compress.archivers.zip.UnicodePathExtraField;
import org.apache.commons.compress.utils.IOUtils;
import org.apache.commons.compress.harmony.unpack200.bytecode.forms.ByteForm;
import org.apache.commons.compress.harmony.unpack200.bytecode.forms.IMethodRefForm;
import org.apache.commons.compress.archivers.examples.CloseableConsumer;
import org.apache.commons.compress.compressors.CompressorInputStream;
import org.apache.commons.compress.harmony.unpack200.bytecode.forms.LookupSwitchForm;
import org.apache.commons.compress.harmony.unpack200.bytecode.forms.LocalForm;
import org.apache.commons.compress.archivers.dump.TapeInputStream;
import org.apache.commons.compress.archivers.zip.Zip64Mode;
import org.apache.commons.compress.harmony.unpack200.bytecode.ByteCode;
import org.apache.commons.compress.compressors.gzip.GzipParameters;
import org.apache.commons.compress.harmony.unpack200.CpBands;
import org.apache.commons.compress.archivers.tar.TarArchiveSparseZeroInputStream;
import org.apache.commons.compress.harmony.unpack200.bytecode.DeprecatedAttribute;
import org.apache.commons.compress.harmony.unpack200.bytecode.NewAttribute;
import org.apache.commons.compress.archivers.zip.PKWareExtraHeader;
import org.apache.commons.compress.archivers.arj.MainHeader;
import org.apache.commons.compress.archivers.sevenz.NID;
import org.apache.commons.compress.compressors.lz4.FramedLZ4CompressorInputStream;
import org.apache.commons.compress.harmony.unpack200.ClassBands;
import org.apache.commons.compress.archivers.zip.ZipEncodingHelper;
import org.apache.commons.compress.archivers.zip.ExtraFieldUtils;
import org.apache.commons.compress.harmony.unpack200.bytecode.forms.MultiANewArrayForm;
import org.apache.commons.compress.harmony.pack200.CPSignature;
import org.apache.commons.compress.compressors.pack200.Pack200Utils;
import org.apache.commons.compress.compressors.deflate.DeflateCompressorOutputStream;
import org.apache.commons.compress.harmony.unpack200.bytecode.forms.SingleByteReferenceForm;
import org.apache.commons.compress.archivers.zip.X000A_NTFS;
import org.apache.commons.compress.archivers.zip.SeekableChannelRandomAccessOutputStream;
import org.apache.commons.compress.parallel.FileBasedScatterGatherBackingStore;
import org.apache.commons.compress.archivers.sevenz.StartHeader;
import org.apache.commons.compress.utils.Sets;
import org.apache.commons.compress.utils.Iterators;
import org.apache.commons.compress.archivers.zip.ZipSplitReadOnlySeekableByteChannel;
import org.apache.commons.compress.archivers.zip.UnsupportedZipFeatureException;
import org.apache.commons.compress.archivers.ar.ArArchiveOutputStream;
import org.apache.commons.compress.harmony.unpack200.bytecode.LocalVariableTypeTableAttribute;
import org.apache.commons.compress.utils.CountingInputStream;
import org.apache.commons.compress.harmony.unpack200.SegmentUtils;
import org.apache.commons.compress.harmony.unpack200.bytecode.forms.ThisMethodRefForm;
import org.apache.commons.compress.archivers.zip.BitStream;
import org.apache.commons.compress.archivers.ArchiveInputStream;
import org.apache.commons.compress.compressors.deflate64.HuffmanState;
import org.apache.commons.compress.compressors.CompressorStreamFactory;
import org.apache.commons.compress.archivers.arj.ArjArchiveEntry;
import org.apache.commons.compress.compressors.lzma.LZMACompressorInputStream;
import org.apache.commons.compress.utils.ArchiveUtils;
import org.apache.commons.compress.utils.ChecksumCalculatingInputStream;
import org.apache.commons.compress.compressors.snappy.SnappyCompressorOutputStream;
import org.apache.commons.compress.harmony.pack200.MetadataBandGroup;
import org.apache.commons.compress.archivers.Lister;
import org.apache.commons.compress.harmony.pack200.Codec;
import org.apache.commons.compress.harmony.pack200.CPNameAndType;
import org.apache.commons.compress.archivers.arj.ArjArchiveInputStream;
import org.apache.commons.compress.archivers.dump.DumpArchiveInputStream;
import org.apache.commons.compress.compressors.lz4.BlockLZ4CompressorInputStream;
import org.apache.commons.compress.archivers.sevenz.SevenZArchiveEntry;
import org.apache.commons.compress.harmony.unpack200.bytecode.CPNameAndType;
import org.apache.commons.compress.archivers.sevenz.BoundedSeekableByteChannelInputStream;
import org.apache.commons.compress.archivers.zip.InflaterInputStreamWithStatistics;
import org.apache.commons.compress.utils.ByteUtils;
import org.apache.commons.compress.archivers.zip.ParallelScatterZipCreator;
import org.apache.commons.compress.archivers.zip.UnparseableExtraFieldData;
import org.apache.commons.compress.utils.ServiceLoaderIterator;
import org.apache.commons.compress.archivers.zip.ZipArchiveEntry;
import org.apache.commons.compress.compressors.pack200.Pack200CompressorInputStream;
import org.apache.commons.compress.archivers.cpio.CpioConstants;
import org.apache.commons.compress.harmony.unpack200.bytecode.Attribute;
import org.apache.commons.compress.harmony.pack200.CPClass;
import org.apache.commons.compress.harmony.unpack200.bytecode.AnnotationsAttribute;
import org.apache.commons.compress.utils.SeekableInMemoryByteChannel;
import org.apache.commons.compress.harmony.unpack200.bytecode.CPConstant;
import org.apache.commons.compress.harmony.unpack200.bytecode.forms.ShortForm;
import org.apache.commons.compress.archivers.sevenz.AES256Options;
import org.apache.commons.compress.compressors.zstandard.ZstdCompressorInputStream;
import org.apache.commons.compress.archivers.zip.BinaryTree;
import org.apache.commons.compress.harmony.pack200.FileBands;
import org.apache.commons.compress.utils.CRC32VerifyingInputStream;
import org.apache.commons.compress.harmony.unpack200.bytecode.EnclosingMethodAttribute;
import org.apache.commons.compress.archivers.zip.ZipArchiveEntryPredicate;
import org.apache.commons.compress.archivers.sevenz.StreamMap;
import org.apache.commons.compress.archivers.sevenz.CLI;
import org.apache.commons.compress.harmony.unpack200.bytecode.forms.NewClassRefForm;
import org.apache.commons.compress.compressors.zstandard.ZstdCompressorOutputStream;
import org.apache.commons.compress.archivers.zip.X0017_StrongEncryptionHeader;
import org.apache.commons.compress.utils.BitInputStream;
import org.apache.commons.compress.utils.TimeUtils;
import org.apache.commons.compress.compressors.lzw.LZWInputStream;
import org.apache.commons.compress.harmony.unpack200.bytecode.CPClass;
import org.apache.commons.compress.archivers.zip.UnrecognizedExtraField;
import org.apache.commons.compress.harmony.unpack200.bytecode.LineNumberTableAttribute;
import org.apache.commons.compress.compressors.bzip2.BZip2Constants;
import org.apache.commons.compress.harmony.pack200.AttributeDefinitionBands;
import org.apache.commons.compress.utils.FixedLengthBlockOutputStream;
import org.apache.commons.compress.archivers.cpio.CpioArchiveEntry;
import org.apache.commons.compress.harmony.unpack200.bytecode.forms.StringRefForm;
import org.apache.commons.compress.harmony.pack200.CPConstant;
import org.apache.commons.compress.archivers.zip.ZipArchiveOutputStream;
import org.apache.commons.compress.archivers.jar.JarArchiveInputStream;
import org.apache.commons.compress.harmony.unpack200.bytecode.ConstantValueAttribute;
import org.apache.commons.compress.harmony.pack200.Archive;
import org.apache.commons.compress.compressors.deflate.DeflateCompressorInputStream;
import org.apache.commons.compress.archivers.examples.CloseableConsumerAdapter;
import org.apache.commons.compress.harmony.pack200.RunCodec;
import org.apache.commons.compress.harmony.pack200.CpBands;
import org.apache.commons.compress.utils.BoundedSeekableByteChannelInputStream;
import org.apache.commons.compress.harmony.unpack200.bytecode.forms.ByteCodeForm;
import org.apache.commons.compress.archivers.ArchiveOutputStream;
import org.apache.commons.compress.MemoryLimitException;
import org.apache.commons.compress.compressors.lz77support.AbstractLZ77CompressorInputStream;
import org.apache.commons.compress.harmony.unpack200.Archive;
import org.apache.commons.compress.harmony.unpack200.bytecode.CPLong;
import org.apache.commons.compress.archivers.zip.ScatterStatistics;
import org.apache.commons.compress.java.util.jar.Pack200;
import org.apache.commons.compress.archivers.tar.TarArchiveInputStream;
import org.apache.commons.compress.harmony.unpack200.bytecode.ExceptionTableEntry;
import org.apache.commons.compress.utils.OsgiUtils;
import org.apache.commons.compress.harmony.unpack200.SegmentConstantPool;
import org.apache.commons.compress.archivers.tar.TarArchiveEntry;
import org.apache.commons.compress.archivers.sevenz.LZMA2Decoder;
import org.apache.commons.compress.harmony.unpack200.bytecode.forms.FloatRefForm;
import org.apache.commons.compress.archivers.dump.Dirent;
import org.apache.commons.compress.harmony.unpack200.bytecode.CPMethod;
import org.apache.commons.compress.archivers.sevenz.BindPair;
import org.apache.commons.compress.harmony.unpack200.bytecode.forms.MethodRefForm;
import org.apache.commons.compress.archivers.sevenz.LZMADecoder;
import org.apache.commons.compress.harmony.unpack200.bytecode.CPFieldRef;
import org.apache.commons.compress.archivers.jar.JarArchiveOutputStream;
import org.apache.commons.compress.compressors.xz.XZCompressorInputStream;
import org.apache.commons.compress.utils.ExactMath;
import org.apache.commons.compress.harmony.unpack200.AttributeLayoutMap;
import org.apache.commons.compress.harmony.unpack200.bytecode.CPMember;
import org.apache.commons.compress.changes.ChangeSetResults;
import org.apache.commons.compress.harmony.pack200.CPInt;
import org.apache.commons.compress.harmony.unpack200.bytecode.ExceptionsAttribute;
import org.apache.commons.compress.archivers.tar.TarArchiveOutputStream;
import org.apache.commons.compress.archivers.zip.Zip64ExtendedInformationExtraField;
import org.apache.commons.compress.harmony.unpack200.bytecode.BCIRenumberedAttribute;
import org.apache.commons.compress.compressors.snappy.FramedSnappyCompressorInputStream;
import org.apache.commons.compress.parallel.ScatterGatherBackingStore;
import org.apache.commons.compress.archivers.zip.X0016_CertificateIdForCentralDirectory;
import org.apache.commons.compress.archivers.tar.TarConstants;
import org.apache.commons.compress.harmony.unpack200.bytecode.forms.SuperMethodRefForm;
import org.apache.commons.compress.harmony.unpack200.bytecode.CPInteger;
import org.apache.commons.compress.harmony.pack200.PackingUtils;
import org.apache.commons.compress.parallel.InputStreamSupplier;
import org.apache.commons.compress.harmony.unpack200.Segment;
import org.apache.commons.compress.archivers.zip.RandomAccessOutputStream;
import org.apache.commons.compress.harmony.unpack200.bytecode.CPMethodRef;
import org.apache.commons.compress.harmony.archive.internal.nls.Messages;
import org.apache.commons.compress.harmony.unpack200.bytecode.forms.ClassRefForm;
import org.apache.commons.compress.harmony.unpack200.bytecode.OperandManager;
import org.apache.commons.compress.harmony.unpack200.bytecode.forms.FieldRefForm;
import org.apache.commons.compress.harmony.unpack200.bytecode.LocalVariableTableAttribute;
import org.apache.commons.compress.archivers.sevenz.AbstractCoder;
import org.apache.commons.compress.harmony.unpack200.IMatcher;
import org.apache.commons.compress.harmony.unpack200.bytecode.forms.SwitchForm;
import org.apache.commons.compress.harmony.unpack200.bytecode.forms.LabelForm;
import org.apache.commons.compress.harmony.pack200.BHSDCodec;
import org.apache.commons.compress.archivers.zip.ZipShort;
import org.apache.commons.compress.harmony.unpack200.AttrDefinitionBands;
import org.apache.commons.compress.harmony.unpack200.bytecode.forms.DoubleForm;
import org.apache.commons.compress.harmony.unpack200.SegmentOptions;
import org.apache.commons.compress.archivers.zip.ZipArchiveInputStream;
import org.apache.commons.compress.archivers.dump.DumpArchiveConstants;
import org.apache.commons.compress.archivers.zip.AsiExtraField;
import org.apache.commons.compress.harmony.unpack200.bytecode.CPString;
import org.apache.commons.compress.harmony.pack200.CPString;
import org.apache.commons.compress.archivers.examples.Expander;
import org.apache.commons.compress.harmony.unpack200.bytecode.CPUTF8;
import org.apache.commons.compress.harmony.unpack200.bytecode.CPConstantNumber;
import org.apache.commons.compress.compressors.pack200.Pack200CompressorOutputStream;
import org.apache.commons.compress.compressors.pack200.InMemoryCachingStreamBridge;
import org.apache.commons.compress.harmony.unpack200.bytecode.forms.TableSwitchForm;
import org.apache.commons.compress.compressors.lz77support.LZ77Compressor;
import org.apache.commons.compress.changes.ChangeSetPerformer;
import org.apache.commons.compress.archivers.tar.TarUtils;
import org.apache.commons.compress.archivers.ArchiveStreamFactory;
import org.apache.commons.compress.archivers.ar.ArArchiveInputStream;
import org.apache.commons.compress.compressors.snappy.FramedSnappyDialect;
import org.apache.commons.compress.changes.ChangeSet;
import org.apache.commons.compress.archivers.EntryStreamOffsets;
import org.apache.commons.compress.harmony.pack200.PopulationCodec;
import org.apache.commons.compress.utils.CharsetNames;
import org.apache.commons.compress.compressors.bzip2.Rand;
import org.apache.commons.compress.harmony.unpack200.bytecode.forms.ClassSpecificReferenceForm;
import org.apache.commons.compress.archivers.sevenz.SevenZOutputFile;
import org.apache.commons.compress.harmony.pack200.CPLong;
import org.apache.commons.compress.archivers.zip.Zip64RequiredException;
import org.apache.commons.compress.archivers.sevenz.Folder;
import org.apache.commons.compress.harmony.unpack200.bytecode.ClassConstantPool;
import org.apache.commons.compress.harmony.unpack200.IcBands;
import org.apache.commons.compress.compressors.z.ZCompressorInputStream;
import org.apache.commons.compress.archivers.sevenz.SevenZMethodConfiguration;
import org.apache.commons.compress.compressors.lz4.BlockLZ4CompressorOutputStream;
import org.apache.commons.compress.compressors.CompressorStreamProvider;
import org.apache.commons.compress.harmony.unpack200.bytecode.forms.SuperFieldRefForm;
import org.apache.commons.compress.harmony.unpack200.bytecode.ConstantPoolEntry;
import org.apache.commons.compress.archivers.zip.ZipConstants;
import org.apache.commons.compress.harmony.pack200.PackingOptions;
import org.apache.commons.compress.archivers.tar.TarArchiveStructSparse;
import org.apache.commons.compress.archivers.zip.JarMarker;
import org.apache.commons.compress.harmony.unpack200.bytecode.forms.LongForm;
import org.apache.commons.compress.archivers.zip.X5455_ExtendedTimestamp;
import org.apache.commons.compress.harmony.pack200.CanonicalCodecFamilies;
import org.apache.commons.compress.archivers.zip.CircularBuffer;
import org.apache.commons.compress.harmony.unpack200.bytecode.forms.ReferenceForm;
import org.apache.commons.compress.harmony.pack200.NewAttribute;
import org.apache.commons.compress.harmony.unpack200.BandSet;
import org.apache.commons.compress.compressors.bzip2.BZip2CompressorInputStream;
import org.apache.commons.compress.archivers.zip.ZipMethod;
import org.apache.commons.compress.harmony.unpack200.bytecode.forms.InitMethodReferenceForm;
import org.apache.commons.compress.compressors.snappy.SnappyCompressorInputStream;
import org.apache.commons.compress.archivers.tar.TarArchiveSparseEntry;
import org.apache.commons.compress.utils.FileNameUtils;
import org.apache.commons.compress.harmony.unpack200.SegmentConstantPoolArrayCache;
import org.apache.commons.compress.utils.CloseShieldFilterInputStream;
import org.apache.commons.compress.utils.BoundedArchiveInputStream;
import org.apache.commons.compress.compressors.brotli.BrotliUtils;
import org.apache.commons.compress.harmony.pack200.Segment;
import org.apache.commons.compress.compressors.gzip.GzipCompressorInputStream;
import org.apache.commons.compress.harmony.unpack200.bytecode.CPField;
import org.apache.commons.compress.archivers.ArchiveEntry;
import org.apache.commons.compress.archivers.dump.ShortFileException;
import org.apache.commons.compress.compressors.CompressorOutputStream;
import org.apache.commons.compress.compressors.lzma.LZMACompressorOutputStream;
import org.apache.commons.compress.compressors.bzip2.BZip2Utils;
import org.apache.commons.compress.compressors.zstandard.ZstdUtils;
import org.apache.commons.compress.archivers.zip.NioZipEncoding;
import org.apache.commons.compress.compressors.pack200.AbstractStreamBridge;
import org.apache.commons.compress.compressors.xz.XZUtils;
import org.apache.commons.compress.utils.Charsets;
import org.apache.commons.compress.harmony.unpack200.bytecode.forms.NoArgumentForm;
import org.apache.commons.compress.archivers.zip.UnshrinkingInputStream;
import org.apache.commons.compress.harmony.unpack200.bytecode.forms.ThisFieldRefForm;
import org.apache.commons.compress.utils.ChecksumVerifyingInputStream;
import org.apache.commons.compress.compressors.snappy.FramedSnappyCompressorOutputStream;
import org.apache.commons.compress.harmony.unpack200.bytecode.forms.NarrowClassRefForm;
import org.apache.commons.compress.archivers.dump.DumpArchiveException;
import org.apache.commons.compress.archivers.sevenz.SubStreamsInfo;
import org.apache.commons.compress.harmony.unpack200.bytecode.SourceFileAttribute;
import org.apache.commons.compress.archivers.zip.GeneralPurposeBit;
import org.apache.commons.compress.compressors.pack200.TempFileCachingStreamBridge;
import org.apache.commons.compress.archivers.sevenz.SevenZMethod;
import org.apache.commons.compress.harmony.pack200.SegmentHeader;
import org.apache.commons.compress.compressors.lz4.FramedLZ4CompressorOutputStream;
import org.apache.commons.compress.harmony.pack200.BcBands;
import org.apache.commons.compress.harmony.pack200.CPFloat;
import org.apache.commons.compress.compressors.pack200.Pack200Strategy;
import org.apache.commons.compress.harmony.unpack200.bytecode.CodeAttribute;
import org.apache.commons.compress.archivers.zip.ZipExtraField;
import org.apache.commons.compress.archivers.jar.JarArchiveEntry;
import org.apache.commons.compress.harmony.unpack200.bytecode.ClassFileEntry;
import org.apache.commons.compress.harmony.pack200.CPUTF8;
import org.apache.commons.compress.harmony.pack200.IntList;
import org.apache.commons.compress.harmony.unpack200.bytecode.forms.VariableInstructionForm;
import org.apache.commons.compress.archivers.zip.ZipLong;
import org.apache.commons.compress.harmony.pack200.BandSet;
import org.apache.commons.compress.harmony.pack200.IcBands;
import org.apache.commons.compress.archivers.sevenz.AES256SHA256Decoder;
import org.apache.commons.compress.harmony.unpack200.NewAttributeBands;
import org.apache.commons.compress.changes.Change;
import org.apache.commons.compress.utils.Lists;
import org.apache.commons.compress.PasswordRequiredException;
import org.apache.commons.compress.harmony.unpack200.bytecode.AnnotationDefaultAttribute;
import org.apache.commons.compress.harmony.unpack200.bytecode.forms.IntRefForm;
import org.apache.commons.compress.archivers.zip.ExtraFieldParsingBehavior;
import org.apache.commons.compress.archivers.sevenz.SevenZFile;
import org.apache.commons.compress.archivers.zip.FileRandomAccessOutputStream;
import org.apache.commons.compress.archivers.dump.DumpArchiveEntry;
import org.apache.commons.compress.harmony.pack200.Pack200ClassReader;
import org.apache.commons.compress.harmony.pack200.NewAttributeBands;
import org.apache.commons.compress.compressors.deflate64.HuffmanDecoder;
import org.apache.commons.compress.compressors.deflate.DeflateParameters;
import org.apache.commons.compress.archivers.sevenz.SevenZFileOptions;
import org.apache.commons.compress.harmony.pack200.CPDouble;
import org.apache.commons.compress.archivers.dump.UnrecognizedFormatException;
import org.apache.commons.compress.utils.CountingOutputStream;
import org.apache.commons.compress.utils.InputStreamStatistics;
import org.apache.commons.compress.compressors.xz.XZCompressorOutputStream;
import org.apache.commons.compress.archivers.zip.UnparseableExtraFieldBehavior;
import org.apache.commons.compress.harmony.unpack200.bytecode.SignatureAttribute;
import org.apache.commons.compress.harmony.unpack200.Pack200UnpackerAdapter;
import org.apache.commons.compress.compressors.FileNameUtil;
import org.apache.commons.compress.archivers.zip.X7875_NewUnix;
import org.apache.commons.compress.archivers.tar.TarGnuSparseKeys;
import org.apache.commons.compress.utils.FlushShieldFilterOutputStream;
import org.apache.commons.compress.parallel.ScatterGatherBackingStoreSupplier;
import org.apache.commons.compress.archivers.ArchiveException;
import org.apache.commons.compress.harmony.unpack200.bytecode.forms.WideForm;
import org.apache.commons.compress.harmony.unpack200.bytecode.forms.ThisInitMethodRefForm;
import org.apache.commons.compress.archivers.tar.TarFile;
import org.apache.commons.compress.archivers.dump.InvalidFormatException;
import org.apache.commons.compress.harmony.unpack200.IcTuple;
import org.apache.commons.compress.harmony.unpack200.AttributeLayout;
import org.apache.commons.compress.harmony.unpack200.bytecode.CPRef;
import org.apache.commons.compress.archivers.sevenz.Coders;
import org.apache.commons.compress.archivers.zip.ScatterZipOutputStream;
import org.apache.commons.compress.archivers.arj.LocalFileHeader;
import org.apache.commons.compress.utils.ParsingUtils;
import org.apache.commons.compress.archivers.zip.CharsetAccessor;
import org.apache.commons.compress.archivers.dump.UnsupportedCompressionAlgorithmException;
import org.apache.commons.compress.archivers.zip.DefaultBackingStoreSupplier;
import org.apache.commons.compress.compressors.bzip2.BZip2CompressorOutputStream;
import org.apache.commons.compress.harmony.unpack200.bytecode.RuntimeVisibleorInvisibleParameterAnnotationsAttribute;
import org.apache.commons.compress.compressors.gzip.GzipCompressorOutputStream;
import org.apache.commons.compress.archivers.cpio.CpioArchiveOutputStream;
import org.apache.commons.compress.harmony.unpack200.bytecode.ClassFile;
import org.apache.commons.compress.archivers.zip.ZipSplitOutputStream;
import org.apache.commons.compress.harmony.pack200.Pack200PackerAdapter;
import org.apache.commons.compress.archivers.zip.UnicodeCommentExtraField;
import org.apache.commons.compress.archivers.sevenz.Coder;
import org.apache.commons.compress.archivers.StreamingNotSupportedException;
import org.apache.commons.compress.archivers.dump.DumpArchiveSummary;
import org.apache.commons.compress.compressors.lz4.XXHash32;
import org.apache.commons.compress.archivers.ArchiveStreamProvider;
import org.apache.commons.compress.harmony.pack200.CodecEncoding;
import org.apache.commons.compress.harmony.unpack200.bytecode.forms.NewInitMethodRefForm;
import org.apache.commons.compress.archivers.zip.ResourceAlignmentExtraField;
import org.apache.commons.compress.archivers.zip.X0019_EncryptionRecipientCertificateList;
import org.apache.commons.compress.compressors.gzip.GzipUtils;
import org.apache.commons.compress.harmony.unpack200.MetadataBandGroup;
import org.apache.commons.compress.archivers.zip.UnixStat;
import org.apache.commons.compress.archivers.zip.ExplodingInputStream;
import org.apache.commons.compress.archivers.zip.X0014_X509Certificates;
import org.apache.commons.compress.archivers.zip.AbstractUnicodeExtraField;
import org.apache.commons.compress.harmony.unpack200.bytecode.CPInterfaceMethodRef;
import org.apache.commons.compress.harmony.unpack200.bytecode.forms.IincForm;
import org.apache.commons.compress.utils.BoundedInputStream;
import org.apache.commons.compress.harmony.pack200.ConstantPoolEntry;
import org.apache.commons.compress.archivers.zip.StreamCompressor;
import org.apache.commons.compress.harmony.pack200.CPMethodOrField;
import org.apache.commons.compress.harmony.unpack200.bytecode.forms.SuperInitMethodRefForm;
import org.apache.commons.compress.archivers.zip.X0015_CertificateIdForFile;
import org.apache.commons.compress.harmony.unpack200.bytecode.InnerClassesAttribute;
import org.apache.commons.compress.archivers.zip.ZipArchiveEntryRequest;
import org.apache.commons.compress.compressors.lzma.LZMAUtils;
import org.apache.commons.compress.harmony.unpack200.BcBands;
import org.apache.commons.compress.utils.MultiReadOnlySeekableByteChannel;
import org.apache.commons.compress.harmony.pack200.ClassBands;
import org.apache.commons.compress.harmony.pack200.Pack200Exception;
import org.apache.commons.compress.archivers.zip.ZipIoUtil;
import org.apache.commons.compress.harmony.unpack200.bytecode.CPFloat;
import org.apache.commons.compress.utils.SkipShieldingInputStream;
import org.apache.commons.compress.archivers.zip.ZipEncoding;
import org.apache.commons.compress.archivers.examples.Archiver;
import org.apache.commons.compress.harmony.unpack200.SegmentHeader;
import org.apache.commons.compress.harmony.unpack200.FileBands;
import org.apache.commons.compress.archivers.zip.ZipUtil;
import org.apache.commons.compress.harmony.pack200.Pack200Adapter;
import org.apache.commons.compress.harmony.unpack200.bytecode.CPDouble;
import org.apache.commons.compress.archivers.sevenz.DeltaDecoder;
import org.apache.commons.compress.archivers.cpio.CpioUtil;
import static org.junit.jupiter.api.Assertions.*;
import java.util.*;
import org.junit.jupiter.api.*;
import java.util.concurrent.TimeUnit;
import static org.mockito.Mockito.when;
import static org.mockito.Mockito.*;
import static org.junit.jupiter.api.Timeout.ThreadMode.SEPARATE_THREAD;
import org.junit.jupiter.api.extension.ExtendWith;
import org.mockito.junit.jupiter.MockitoSettings;
import org.mockito.quality.Strictness;
import org.mockito.InjectMocks;
import org.mockito.*;
import org.mockito.Mockito;
import java.sql.*;
import org.mockito.MockitoAnnotations;
import org.mockito.junit.MockitoJUnitRunner;
import org.mockito.junit.jupiter.MockitoExtension;
import static org.mockito.Mockito.*;
import java.lang.reflect.Field;
import org.springframework.mock.web.MockHttpServletRequest;
import org.springframework.mock.web.MockHttpServletResponse; 
import static org.junit.jupiter.api.Assertions.*;
import java.util.*;
import org.junit.jupiter.api.*;
import java.util.concurrent.TimeUnit;
import static org.mockito.Mockito.when;
import static org.mockito.Mockito.*;
import static org.junit.jupiter.api.Timeout.ThreadMode.SEPARATE_THREAD;
import org.junit.jupiter.api.extension.ExtendWith;
import org.mockito.junit.jupiter.MockitoSettings;
import org.mockito.quality.Strictness;
import org.mockito.InjectMocks;
import org.mockito.*;
import org.mockito.Mockito;
import java.sql.*;
import org.mockito.MockitoAnnotations;
import org.mockito.junit.MockitoJUnitRunner;
import org.mockito.junit.jupiter.MockitoExtension;
import static org.mockito.Mockito.*;
import java.lang.reflect.Field;
import org.springframework.mock.web.MockHttpServletRequest;
import org.springframework.mock.web.MockHttpServletResponse;   
@ExtendWith(MockitoExtension.class)
@MockitoSettings(strictness = Strictness.LENIENT)
public class Aster_TarArchiveOutputStream_Test_Passing {
TarArchiveOutputStream tararchiveoutputstream;
TarArchiveEntry mockEntry;
String entryName;
Map<String, String> headers;
private TarArchiveOutputStream tarArchiveOutputStream;
private ByteArrayOutputStream outputStream;
private ZipEncoding zipEncoding;
private TarArchiveEntry archiveEntry;
@Test(expected = IllegalStateException.class)
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
public void testWriteWithoutOpenEntry_sEGk1() throws IOException {
    ByteArrayOutputStream baos = new ByteArrayOutputStream();
    TarArchiveOutputStream tarOutputStream = new TarArchiveOutputStream(baos);
    byte[] data = new byte[]{1, 2, 3};
    tarOutputStream.write(data, 0, 3);
}
@Test(expected = IOException.class)
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
public void testWriteExceedingSize_HwdY2() throws IOException {
    ByteArrayOutputStream baos = new ByteArrayOutputStream();
    TarArchiveOutputStream tarOutputStream = new TarArchiveOutputStream(baos);
    tarOutputStream.haveUnclosedEntry = true; // Simulate an open entry
    tarOutputStream.currSize = 5; // Set expected size
    tarOutputStream.currName = "test.txt"; // Set entry name
    byte[] data = new byte[]{1, 2, 3, 4, 5, 6}; // 6 bytes to write
    tarOutputStream.write(data, 0, 6);
}
@Test(expected = IOException.class)
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
public void testFinishWhenAlreadyFinished_kgMs1() throws IOException {
    ByteArrayOutputStream outputStream = new ByteArrayOutputStream();
    TarArchiveOutputStream tarOutputStream = new TarArchiveOutputStream(outputStream);
    tarOutputStream.finish();
    tarOutputStream.finish(); // This should throw an exception
}
@Test(expected = IOException.class)
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
public void testFinishWithUnclosedEntry_XPtG2() throws IOException {
    ByteArrayOutputStream outputStream = new ByteArrayOutputStream();
    TarArchiveOutputStream tarOutputStream = new TarArchiveOutputStream(outputStream);
    tarOutputStream.haveUnclosedEntry = true; // Simulating an unclosed entry
    tarOutputStream.finish(); // This should throw an exception
}
@Test(expected = IOException.class)
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
public void testCreateArchiveEntry_StreamFinished_ZadG1() throws IOException {
    TarArchiveOutputStream tarOutputStream = new TarArchiveOutputStream(new ByteArrayOutputStream());
    tarOutputStream.finish(); // Simulate finishing the stream
    File inputFile = new File("test.txt");
    String entryName = "testEntry";
    tarOutputStream.createArchiveEntry(inputFile, entryName);
}
@Test(expected = IOException.class)
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
public void testCreateArchiveEntry_StreamFinished_Eirl1() throws IOException {
    ByteArrayOutputStream baos = new ByteArrayOutputStream();
    TarArchiveOutputStream tarOutputStream = new TarArchiveOutputStream(baos);
    tarOutputStream.finish(); // Mark the stream as finished
    Path inputPath = Paths.get("testFile.txt");
    String entryName = "testFile.txt";
    tarOutputStream.createArchiveEntry(inputPath, entryName);
}
    private boolean addPaxHeadersForNonAsciiNames;
    private final byte[] recordBuf;
    private long currSize;
    private boolean haveUnclosedEntry;
    private long currBytes;
    private static final ZipEncoding ASCII = ZipEncodingHelper.getZipEncoding(StandardCharsets.US_ASCII);
    private int bigNumberMode = BIGNUMBER_ERROR;
    private String currName;
    private boolean finished;
}
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
public void testFinishPadsAsNeeded_BSzV2_2_fid1() throws IOException {
    OutputStream os = new ByteArrayOutputStream();
    TarArchiveOutputStream tarOutputStream = new TarArchiveOutputStream(os);
    tarOutputStream.recordsWritten = 5; // Simulating records written
    tarOutputStream.recordsPerBlock = 8; // Assuming a block size of 8 records
    tarOutputStream.finish();
    assertEquals(2, ((ByteArrayOutputStream) os).size()); // Assuming each EOF record is 1 byte}
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
public void testGetRecordSize_CoQL0() {
    OutputStream os = new ByteArrayOutputStream();
    TarArchiveOutputStream tarOutputStream = new TarArchiveOutputStream(os);
    int expectedRecordSize = 512; // Assuming the default record size is 512
    assertEquals(expectedRecordSize, tarOutputStream.getRecordSize());
}
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
public void testCreateArchiveEntry_ValidInput_smvy0_1() throws IOException {
    TarArchiveOutputStream tarOutputStream = new TarArchiveOutputStream(new ByteArrayOutputStream());
    File inputFile = new File("test.txt");
    String entryName = "testEntry";
    TarArchiveEntry entry = tarOutputStream.createArchiveEntry(inputFile, entryName);
    assertNotNull(entry);}
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
public void testCreateArchiveEntry_ValidInput_smvy0_2() throws IOException {
    TarArchiveOutputStream tarOutputStream = new TarArchiveOutputStream(new ByteArrayOutputStream());
    File inputFile = new File("test.txt");
    String entryName = "testEntry";
    TarArchiveEntry entry = tarOutputStream.createArchiveEntry(inputFile, entryName);
    assertEquals(entryName, entry.getName());}
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
public void testCreateArchiveEntry_ValidInput_smvy0_3() throws IOException {
    TarArchiveOutputStream tarOutputStream = new TarArchiveOutputStream(new ByteArrayOutputStream());
    File inputFile = new File("test.txt");
    String entryName = "testEntry";
    TarArchiveEntry entry = tarOutputStream.createArchiveEntry(inputFile, entryName);
    assertEquals(inputFile.length(), entry.getSize());}
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
public void testCloseNotFinished_lKWg0() throws IOException {
    ByteArrayOutputStream baos = new ByteArrayOutputStream();
    TarArchiveOutputStream tarOutputStream = new TarArchiveOutputStream(baos);
    tarOutputStream.close();
    assertTrue(tarOutputStream.isClosed());
}
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
public void testCloseAlreadyClosed_iDjY1() throws IOException {
    ByteArrayOutputStream baos = new ByteArrayOutputStream();
    TarArchiveOutputStream tarOutputStream = new TarArchiveOutputStream(baos);
    tarOutputStream.close();
    tarOutputStream.close(); // Calling close again
    assertTrue(tarOutputStream.isClosed());
}
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
public void testCloseWithFinished_VNhE2() throws IOException {
    ByteArrayOutputStream baos = new ByteArrayOutputStream();
    TarArchiveOutputStream tarOutputStream = new TarArchiveOutputStream(baos);
    tarOutputStream.finish(); // Mark as finished
    tarOutputStream.close();
    assertTrue(tarOutputStream.isClosed());
}
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
public void testCloseExceptionHandling_PxvW3() {
    ByteArrayOutputStream baos = new ByteArrayOutputStream() {
    };
    TarArchiveOutputStream tarOutputStream = new TarArchiveOutputStream(baos);
    try {
        tarOutputStream.close();
        fail("Expected IOException to be thrown");
    } catch (IOException e) {
        assertEquals("Test Exception", e.getMessage());
    }
}
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
public void testFinishPadsAsNeeded_BSzV2_2_fid2() throws IOException {
    OutputStream os = new ByteArrayOutputStream();
    TarArchiveOutputStream tarOutputStream = new TarArchiveOutputStream(os);
    tarOutputStream.recordsWritten = 5; // Simulating records written
    tarOutputStream.recordsPerBlock = 8; // Assuming a block size of 8 records
    tarOutputStream.finish();
    assertEquals(2, ((ByteArrayOutputStream) os).size()); // Assuming each EOF record is 1 byte}
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
public void testGetRecordSize_CoQL0() {
    OutputStream os = new ByteArrayOutputStream();
    TarArchiveOutputStream tarOutputStream = new TarArchiveOutputStream(os);
    int expectedRecordSize = 512; // Assuming the default record size is 512
    assertEquals(expectedRecordSize, tarOutputStream.getRecordSize());
}
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
public void testCreateArchiveEntry_ValidInput_smvy0_1() throws IOException {
    TarArchiveOutputStream tarOutputStream = new TarArchiveOutputStream(new ByteArrayOutputStream());
    File inputFile = new File("test.txt");
    String entryName = "testEntry";
    TarArchiveEntry entry = tarOutputStream.createArchiveEntry(inputFile, entryName);
    assertNotNull(entry);}
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
public void testCreateArchiveEntry_ValidInput_smvy0_2() throws IOException {
    TarArchiveOutputStream tarOutputStream = new TarArchiveOutputStream(new ByteArrayOutputStream());
    File inputFile = new File("test.txt");
    String entryName = "testEntry";
    TarArchiveEntry entry = tarOutputStream.createArchiveEntry(inputFile, entryName);
    assertEquals(entryName, entry.getName());}
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
public void testCreateArchiveEntry_ValidInput_smvy0_3() throws IOException {
    TarArchiveOutputStream tarOutputStream = new TarArchiveOutputStream(new ByteArrayOutputStream());
    File inputFile = new File("test.txt");
    String entryName = "testEntry";
    TarArchiveEntry entry = tarOutputStream.createArchiveEntry(inputFile, entryName);
    assertEquals(inputFile.length(), entry.getSize());}
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
public void testCloseNotFinished_lKWg0() throws IOException {
    ByteArrayOutputStream baos = new ByteArrayOutputStream();
    TarArchiveOutputStream tarOutputStream = new TarArchiveOutputStream(baos);
    tarOutputStream.close();
    assertTrue(tarOutputStream.isClosed());
}
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
public void testCloseAlreadyClosed_iDjY1() throws IOException {
    ByteArrayOutputStream baos = new ByteArrayOutputStream();
    TarArchiveOutputStream tarOutputStream = new TarArchiveOutputStream(baos);
    tarOutputStream.close();
    tarOutputStream.close(); // Calling close again
    assertTrue(tarOutputStream.isClosed());
}
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
public void testCloseWithFinished_VNhE2() throws IOException {
    ByteArrayOutputStream baos = new ByteArrayOutputStream();
    TarArchiveOutputStream tarOutputStream = new TarArchiveOutputStream(baos);
    tarOutputStream.finish(); // Mark as finished
    tarOutputStream.close();
    assertTrue(tarOutputStream.isClosed());
}
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
public void testCloseExceptionHandling_PxvW3() {
    ByteArrayOutputStream baos = new ByteArrayOutputStream() {
    };
    TarArchiveOutputStream tarOutputStream = new TarArchiveOutputStream(baos);
    try {
        tarOutputStream.close();
        fail("Expected IOException to be thrown");
    } catch (IOException e) {
        assertEquals("Test Exception", e.getMessage());
    }
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testwritePaxHeaders() throws Exception {
        ByteArrayOutputStream outputStream = new ByteArrayOutputStream();
        tararchiveoutputstream = new TarArchiveOutputStream(outputStream);
        mockEntry = Mockito.mock(TarArchiveEntry.class);
        entryName = "testEntry";
        headers = new HashMap<>();
        headers.put("key1", "value1");
        headers.put("key2", "value2");
        Mockito.when(mockEntry.getModTime()).thenReturn(new Date());
        Mockito.when(mockEntry.getName()).thenReturn(entryName);
        tararchiveoutputstream.writePaxHeaders(mockEntry, entryName, headers);
        // Assertions to verify the behavior
        Mockito.verify(mockEntry).setSize(Mockito.anyLong());
        Mockito.verify(mockEntry).setModTime(Mockito.any());
        Mockito.verify(mockEntry).setName(Mockito.anyString());
        // Additional assertions can be added based on the expected behavior
    }
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
public void testSetLongFileMode_eRiz0() {
    TarArchiveOutputStream tarOutputStream = new TarArchiveOutputStream(new ByteArrayOutputStream());
    tarOutputStream.setLongFileMode(1);
    assertEquals(1, tarOutputStream.getLongFileMode());
}
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
public void testWritePaxHeadersWithValidData_eDFm0() throws IOException {
    ByteArrayOutputStream outputStream = new ByteArrayOutputStream();
    TarArchiveOutputStream tarOutputStream = new TarArchiveOutputStream(outputStream);
    TarArchiveEntry entry = new TarArchiveEntry("testFile.txt");
    String entryName = "testFile.txt";
    Map<String, String> headers = new HashMap<>();
    headers.put("key1", "value1");
    headers.put("key2", "value2");
    tarOutputStream.writePaxHeaders(entry, entryName, headers);
    byte[] expectedData = "17 key1=value1\n17 key2=value2\n".getBytes(StandardCharsets.UTF_8);
    assertArrayEquals(expectedData, outputStream.toByteArray());
}
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
public void testWritePaxHeadersWithLongEntryName_EkYG1_1() throws IOException {
    ByteArrayOutputStream outputStream = new ByteArrayOutputStream();
    TarArchiveOutputStream tarOutputStream = new TarArchiveOutputStream(outputStream);
    TarArchiveEntry entry = new TarArchiveEntry("testFile.txt");
    String entryName = "aVeryLongEntryNameThatExceedsTheLimitOfTarConstantsNAMELEN";
    Map<String, String> headers = new HashMap<>();
    headers.put("key1", "value1");
    tarOutputStream.writePaxHeaders(entry, entryName, headers);
    String expectedName = "./PaxHeaders.X/aVeryLongEntryNameThatExceedsTheLimitOfTarConstantsNAMELEN".substring(0, TarConstants.NAMELEN - 1);
    byte[] expectedData = ("17 key1=value1\n").getBytes(StandardCharsets.UTF_8);
    assertTrue(outputStream.toString().contains(expectedName));}
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
public void testWritePaxHeadersWithLongEntryName_EkYG1_2() throws IOException {
    ByteArrayOutputStream outputStream = new ByteArrayOutputStream();
    TarArchiveOutputStream tarOutputStream = new TarArchiveOutputStream(outputStream);
    TarArchiveEntry entry = new TarArchiveEntry("testFile.txt");
    String entryName = "aVeryLongEntryNameThatExceedsTheLimitOfTarConstantsNAMELEN";
    Map<String, String> headers = new HashMap<>();
    headers.put("key1", "value1");
    tarOutputStream.writePaxHeaders(entry, entryName, headers);
    String expectedName = "./PaxHeaders.X/aVeryLongEntryNameThatExceedsTheLimitOfTarConstantsNAMELEN".substring(0, TarConstants.NAMELEN - 1);
    byte[] expectedData = ("17 key1=value1\n").getBytes(StandardCharsets.UTF_8);
    assertArrayEquals(expectedData, outputStream.toByteArray());}
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
public void testWriteWithValidParameters_UEqH0() throws IOException {
    ByteArrayOutputStream baos = new ByteArrayOutputStream();
    TarArchiveOutputStream tarOutputStream = new TarArchiveOutputStream(baos);
    tarOutputStream.haveUnclosedEntry = true; // Simulate an open entry
    tarOutputStream.currSize = 10; // Set expected size
    tarOutputStream.currName = "test.txt"; // Set entry name
    byte[] data = new byte[]{1, 2, 3, 4, 5, 6, 7, 8, 9, 10};
    tarOutputStream.write(data, 0, 10);
    assertEquals(10, tarOutputStream.currBytes);
}
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
public void testSetBigNumberMode_OCqW0() {
    TarArchiveOutputStream tarOutputStream = new TarArchiveOutputStream(new ByteArrayOutputStream());
    tarOutputStream.setBigNumberMode(1);
    assertEquals(1, tarOutputStream.getBigNumberMode());
}
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
public void testFinishAlreadyFinished_bOEQ0_1() throws IOException {
    TarArchiveOutputStream tarOutputStream = new TarArchiveOutputStream(new ByteArrayOutputStream());
    tarOutputStream.finish(); // First call to finish
    Exception exception = assertThrows(IOException.class, () -> {
        tarOutputStream.finish(); // Second call to finish should throw exception
    });}
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
public void testFinishAlreadyFinished_bOEQ0_2() throws IOException {
    TarArchiveOutputStream tarOutputStream = new TarArchiveOutputStream(new ByteArrayOutputStream());
    tarOutputStream.finish(); // First call to finish
    assertEquals("This archive has already been finished", exception.getMessage());}
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
public void testFinishWithUnclosedEntry_QAGT1_1() throws IOException {
    TarArchiveOutputStream tarOutputStream = new TarArchiveOutputStream(new ByteArrayOutputStream());
    tarOutputStream.haveUnclosedEntry = true; 
    Exception exception = assertThrows(IOException.class, () -> {
        tarOutputStream.finish(); // Should throw exception due to unclosed entry
    });}
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
public void testFinishWithUnclosedEntry_QAGT1_2() throws IOException {
    TarArchiveOutputStream tarOutputStream = new TarArchiveOutputStream(new ByteArrayOutputStream());
    tarOutputStream.haveUnclosedEntry = true; 
    assertEquals("This archive contains unclosed entries.", exception.getMessage());}
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
public void testFinishSuccessful_iMlJ2() throws IOException {
    ByteArrayOutputStream byteArrayOutputStream = new ByteArrayOutputStream();
    TarArchiveOutputStream tarOutputStream = new TarArchiveOutputStream(byteArrayOutputStream);
    tarOutputStream.finish(); // Should complete without exceptions
    assertTrue(tarOutputStream.finished); // Verify that finished is set to true
}
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
public void testFinishSuccessfully_xXnG0_1() throws IOException {
    ByteArrayOutputStream outputStream = new ByteArrayOutputStream();
    TarArchiveOutputStream tarOutputStream = new TarArchiveOutputStream(outputStream);
    tarOutputStream.finish();
    assertTrue(tarOutputStream.finished);}
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
public void testFinishSuccessfully_xXnG0_2() throws IOException {
    ByteArrayOutputStream outputStream = new ByteArrayOutputStream();
    TarArchiveOutputStream tarOutputStream = new TarArchiveOutputStream(outputStream);
    tarOutputStream.finish();
    assertEquals(2, tarOutputStream.recordsWritten);}
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
public void testFinishAlreadyFinished_yCcp0() throws IOException {
    OutputStream os = new ByteArrayOutputStream();
    TarArchiveOutputStream tarOutputStream = new TarArchiveOutputStream(os);
    tarOutputStream.finish();
    assertThrows(IOException.class, tarOutputStream::finish, "This archive has already been finished");
}
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
public void testFinishWithUnclosedEntry_NtEI1() throws IOException {
    OutputStream os = new ByteArrayOutputStream();
    TarArchiveOutputStream tarOutputStream = new TarArchiveOutputStream(os);
    tarOutputStream.haveUnclosedEntry = true; // Simulating an unclosed entry
    assertThrows(IOException.class, tarOutputStream::finish, "This archive contains unclosed entries.");
}
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
public void testFinishPadsAsNeeded_BSzV2_1() throws IOException {
    OutputStream os = new ByteArrayOutputStream();
    TarArchiveOutputStream tarOutputStream = new TarArchiveOutputStream(os);
    tarOutputStream.recordsWritten = 5; // Simulating records written
    tarOutputStream.recordsPerBlock = 8; // Assuming a block size of 8 records
    tarOutputStream.finish();
    assertTrue(tarOutputStream.finished);}
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
public void testFinishPadsAsNeeded_BSzV2_2() throws IOException {
    OutputStream os = new ByteArrayOutputStream();
    TarArchiveOutputStream tarOutputStream = new TarArchiveOutputStream(os);
    tarOutputStream.recordsWritten = 5; // Simulating records written
    tarOutputStream.recordsPerBlock = 8; // Assuming a block size of 8 records
    tarOutputStream.finish();
    assertEquals(2, ((ByteArrayOutputStream) os).size()); // Assuming each EOF record is 1 byte}
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
public void testGetRecordSize_CoQL0() {
    OutputStream os = new ByteArrayOutputStream();
    TarArchiveOutputStream tarOutputStream = new TarArchiveOutputStream(os);
    int expectedRecordSize = 512; // Assuming the default record size is 512
    assertEquals(expectedRecordSize, tarOutputStream.getRecordSize());
}
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
public void testCreateArchiveEntry_ValidInput_smvy0_1() throws IOException {
    TarArchiveOutputStream tarOutputStream = new TarArchiveOutputStream(new ByteArrayOutputStream());
    File inputFile = new File("test.txt");
    String entryName = "testEntry";
    TarArchiveEntry entry = tarOutputStream.createArchiveEntry(inputFile, entryName);
    assertNotNull(entry);}
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
public void testCreateArchiveEntry_ValidInput_smvy0_2() throws IOException {
    TarArchiveOutputStream tarOutputStream = new TarArchiveOutputStream(new ByteArrayOutputStream());
    File inputFile = new File("test.txt");
    String entryName = "testEntry";
    TarArchiveEntry entry = tarOutputStream.createArchiveEntry(inputFile, entryName);
    assertEquals(entryName, entry.getName());}
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
public void testCreateArchiveEntry_ValidInput_smvy0_3() throws IOException {
    TarArchiveOutputStream tarOutputStream = new TarArchiveOutputStream(new ByteArrayOutputStream());
    File inputFile = new File("test.txt");
    String entryName = "testEntry";
    TarArchiveEntry entry = tarOutputStream.createArchiveEntry(inputFile, entryName);
    assertEquals(inputFile.length(), entry.getSize());}
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
public void testCloseNotFinished_lKWg0() throws IOException {
    ByteArrayOutputStream baos = new ByteArrayOutputStream();
    TarArchiveOutputStream tarOutputStream = new TarArchiveOutputStream(baos);
    tarOutputStream.close();
    assertTrue(tarOutputStream.isClosed());
}
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
public void testCloseAlreadyClosed_iDjY1() throws IOException {
    ByteArrayOutputStream baos = new ByteArrayOutputStream();
    TarArchiveOutputStream tarOutputStream = new TarArchiveOutputStream(baos);
    tarOutputStream.close();
    tarOutputStream.close(); // Calling close again
    assertTrue(tarOutputStream.isClosed());
}
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
public void testCloseWithFinished_VNhE2() throws IOException {
    ByteArrayOutputStream baos = new ByteArrayOutputStream();
    TarArchiveOutputStream tarOutputStream = new TarArchiveOutputStream(baos);
    tarOutputStream.finish(); // Mark as finished
    tarOutputStream.close();
    assertTrue(tarOutputStream.isClosed());
}
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
public void testCloseExceptionHandling_PxvW3() {
    ByteArrayOutputStream baos = new ByteArrayOutputStream() {
        @Override
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
        public void close_dHkY4_0() throws IOException {
            throw new IOException("Test Exception");
        }
    };
    TarArchiveOutputStream tarOutputStream = new TarArchiveOutputStream(baos);
    try {
        tarOutputStream.close();
        fail("Expected IOException to be thrown");
    } catch (IOException e) {
        assertEquals("Test Exception", e.getMessage());
    }
}
@Override
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
        public void close_dHkY4_1() throws IOException {
            throw new IOException("Test Exception");
        }
@Override
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
        public void close_dHkY4() throws IOException {
            throw new IOException("Test Exception");
        }
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
public void testCreateArchiveEntry_ValidInput_HtSQ0_1() throws IOException {
    ByteArrayOutputStream baos = new ByteArrayOutputStream();
    TarArchiveOutputStream tarOutputStream = new TarArchiveOutputStream(baos);
    Path inputPath = Paths.get("testFile.txt");
    String entryName = "testFile.txt";
    TarArchiveEntry entry = tarOutputStream.createArchiveEntry(inputPath, entryName);
    assertNotNull(entry);}
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
public void testCreateArchiveEntry_ValidInput_HtSQ0_2() throws IOException {
    ByteArrayOutputStream baos = new ByteArrayOutputStream();
    TarArchiveOutputStream tarOutputStream = new TarArchiveOutputStream(baos);
    Path inputPath = Paths.get("testFile.txt");
    String entryName = "testFile.txt";
    TarArchiveEntry entry = tarOutputStream.createArchiveEntry(inputPath, entryName);
    assertEquals(entryName, entry.getName());}
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
public void testCreateArchiveEntry_ValidInput_HtSQ0_3() throws IOException {
    ByteArrayOutputStream baos = new ByteArrayOutputStream();
    TarArchiveOutputStream tarOutputStream = new TarArchiveOutputStream(baos);
    Path inputPath = Paths.get("testFile.txt");
    String entryName = "testFile.txt";
    TarArchiveEntry entry = tarOutputStream.createArchiveEntry(inputPath, entryName);
    assertEquals(inputPath.toString(), entry.getPath().toString());}
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
public void testCloseArchiveEntry_AlreadyFinished_UgBf0() throws IOException {
    TarArchiveOutputStream tarOutputStream = new TarArchiveOutputStream(new ByteArrayOutputStream());
    tarOutputStream.finish(); // Assuming finish sets finished to true
    assertThrows(IOException.class, () -> tarOutputStream.closeArchiveEntry());
}
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
public void testCloseArchiveEntry_NoCurrentEntry_QoHZ1() throws IOException {
    TarArchiveOutputStream tarOutputStream = new TarArchiveOutputStream(new ByteArrayOutputStream());
    assertThrows(IOException.class, () -> tarOutputStream.closeArchiveEntry());
}
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
public void testCloseArchiveEntry_EntryNotFullyWritten_NEHt2() throws IOException {
    TarArchiveOutputStream tarOutputStream = new TarArchiveOutputStream(new ByteArrayOutputStream());
    tarOutputStream.putArchiveEntry(new TarArchiveEntry("test.txt", 100)); // Assuming this method exists
    tarOutputStream.write(new byte[50]); // Write less than the specified size
    assertThrows(IOException.class, () -> tarOutputStream.closeArchiveEntry());
}
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
public void testCloseArchiveEntry_SuccessfulClose_WhpE3() throws IOException {
    ByteArrayOutputStream baos = new ByteArrayOutputStream();
    TarArchiveOutputStream tarOutputStream = new TarArchiveOutputStream(baos);
    tarOutputStream.putArchiveEntry(new TarArchiveEntry("test.txt", 100)); // Assuming this method exists
    tarOutputStream.write(new byte[100]); // Write exactly the specified size
    tarOutputStream.closeArchiveEntry();
    assertEquals(1, tarOutputStream.getRecordsWritten()); // Assuming this method exists
}
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
public void testCloseArchiveEntry_PartialRecordWritten_kMZp4() throws IOException {
    ByteArrayOutputStream baos = new ByteArrayOutputStream();
    TarArchiveOutputStream tarOutputStream = new TarArchiveOutputStream(baos);
    tarOutputStream.putArchiveEntry(new TarArchiveEntry("test.txt", 1024)); // Assuming this method exists
    tarOutputStream.write(new byte[1023]); // Write one less than the specified size
    tarOutputStream.closeArchiveEntry();
    assertEquals(2, tarOutputStream.getRecordsWritten()); // Assuming this method exists
}
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
public void testFlush_AhAk0() throws IOException {
    ByteArrayOutputStream byteArrayOutputStream = new ByteArrayOutputStream();
    TarArchiveOutputStream tarArchiveOutputStream = new TarArchiveOutputStream(byteArrayOutputStream);
    tarArchiveOutputStream.flush();
    assertEquals(0, byteArrayOutputStream.size());
}
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testPutArchiveEntry_1() throws Exception {
        outputStream = new ByteArrayOutputStream();
        zipEncoding = Mockito.mock(ZipEncoding.class);
        tarArchiveOutputStream = new TarArchiveOutputStream(outputStream, zipEncoding);
        archiveEntry = Mockito.mock(TarArchiveEntry.class);
        Mockito.when(archiveEntry.isGlobalPaxHeader()).thenReturn(false);
        Mockito.when(archiveEntry.getName()).thenReturn("testFile.txt");
        Mockito.when(archiveEntry.getSize()).thenReturn(10L);
        Mockito.when(archiveEntry.getExtraPaxHeaders()).thenReturn(new HashMap<>());
        tarArchiveOutputStream.putArchiveEntry(archiveEntry);
        Mockito.verify(archiveEntry).writeEntryHeader(Mockito.any(byte[].class), Mockito.eq(zipEncoding), Mockito.anyBoolean());
        Mockito.verify(tarArchiveOutputStream).writeRecord(Mockito.any(byte[].class));
        Mockito.verify(archiveEntry).setSize(10L);
        assertTrue(haveUnclosedEntry);}
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testPutArchiveEntry_2() throws Exception {
        outputStream = new ByteArrayOutputStream();
        zipEncoding = Mockito.mock(ZipEncoding.class);
        tarArchiveOutputStream = new TarArchiveOutputStream(outputStream, zipEncoding);
        archiveEntry = Mockito.mock(TarArchiveEntry.class);
        Mockito.when(archiveEntry.isGlobalPaxHeader()).thenReturn(false);
        Mockito.when(archiveEntry.getName()).thenReturn("testFile.txt");
        Mockito.when(archiveEntry.getSize()).thenReturn(10L);
        Mockito.when(archiveEntry.getExtraPaxHeaders()).thenReturn(new HashMap<>());
        tarArchiveOutputStream.putArchiveEntry(archiveEntry);
        Mockito.verify(archiveEntry).writeEntryHeader(Mockito.any(byte[].class), Mockito.eq(zipEncoding), Mockito.anyBoolean());
        Mockito.verify(tarArchiveOutputStream).writeRecord(Mockito.any(byte[].class));
        Mockito.verify(archiveEntry).setSize(10L);
        assertEquals(currName);}
@Override
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
        public void close_dHkY4_0() throws IOException {
            throw new IOException("Test Exception");
        }
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
public void testPutArchiveEntryWithGlobalPaxHeader_opzg0() throws IOException {
    ByteArrayOutputStream baos = new ByteArrayOutputStream();
    TarArchiveOutputStream tarOutputStream = new TarArchiveOutputStream(baos);
    TarArchiveEntry entry = new TarArchiveEntry("test.txt");
    entry.setGlobalPaxHeader(true);
    entry.addPaxHeader("key", "value");
    tarOutputStream.putArchiveEntry(entry);
    assertTrue(baos.toByteArray().length > 0);
}
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
public void testPutArchiveEntryWithLongName_lLNB1() throws IOException {
    ByteArrayOutputStream baos = new ByteArrayOutputStream();
    TarArchiveOutputStream tarOutputStream = new TarArchiveOutputStream(baos);
    TarArchiveEntry entry = new TarArchiveEntry("this_is_a_very_long_file_name_that_exceeds_the_standard_length.txt");
    tarOutputStream.putArchiveEntry(entry);
    assertTrue(baos.toByteArray().length > 0);
}
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
public void testPutArchiveEntryWithLinkName_YFgS2() throws IOException {
    ByteArrayOutputStream baos = new ByteArrayOutputStream();
    TarArchiveOutputStream tarOutputStream = new TarArchiveOutputStream(baos);
    TarArchiveEntry entry = new TarArchiveEntry("link.txt", TarConstants.LF_SYMLINK);
    entry.setLinkName("target.txt");
    tarOutputStream.putArchiveEntry(entry);
    assertTrue(baos.toByteArray().length > 0);
}
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
public void testPutArchiveEntryWithNonAsciiName_yrek3() throws IOException {
    ByteArrayOutputStream baos = new ByteArrayOutputStream();
    TarArchiveOutputStream tarOutputStream = new TarArchiveOutputStream(baos);
    TarArchiveEntry entry = new TarArchiveEntry(".txt");
    tarOutputStream.putArchiveEntry(entry);
    assertTrue(baos.toByteArray().length > 0);
}
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
public void testPutArchiveEntryWithDirectory_fetT4() throws IOException {
    ByteArrayOutputStream baos = new ByteArrayOutputStream();
    TarArchiveOutputStream tarOutputStream = new TarArchiveOutputStream(baos);
    TarArchiveEntry entry = new TarArchiveEntry("directory/");
    entry.setSize(0);
    tarOutputStream.putArchiveEntry(entry);
    assertTrue(baos.toByteArray().length > 0);
}
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
public void testPutArchiveEntryWithEmptyPaxHeaders_rpxI5() throws IOException {
    ByteArrayOutputStream baos = new ByteArrayOutputStream();
    TarArchiveOutputStream tarOutputStream = new TarArchiveOutputStream(baos);
    TarArchiveEntry entry = new TarArchiveEntry("test.txt");
    tarOutputStream.putArchiveEntry(entry);
    assertTrue(baos.toByteArray().length > 0);
}
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
public void testPutArchiveEntryWithBigNumberMode_fwXK6() throws IOException {
    ByteArrayOutputStream baos = new ByteArrayOutputStream();
    TarArchiveOutputStream tarOutputStream = new TarArchiveOutputStream(baos);
    tarOutputStream.setBigNumberMode(TarArchiveOutputStream.BIGNUMBER_POSIX);
    TarArchiveEntry entry = new TarArchiveEntry("bigfile.txt");
    entry.setSize(Long.MAX_VALUE);
    tarOutputStream.putArchiveEntry(entry);
    assertTrue(baos.toByteArray().length > 0);
}
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
public void testPutArchiveEntryWithInvalidLongName_mFoy7() {
    ByteArrayOutputStream baos = new ByteArrayOutputStream();
    TarArchiveOutputStream tarOutputStream = new TarArchiveOutputStream(baos);
    TarArchiveEntry entry = new TarArchiveEntry("this_is_a_very_long_file_name_that_exceeds_the_standard_length.txt");
    entry.setSize(Long.MAX_VALUE);
    assertThrows(IllegalArgumentException.class, () -> tarOutputStream.putArchiveEntry(entry));
}
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
public void testPutArchiveEntryWithLinkAndLongName_JgKN8() throws IOException {
    ByteArrayOutputStream baos = new ByteArrayOutputStream();
    TarArchiveOutputStream tarOutputStream = new TarArchiveOutputStream(baos);
    TarArchiveEntry entry = new TarArchiveEntry("link.txt", TarConstants.LF_SYMLINK);
    entry.setLinkName("this_is_a_very_long_link_name_that_exceeds_the_standard_length.txt");
    tarOutputStream.putArchiveEntry(entry);
    assertTrue(baos.toByteArray().length > 0);
}
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
public void testPutArchiveEntryWithSparseFile_sBPm9() throws IOException {
    ByteArrayOutputStream baos = new ByteArrayOutputStream();
    TarArchiveOutputStream tarOutputStream = new TarArchiveOutputStream(baos);
    TarArchiveEntry entry = new TarArchiveEntry("sparsefile.txt");
    entry.setSparse(true);
    tarOutputStream.putArchiveEntry(entry);
    assertTrue(baos.toByteArray().length > 0);
}
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
public void testPutArchiveEntryWithFileSizeZero_Nxji10() throws IOException {
    ByteArrayOutputStream baos = new ByteArrayOutputStream();
    TarArchiveOutputStream tarOutputStream = new TarArchiveOutputStream(baos);
    TarArchiveEntry entry = new TarArchiveEntry("emptyfile.txt");
    entry.setSize(0);
    tarOutputStream.putArchiveEntry(entry);
    assertTrue(baos.toByteArray().length > 0);
}
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
public void testPutArchiveEntryWithMultiplePaxHeaders_pgfc11() throws IOException {
    ByteArrayOutputStream baos = new ByteArrayOutputStream();
    TarArchiveOutputStream tarOutputStream = new TarArchiveOutputStream(baos);
    TarArchiveEntry entry = new TarArchiveEntry("test.txt");
    entry.addPaxHeader("key1", "value1");
    entry.addPaxHeader("key2", "value2");
    tarOutputStream.putArchiveEntry(entry);
    assertTrue(baos.toByteArray().length > 0);
}
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
public void testPutArchiveEntryWithUserDefinedPaxHeaders_SbOy12() throws IOException {
    ByteArrayOutputStream baos = new ByteArrayOutputStream();
    TarArchiveOutputStream tarOutputStream = new TarArchiveOutputStream(baos);
    TarArchiveEntry entry = new TarArchiveEntry("test.txt");
    entry.addPaxHeader("user", "testuser");
    tarOutputStream.putArchiveEntry(entry);
    assertTrue(baos.toByteArray().length > 0);
}
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
public void testPutArchiveEntryWithGroupDefinedPaxHeaders_fXJF13() throws IOException {
    ByteArrayOutputStream baos = new ByteArrayOutputStream();
    TarArchiveOutputStream tarOutputStream = new TarArchiveOutputStream(baos);
    TarArchiveEntry entry = new TarArchiveEntry("test.txt");
    entry.addPaxHeader("group", "testgroup");
    tarOutputStream.putArchiveEntry(entry);
    assertTrue(baos.toByteArray().length > 0);
}
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
public void testPutArchiveEntryWithEmptyLinkName_UuIx14() throws IOException {
    ByteArrayOutputStream baos = new ByteArrayOutputStream();
    TarArchiveOutputStream tarOutputStream = new TarArchiveOutputStream(baos);
    TarArchiveEntry entry = new TarArchiveEntry("link.txt", TarConstants.LF_SYMLINK);
    entry.setLinkName("");
    tarOutputStream.putArchiveEntry(entry);
    assertTrue(baos.toByteArray().length > 0);
}
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
public void testPutArchiveEntryWithDirectoryEntry_jLgw16() throws IOException {
    ByteArrayOutputStream baos = new ByteArrayOutputStream();
    TarArchiveOutputStream tarOutputStream = new TarArchiveOutputStream(baos);
    TarArchiveEntry entry = new TarArchiveEntry("directory/");
    tarOutputStream.putArchiveEntry(entry);
    assertTrue(baos.toByteArray().length > 0);
}
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
public void testPutArchiveEntryWithFileEntry_nsAF17() throws IOException {
    ByteArrayOutputStream baos = new ByteArrayOutputStream();
    TarArchiveOutputStream tarOutputStream = new TarArchiveOutputStream(baos);
    TarArchiveEntry entry = new TarArchiveEntry("file.txt");
    entry.setSize(100);
    tarOutputStream.putArchiveEntry(entry);
    assertTrue(baos.toByteArray().length > 0);
}
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
public void testPutArchiveEntry_GlobalPaxHeader_Mcwa0() throws IOException {
    TarArchiveOutputStream outputStream = new TarArchiveOutputStream(new ByteArrayOutputStream());
    TarArchiveEntry entry = new TarArchiveEntry("test.txt");
    entry.setGlobalPaxHeader(true);
    outputStream.putArchiveEntry(entry);
    assertTrue(outputStream.haveUnclosedEntry);
}
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
public void testPutArchiveEntry_NonGlobalPaxHeader_XrxA1() throws IOException {
    TarArchiveOutputStream outputStream = new TarArchiveOutputStream(new ByteArrayOutputStream());
    TarArchiveEntry entry = new TarArchiveEntry("test.txt");
    outputStream.putArchiveEntry(entry);
    assertEquals("test.txt", outputStream.currName);
}
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
public void testPutArchiveEntry_WithLongName_aCyX2() throws IOException {
    TarArchiveOutputStream outputStream = new TarArchiveOutputStream(new ByteArrayOutputStream());
    TarArchiveEntry entry = new TarArchiveEntry("a_very_long_file_name_that_exceeds_the_normal_length.txt");
    outputStream.putArchiveEntry(entry);
    assertTrue(outputStream.haveUnclosedEntry);
}
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
public void testPutArchiveEntry_WithLink_rAjV3() throws IOException {
    TarArchiveOutputStream outputStream = new TarArchiveOutputStream(new ByteArrayOutputStream());
    TarArchiveEntry entry = new TarArchiveEntry("test_link.txt", (byte) 1);
    entry.setLinkName("link_to_test.txt");
    outputStream.putArchiveEntry(entry);
    assertTrue(outputStream.haveUnclosedEntry);
}
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
public void testPutArchiveEntry_WithBigNumbers_lkyB4() throws IOException {
    TarArchiveOutputStream outputStream = new TarArchiveOutputStream(new ByteArrayOutputStream());
    TarArchiveEntry entry = new TarArchiveEntry("big_numbers.txt");
    entry.setSize(Long.MAX_VALUE);
    entry.setLongUserId(Long.MAX_VALUE);
    entry.setLongGroupId(Long.MAX_VALUE);
    outputStream.putArchiveEntry(entry);
    assertTrue(outputStream.haveUnclosedEntry);
}
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
public void testPutArchiveEntry_WithNonAsciiName_ebnT5() throws IOException {
    TarArchiveOutputStream outputStream = new TarArchiveOutputStream(new ByteArrayOutputStream());
    TarArchiveEntry entry = new TarArchiveEntry(".txt");
    outputStream.putArchiveEntry(entry);
    assertTrue(outputStream.haveUnclosedEntry);
}
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
public void testPutArchiveEntry_WithDirectory_gWLK6() throws IOException {
    TarArchiveOutputStream outputStream = new TarArchiveOutputStream(new ByteArrayOutputStream());
    TarArchiveEntry entry = new TarArchiveEntry("test_directory/");
    entry.setSize(0);
    outputStream.putArchiveEntry(entry);
    assertEquals(0, outputStream.currSize);
}
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
public void testPutArchiveEntry_WithSymbolicLink_YLUz7() throws IOException {
    TarArchiveOutputStream outputStream = new TarArchiveOutputStream(new ByteArrayOutputStream());
    TarArchiveEntry entry = new TarArchiveEntry("symbolic_link.txt", (byte) 2);
    entry.setLinkName("link_to_symbolic.txt");
    outputStream.putArchiveEntry(entry);
    assertTrue(outputStream.haveUnclosedEntry);
}
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
public void testPutArchiveEntry_WithSparseFile_PNpA8() throws IOException {
    TarArchiveOutputStream outputStream = new TarArchiveOutputStream(new ByteArrayOutputStream());
    TarArchiveEntry entry = new TarArchiveEntry("sparse_file.txt");
    entry.setSparseHeaders(new ArrayList<>());
    outputStream.putArchiveEntry(entry);
    assertTrue(outputStream.haveUnclosedEntry);
}
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
public void testPutArchiveEntry_WithCreationTime_Zjbd9() throws IOException {
    TarArchiveOutputStream outputStream = new TarArchiveOutputStream(new ByteArrayOutputStream());
    TarArchiveEntry entry = new TarArchiveEntry("creation_time.txt");
    entry.setCreationTime(FileTime.fromMillis(System.currentTimeMillis()));
    outputStream.putArchiveEntry(entry);
    assertNotNull(entry.getCreationTime());
}
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
public void testPutArchiveEntry_WithLastModifiedTime_hCej10() throws IOException {
    TarArchiveOutputStream outputStream = new TarArchiveOutputStream(new ByteArrayOutputStream());
    TarArchiveEntry entry = new TarArchiveEntry("last_modified_time.txt");
    entry.setLastModifiedTime(FileTime.fromMillis(System.currentTimeMillis()));
    outputStream.putArchiveEntry(entry);
    assertNotNull(entry.getLastModifiedTime());
}
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
public void testPutArchiveEntry_WithUserIdAndGroupId_aMKA11_1() throws IOException {
    TarArchiveOutputStream outputStream = new TarArchiveOutputStream(new ByteArrayOutputStream());
    TarArchiveEntry entry = new TarArchiveEntry("user_group.txt");
    entry.setUserId(1000);
    entry.setGroupId(1000);
    outputStream.putArchiveEntry(entry);
    assertEquals(1000, entry.getUserId());}
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
public void testPutArchiveEntry_WithUserIdAndGroupId_aMKA11_2() throws IOException {
    TarArchiveOutputStream outputStream = new TarArchiveOutputStream(new ByteArrayOutputStream());
    TarArchiveEntry entry = new TarArchiveEntry("user_group.txt");
    entry.setUserId(1000);
    entry.setGroupId(1000);
    outputStream.putArchiveEntry(entry);
    assertEquals(1000, entry.getGroupId());}
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
public void testPutArchiveEntry_WithMode_xemW12() throws IOException {
    TarArchiveOutputStream outputStream = new TarArchiveOutputStream(new ByteArrayOutputStream());
    TarArchiveEntry entry = new TarArchiveEntry("mode_file.txt");
    entry.setMode(0755);
    outputStream.putArchiveEntry(entry);
    assertEquals(0755, entry.getMode());
}
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
public void testPutArchiveEntry_WithFIFO_IPPI13() throws IOException {
    TarArchiveOutputStream outputStream = new TarArchiveOutputStream(new ByteArrayOutputStream());
    TarArchiveEntry entry = new TarArchiveEntry("fifo_file.txt", (byte) 6);
    outputStream.putArchiveEntry(entry);
    assertTrue(entry.isFIFO());
}
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
public void testPutArchiveEntry_WithCharacterDevice_LVfD14() throws IOException {
    TarArchiveOutputStream outputStream = new TarArchiveOutputStream(new ByteArrayOutputStream());
    TarArchiveEntry entry = new TarArchiveEntry("char_device.txt", (byte) 2);
    outputStream.putArchiveEntry(entry);
    assertTrue(entry.isCharacterDevice());
}
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
public void testPutArchiveEntry_WithBlockDevice_DcYD15() throws IOException {
    TarArchiveOutputStream outputStream = new TarArchiveOutputStream(new ByteArrayOutputStream());
    TarArchiveEntry entry = new TarArchiveEntry("block_device.txt", (byte) 3);
    outputStream.putArchiveEntry(entry);
    assertTrue(entry.isBlockDevice());
}
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
public void testPutArchiveEntry_WithExtendedPaxHeaders_dLEM16() throws IOException {
    TarArchiveOutputStream outputStream = new TarArchiveOutputStream(new ByteArrayOutputStream());
    TarArchiveEntry entry = new TarArchiveEntry("extended_pax.txt");
    entry.addPaxHeader("customHeader", "customValue");
    outputStream.putArchiveEntry(entry);
    assertEquals("customValue", entry.getExtraPaxHeader("customHeader"));
}
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
public void testPutArchiveEntry_WithStarSparse_wlds17() throws IOException {
    TarArchiveOutputStream outputStream = new TarArchiveOutputStream(new ByteArrayOutputStream());
    TarArchiveEntry entry = new TarArchiveEntry("star_sparse.txt");
    entry.setSparseHeaders(new ArrayList<>());
    outputStream.putArchiveEntry(entry);
    assertTrue(entry.isStarSparse());
}
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
public void testPutArchiveEntry_WithGNULongName_Kozz18() throws IOException {
    TarArchiveOutputStream outputStream = new TarArchiveOutputStream(new ByteArrayOutputStream());
    TarArchiveEntry entry = new TarArchiveEntry("gnu_long_name.txt");
    entry.setGNULongNameEntry(true);
    outputStream.putArchiveEntry(entry);
    assertTrue(entry.isGNULongNameEntry());
}
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
public void testPutArchiveEntry_WithGNULongLink_PFdt19() throws IOException {
    TarArchiveOutputStream outputStream = new TarArchiveOutputStream(new ByteArrayOutputStream());
    TarArchiveEntry entry = new TarArchiveEntry("gnu_long_link.txt");
    entry.setGNULongLinkEntry(true);
    outputStream.putArchiveEntry(entry);
    assertTrue(entry.isGNULongLinkEntry());
}
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
public void testPutArchiveEntry_GlobalPaxHeader_RCqQ0() throws IOException {
    ByteArrayOutputStream baos = new ByteArrayOutputStream();
    TarArchiveOutputStream tarOutputStream = new TarArchiveOutputStream(baos);
    TarArchiveEntry entry = new TarArchiveEntry("test.txt");
    entry.addPaxHeader("key", "value");
    tarOutputStream.putArchiveEntry(entry);
    assertTrue(baos.size() > 0);
}
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
public void testPutArchiveEntry_LongName_UANs1() throws IOException {
    ByteArrayOutputStream baos = new ByteArrayOutputStream();
    TarArchiveOutputStream tarOutputStream = new TarArchiveOutputStream(baos);
    TarArchiveEntry entry = new TarArchiveEntry("a_very_long_filename_that_exceeds_the_limit.txt");
    tarOutputStream.putArchiveEntry(entry);
    assertTrue(baos.size() > 0);
}
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
public void testPutArchiveEntry_SymbolicLink_hFnc2() throws IOException {
    ByteArrayOutputStream baos = new ByteArrayOutputStream();
    TarArchiveOutputStream tarOutputStream = new TarArchiveOutputStream(baos);
    TarArchiveEntry entry = new TarArchiveEntry("link.txt", TarConstants.LF_SYMLINK);
    entry.setLinkName("target.txt");
    tarOutputStream.putArchiveEntry(entry);
    assertTrue(baos.size() > 0);
}
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
public void testPutArchiveEntry_Directory_oiPo3() throws IOException {
    ByteArrayOutputStream baos = new ByteArrayOutputStream();
    TarArchiveOutputStream tarOutputStream = new TarArchiveOutputStream(baos);
    TarArchiveEntry entry = new TarArchiveEntry("directory/");
    tarOutputStream.putArchiveEntry(entry);
    assertTrue(baos.size() > 0);
}
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
public void testPutArchiveEntry_NonAsciiName_jXbb4() throws IOException {
    ByteArrayOutputStream baos = new ByteArrayOutputStream();
    TarArchiveOutputStream tarOutputStream = new TarArchiveOutputStream(baos);
    TarArchiveEntry entry = new TarArchiveEntry(".txt");
    tarOutputStream.putArchiveEntry(entry);
    assertTrue(baos.size() > 0);
}
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
public void testPutArchiveEntry_EmptyEntry_hgca5() throws IOException {
    ByteArrayOutputStream baos = new ByteArrayOutputStream();
    TarArchiveOutputStream tarOutputStream = new TarArchiveOutputStream(baos);
    TarArchiveEntry entry = new TarArchiveEntry("empty.txt");
    entry.setSize(0);
    tarOutputStream.putArchiveEntry(entry);
    assertTrue(baos.size() > 0);
}
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
public void testPutArchiveEntry_WithPaxHeaders_FRBf6() throws IOException {
    ByteArrayOutputStream baos = new ByteArrayOutputStream();
    TarArchiveOutputStream tarOutputStream = new TarArchiveOutputStream(baos);
    TarArchiveEntry entry = new TarArchiveEntry("test.txt");
    entry.addPaxHeader("user", "testUser");
    tarOutputStream.putArchiveEntry(entry);
    assertTrue(baos.size() > 0);
}
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
public void testPutArchiveEntry_BigNumberMode_JpIE7() throws IOException {
    ByteArrayOutputStream baos = new ByteArrayOutputStream();
    TarArchiveOutputStream tarOutputStream = new TarArchiveOutputStream(baos);
    TarArchiveEntry entry = new TarArchiveEntry("bigNumber.txt");
    entry.setSize(Long.MAX_VALUE);
    tarOutputStream.putArchiveEntry(entry);
    assertTrue(baos.size() > 0);
}
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
public void testPutArchiveEntry_SparseFile_ZsLJ8() throws IOException {
    ByteArrayOutputStream baos = new ByteArrayOutputStream();
    TarArchiveOutputStream tarOutputStream = new TarArchiveOutputStream(baos);
    TarArchiveEntry entry = new TarArchiveEntry("sparseFile.txt");
    entry.setSparseHeaders(new ArrayList<>());
    tarOutputStream.putArchiveEntry(entry);
    assertTrue(baos.size() > 0);
}
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
public void testPutArchiveEntry_RegularFile_ihOP9() throws IOException {
    ByteArrayOutputStream baos = new ByteArrayOutputStream();
    TarArchiveOutputStream tarOutputStream = new TarArchiveOutputStream(baos);
    TarArchiveEntry entry = new TarArchiveEntry("regularFile.txt");
    entry.setSize(1024);
    tarOutputStream.putArchiveEntry(entry);
    assertTrue(baos.size() > 0);
}
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
public void testPutArchiveEntry_CharacterDevice_jaaN10() throws IOException {
    ByteArrayOutputStream baos = new ByteArrayOutputStream();
    TarArchiveOutputStream tarOutputStream = new TarArchiveOutputStream(baos);
    TarArchiveEntry entry = new TarArchiveEntry("charDevice", TarConstants.LF_CHR);
    entry.setDevMajor(1);
    entry.setDevMinor(2);
    tarOutputStream.putArchiveEntry(entry);
    assertTrue(baos.size() > 0);
}
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
public void testPutArchiveEntry_BlockDevice_lRqA11() throws IOException {
    ByteArrayOutputStream baos = new ByteArrayOutputStream();
    TarArchiveOutputStream tarOutputStream = new TarArchiveOutputStream(baos);
    TarArchiveEntry entry = new TarArchiveEntry("blockDevice", TarConstants.LF_BLK);
    entry.setDevMajor(1);
    entry.setDevMinor(2);
    tarOutputStream.putArchiveEntry(entry);
    assertTrue(baos.size() > 0);
}
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
public void testPutArchiveEntry_Fifo_QRYe12() throws IOException {
    ByteArrayOutputStream baos = new ByteArrayOutputStream();
    TarArchiveOutputStream tarOutputStream = new TarArchiveOutputStream(baos);
    TarArchiveEntry entry = new TarArchiveEntry("fifo", TarConstants.LF_FIFO);
    tarOutputStream.putArchiveEntry(entry);
    assertTrue(baos.size() > 0);
}
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
public void testPutArchiveEntry_GNULongLink_HsIA13() throws IOException {
    ByteArrayOutputStream baos = new ByteArrayOutputStream();
    TarArchiveOutputStream tarOutputStream = new TarArchiveOutputStream(baos);
    TarArchiveEntry entry = new TarArchiveEntry("a_very_long_filename_that_exceeds_the_limit.txt");
    entry.setLinkName("longLink");
    tarOutputStream.putArchiveEntry(entry);
    assertTrue(baos.size() > 0);
}
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
public void testPutArchiveEntry_StarSparse_rsng14() throws IOException {
    ByteArrayOutputStream baos = new ByteArrayOutputStream();
    TarArchiveOutputStream tarOutputStream = new TarArchiveOutputStream(baos);
    TarArchiveEntry entry = new TarArchiveEntry("starSparseFile.txt");
    entry.setSparseHeaders(new ArrayList<>());
    tarOutputStream.putArchiveEntry(entry);
    assertTrue(baos.size() > 0);
}
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
public void testPutArchiveEntry_EmptyPaxHeaders_fVvL15() throws IOException {
    ByteArrayOutputStream baos = new ByteArrayOutputStream();
    TarArchiveOutputStream tarOutputStream = new TarArchiveOutputStream(baos);
    TarArchiveEntry entry = new TarArchiveEntry("test.txt");
    tarOutputStream.putArchiveEntry(entry);
    assertTrue(baos.size() > 0);
}
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
public void testPutArchiveEntry_ValidLinkEntry_BhQV16() throws IOException {
    ByteArrayOutputStream baos = new ByteArrayOutputStream();
    TarArchiveOutputStream tarOutputStream = new TarArchiveOutputStream(baos);
    TarArchiveEntry entry = new TarArchiveEntry("linkEntry", TarConstants.LF_LINK);
    entry.setLinkName("targetEntry");
    tarOutputStream.putArchiveEntry(entry);
    assertTrue(baos.size() > 0);
}
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
public void testPutArchiveEntry_ValidFileEntry_mXxv17() throws IOException {
    ByteArrayOutputStream baos = new ByteArrayOutputStream();
    TarArchiveOutputStream tarOutputStream = new TarArchiveOutputStream(baos);
    TarArchiveEntry entry = new TarArchiveEntry("validFile.txt");
    entry.setSize(512);
    tarOutputStream.putArchiveEntry(entry);
    assertTrue(baos.size() > 0);
}
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
public void testPutArchiveEntry_ValidDirectoryEntry_rSzo18() throws IOException {
    ByteArrayOutputStream baos = new ByteArrayOutputStream();
    TarArchiveOutputStream tarOutputStream = new TarArchiveOutputStream(baos);
    TarArchiveEntry entry = new TarArchiveEntry("validDirectory/");
    tarOutputStream.putArchiveEntry(entry);
    assertTrue(baos.size() > 0);
}
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testPutArchiveEntryWithGlobalPaxHeader_grZH0() throws IOException {
        ByteArrayOutputStream baos = new ByteArrayOutputStream();
        TarArchiveOutputStream tarOutputStream = new TarArchiveOutputStream(baos);
        TarArchiveEntry entry = new TarArchiveEntry(Paths.get("test.txt"), "test.txt");
        entry.setGlobalPaxHeader(true);
        entry.setSize(100);
        tarOutputStream.putArchiveEntry(entry);
        assertEquals(100, entry.getSize());
    }
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testPutArchiveEntryWithLongName_uGoP1() throws IOException {
        ByteArrayOutputStream baos = new ByteArrayOutputStream();
        TarArchiveOutputStream tarOutputStream = new TarArchiveOutputStream(baos);
        TarArchiveEntry entry = new TarArchiveEntry("very_long_file_name_that_exceeds_limit.txt");
        entry.setSize(200);
        tarOutputStream.putArchiveEntry(entry);
        assertEquals("very_long_file_name_that_exceeds_limit.txt", entry.getName());
    }
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testPutArchiveEntryWithLink_ianH2() throws IOException {
        ByteArrayOutputStream baos = new ByteArrayOutputStream();
        TarArchiveOutputStream tarOutputStream = new TarArchiveOutputStream(baos);
        TarArchiveEntry entry = new TarArchiveEntry("link.txt", (byte) 1);
        entry.setLinkName("target.txt");
        tarOutputStream.putArchiveEntry(entry);
        assertEquals("target.txt", entry.getLinkName());
    }
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testPutArchiveEntryWithNonAsciiName_eEtN3() throws IOException {
        ByteArrayOutputStream baos = new ByteArrayOutputStream();
        TarArchiveOutputStream tarOutputStream = new TarArchiveOutputStream(baos);
        TarArchiveEntry entry = new TarArchiveEntry(".txt");
        entry.setSize(150);
        tarOutputStream.putArchiveEntry(entry);
        assertTrue(entry.getName().contains(""));
    }
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testPutArchiveEntryWithDirectory_IKOv4() throws IOException {
        ByteArrayOutputStream baos = new ByteArrayOutputStream();
        TarArchiveOutputStream tarOutputStream = new TarArchiveOutputStream(baos);
        TarArchiveEntry entry = new TarArchiveEntry("directory/");
        entry.setSize(0);
        tarOutputStream.putArchiveEntry(entry);
        assertTrue(entry.isDirectory());
    }
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testPutArchiveEntryWithSparse_oOtA5() throws IOException {
        ByteArrayOutputStream baos = new ByteArrayOutputStream();
        TarArchiveOutputStream tarOutputStream = new TarArchiveOutputStream(baos);
        TarArchiveEntry entry = new TarArchiveEntry("sparse_file.txt");
        entry.setSparse(true);
        tarOutputStream.putArchiveEntry(entry);
        assertTrue(entry.isSparse());
    }
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testPutArchiveEntryWithBigNumbers_NYXC6_1() throws IOException {
        ByteArrayOutputStream baos = new ByteArrayOutputStream();
        TarArchiveOutputStream tarOutputStream = new TarArchiveOutputStream(baos);
        TarArchiveEntry entry = new TarArchiveEntry("big_numbers.txt");
        entry.setSize(Long.MAX_VALUE);
        entry.setLongUserId(Long.MAX_VALUE);
        entry.setLongGroupId(Long.MAX_VALUE);
        tarOutputStream.putArchiveEntry(entry);
        assertEquals(Long.MAX_VALUE, entry.getLongUserId());}
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testPutArchiveEntryWithBigNumbers_NYXC6_2() throws IOException {
        ByteArrayOutputStream baos = new ByteArrayOutputStream();
        TarArchiveOutputStream tarOutputStream = new TarArchiveOutputStream(baos);
        TarArchiveEntry entry = new TarArchiveEntry("big_numbers.txt");
        entry.setSize(Long.MAX_VALUE);
        entry.setLongUserId(Long.MAX_VALUE);
        entry.setLongGroupId(Long.MAX_VALUE);
        tarOutputStream.putArchiveEntry(entry);
        assertEquals(Long.MAX_VALUE, entry.getLongGroupId());}
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testPutArchiveEntryWithFileTime_pEGl7() throws IOException {
        ByteArrayOutputStream baos = new ByteArrayOutputStream();
        TarArchiveOutputStream tarOutputStream = new TarArchiveOutputStream(baos);
        TarArchiveEntry entry = new TarArchiveEntry("file_time.txt");
        entry.setCreationTime(FileTime.fromMillis(System.currentTimeMillis()));
        tarOutputStream.putArchiveEntry(entry);
        assertNotNull(entry.getCreationTime());
    }
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testPutArchiveEntryWithEmptyPaxHeaders_Dlgw8() throws IOException {
        ByteArrayOutputStream baos = new ByteArrayOutputStream();
        TarArchiveOutputStream tarOutputStream = new TarArchiveOutputStream(baos);
        TarArchiveEntry entry = new TarArchiveEntry("empty_pax.txt");
        entry.clearExtraPaxHeaders();
        tarOutputStream.putArchiveEntry(entry);
        assertTrue(entry.getExtraPaxHeaders().isEmpty());
    }
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testPutArchiveEntryWithInvalidState_QXSZ9() {
        ByteArrayOutputStream baos = new ByteArrayOutputStream();
        TarArchiveOutputStream tarOutputStream = new TarArchiveOutputStream(baos);
        tarOutputStream.finish();
        TarArchiveEntry entry = new TarArchiveEntry("invalid_state.txt");
        assertThrows(IOException.class, () -> tarOutputStream.putArchiveEntry(entry));
    }
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testPutArchiveEntryWithFIFO_jQYn10() throws IOException {
        ByteArrayOutputStream baos = new ByteArrayOutputStream();
        TarArchiveOutputStream tarOutputStream = new TarArchiveOutputStream(baos);
        TarArchiveEntry entry = new TarArchiveEntry("fifo_file", (byte) 2);
        tarOutputStream.putArchiveEntry(entry);
        assertTrue(entry.isFIFO());
    }
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testPutArchiveEntryWithCharacterDevice_JHsV11() throws IOException {
        ByteArrayOutputStream baos = new ByteArrayOutputStream();
        TarArchiveOutputStream tarOutputStream = new TarArchiveOutputStream(baos);
        TarArchiveEntry entry = new TarArchiveEntry("char_device", (byte) 3);
        tarOutputStream.putArchiveEntry(entry);
        assertTrue(entry.isCharacterDevice());
    }
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testPutArchiveEntryWithBlockDevice_aRkj12() throws IOException {
        ByteArrayOutputStream baos = new ByteArrayOutputStream();
        TarArchiveOutputStream tarOutputStream = new TarArchiveOutputStream(baos);
        TarArchiveEntry entry = new TarArchiveEntry("block_device", (byte) 4);
        tarOutputStream.putArchiveEntry(entry);
        assertTrue(entry.isBlockDevice());
    }
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testPutArchiveEntryWithSymbolicLink_YECG13() throws IOException {
        ByteArrayOutputStream baos = new ByteArrayOutputStream();
        TarArchiveOutputStream tarOutputStream = new TarArchiveOutputStream(baos);
        TarArchiveEntry entry = new TarArchiveEntry("symlink", (byte) 5);
        entry.setLinkName("target_symlink.txt");
        tarOutputStream.putArchiveEntry(entry);
        assertTrue(entry.isSymbolicLink());
    }
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testPutArchiveEntryWithExtendedAttributes_Ecgq14() throws IOException {
        ByteArrayOutputStream baos = new ByteArrayOutputStream();
        TarArchiveOutputStream tarOutputStream = new TarArchiveOutputStream(baos);
        TarArchiveEntry entry = new TarArchiveEntry("extended_attributes.txt");
        entry.addPaxHeader("user.attr", "value");
        tarOutputStream.putArchiveEntry(entry);
        assertEquals("value", entry.getExtraPaxHeader("user.attr"));
    }
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testPutArchiveEntryWithNonExistentLink_iacL15() throws IOException {
        ByteArrayOutputStream baos = new ByteArrayOutputStream();
        TarArchiveOutputStream tarOutputStream = new TarArchiveOutputStream(baos);
        TarArchiveEntry entry = new TarArchiveEntry("non_existent_link", (byte) 1);
        entry.setLinkName("non_existent_target.txt");
        tarOutputStream.putArchiveEntry(entry);
        assertEquals("non_existent_target.txt", entry.getLinkName());
    }
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testPutArchiveEntryWithEmptyEntry_wcgP16() throws IOException {
        ByteArrayOutputStream baos = new ByteArrayOutputStream();
        TarArchiveOutputStream tarOutputStream = new TarArchiveOutputStream(baos);
        TarArchiveEntry entry = new TarArchiveEntry("empty_entry.txt");
        entry.setSize(0);
        tarOutputStream.putArchiveEntry(entry);
        assertEquals(0, entry.getSize());
    }
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testPutArchiveEntryWithInvalidLinkFlag_fkMk17() throws IOException {
        ByteArrayOutputStream baos = new ByteArrayOutputStream();
        TarArchiveOutputStream tarOutputStream = new TarArchiveOutputStream(baos);
        TarArchiveEntry entry = new TarArchiveEntry("invalid_link_flag.txt", (byte) 99);
        tarOutputStream.putArchiveEntry(entry);
        assertEquals((byte) 99, entry.getLinkFlag());
    }
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
public void testPutArchiveEntry_GlobalPaxHeader_qXXQ0_1() throws IOException {
    TarArchiveOutputStream outputStream = new TarArchiveOutputStream(new ByteArrayOutputStream());
    TarArchiveEntry entry = new TarArchiveEntry("test.txt");
    entry.setGlobalPaxHeader(true);
    entry.setSize(10);
    outputStream.putArchiveEntry(entry);
    assertTrue(outputStream.haveUnclosedEntry);}
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
public void testPutArchiveEntry_GlobalPaxHeader_qXXQ0_2() throws IOException {
    TarArchiveOutputStream outputStream = new TarArchiveOutputStream(new ByteArrayOutputStream());
    TarArchiveEntry entry = new TarArchiveEntry("test.txt");
    entry.setGlobalPaxHeader(true);
    entry.setSize(10);
    outputStream.putArchiveEntry(entry);
    assertEquals(10, entry.getSize());}
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
public void testPutArchiveEntry_NonGlobalPaxHeader_GtSV1_1() throws IOException {
    TarArchiveOutputStream outputStream = new TarArchiveOutputStream(new ByteArrayOutputStream());
    TarArchiveEntry entry = new TarArchiveEntry("test.txt");
    entry.setSize(10);
    outputStream.putArchiveEntry(entry);
    assertTrue(outputStream.haveUnclosedEntry);}
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
public void testPutArchiveEntry_NonGlobalPaxHeader_GtSV1_2() throws IOException {
    TarArchiveOutputStream outputStream = new TarArchiveOutputStream(new ByteArrayOutputStream());
    TarArchiveEntry entry = new TarArchiveEntry("test.txt");
    entry.setSize(10);
    outputStream.putArchiveEntry(entry);
    assertEquals(10, entry.getSize());}
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
public void testPutArchiveEntry_WithLongName_eGke2_1() throws IOException {
    TarArchiveOutputStream outputStream = new TarArchiveOutputStream(new ByteArrayOutputStream());
    TarArchiveEntry entry = new TarArchiveEntry("very_long_filename_that_exceeds_normal_length.txt");
    outputStream.putArchiveEntry(entry);
    assertTrue(outputStream.haveUnclosedEntry);}
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
public void testPutArchiveEntry_WithLongName_eGke2_2() throws IOException {
    TarArchiveOutputStream outputStream = new TarArchiveOutputStream(new ByteArrayOutputStream());
    TarArchiveEntry entry = new TarArchiveEntry("very_long_filename_that_exceeds_normal_length.txt");
    outputStream.putArchiveEntry(entry);
    assertNotNull(entry.getExtraPaxHeaders().get("path"));}
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
public void testPutArchiveEntry_WithLinkName_XbKD3_1() throws IOException {
    TarArchiveOutputStream outputStream = new TarArchiveOutputStream(new ByteArrayOutputStream());
    TarArchiveEntry entry = new TarArchiveEntry("test.txt");
    entry.setLinkName("link_to_test.txt");
    outputStream.putArchiveEntry(entry);
    assertTrue(outputStream.haveUnclosedEntry);}
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
public void testPutArchiveEntry_WithLinkName_XbKD3_2() throws IOException {
    TarArchiveOutputStream outputStream = new TarArchiveOutputStream(new ByteArrayOutputStream());
    TarArchiveEntry entry = new TarArchiveEntry("test.txt");
    entry.setLinkName("link_to_test.txt");
    outputStream.putArchiveEntry(entry);
    assertEquals("link_to_test.txt", entry.getLinkName());}
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
public void testPutArchiveEntry_WithBigNumbers_PqLv4_1() throws IOException {
    TarArchiveOutputStream outputStream = new TarArchiveOutputStream(new ByteArrayOutputStream());
    TarArchiveEntry entry = new TarArchiveEntry("test.txt");
    entry.setSize(Long.MAX_VALUE);
    entry.setLongUserId(Long.MAX_VALUE);
    entry.setLongGroupId(Long.MAX_VALUE);
    outputStream.putArchiveEntry(entry);
    assertTrue(outputStream.haveUnclosedEntry);}
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
public void testPutArchiveEntry_WithBigNumbers_PqLv4_2() throws IOException {
    TarArchiveOutputStream outputStream = new TarArchiveOutputStream(new ByteArrayOutputStream());
    TarArchiveEntry entry = new TarArchiveEntry("test.txt");
    entry.setSize(Long.MAX_VALUE);
    entry.setLongUserId(Long.MAX_VALUE);
    entry.setLongGroupId(Long.MAX_VALUE);
    outputStream.putArchiveEntry(entry);
    assertEquals(Long.MAX_VALUE, entry.getLongUserId());}
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
public void testPutArchiveEntry_WithNonAsciiName_LEqH5_2() throws IOException {
    TarArchiveOutputStream outputStream = new TarArchiveOutputStream(new ByteArrayOutputStream());
    TarArchiveEntry entry = new TarArchiveEntry(".txt");
    outputStream.putArchiveEntry(entry);
    assertNotNull(entry.getExtraPaxHeaders().get("path"));}
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
public void testPutArchiveEntry_DirectoryEntry_hpmo6_1() throws IOException {
    TarArchiveOutputStream outputStream = new TarArchiveOutputStream(new ByteArrayOutputStream());
    TarArchiveEntry entry = new TarArchiveEntry("directory/");
    entry.setSize(0);
    outputStream.putArchiveEntry(entry);
    assertTrue(outputStream.haveUnclosedEntry);}
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
public void testPutArchiveEntry_DirectoryEntry_hpmo6_2() throws IOException {
    TarArchiveOutputStream outputStream = new TarArchiveOutputStream(new ByteArrayOutputStream());
    TarArchiveEntry entry = new TarArchiveEntry("directory/");
    entry.setSize(0);
    outputStream.putArchiveEntry(entry);
    assertEquals(0, entry.getSize());}
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
public void testPutArchiveEntry_SymbolicLink_AgRj7_1() throws IOException {
    TarArchiveOutputStream outputStream = new TarArchiveOutputStream(new ByteArrayOutputStream());
    TarArchiveEntry entry = new TarArchiveEntry("link.txt", (byte) 2);
    entry.setLinkName("target.txt");
    outputStream.putArchiveEntry(entry);
    assertTrue(outputStream.haveUnclosedEntry);}
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
public void testPutArchiveEntry_SymbolicLink_AgRj7_2() throws IOException {
    TarArchiveOutputStream outputStream = new TarArchiveOutputStream(new ByteArrayOutputStream());
    TarArchiveEntry entry = new TarArchiveEntry("link.txt", (byte) 2);
    entry.setLinkName("target.txt");
    outputStream.putArchiveEntry(entry);
    assertEquals("target.txt", entry.getLinkName());}
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
public void testPutArchiveEntry_WithCreationTime_TeNb8() throws IOException {
    TarArchiveOutputStream outputStream = new TarArchiveOutputStream(new ByteArrayOutputStream());
    TarArchiveEntry entry = new TarArchiveEntry("test.txt");
    entry.setCreationTime(FileTime.fromMillis(System.currentTimeMillis()));
    outputStream.putArchiveEntry(entry);
    assertNotNull(entry.getCreationTime());
}
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
public void testPutArchiveEntry_WithLastAccessTime_cgOm9() throws IOException {
    TarArchiveOutputStream outputStream = new TarArchiveOutputStream(new ByteArrayOutputStream());
    TarArchiveEntry entry = new TarArchiveEntry("test.txt");
    entry.setLastAccessTime(FileTime.fromMillis(System.currentTimeMillis()));
    outputStream.putArchiveEntry(entry);
    assertNotNull(entry.getLastAccessTime());
}
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
public void testPutArchiveEntry_WithStatusChangeTime_OWcc10() throws IOException {
    TarArchiveOutputStream outputStream = new TarArchiveOutputStream(new ByteArrayOutputStream());
    TarArchiveEntry entry = new TarArchiveEntry("test.txt");
    entry.setStatusChangeTime(FileTime.fromMillis(System.currentTimeMillis()));
    outputStream.putArchiveEntry(entry);
    assertNotNull(entry.getStatusChangeTime());
}
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
public void testPutArchiveEntry_WithSparseHeaders_lazN11() throws IOException {
    TarArchiveOutputStream outputStream = new TarArchiveOutputStream(new ByteArrayOutputStream());
    TarArchiveEntry entry = new TarArchiveEntry("test.txt");
    List<TarArchiveStructSparse> sparseHeaders = new ArrayList<>();
    entry.setSparseHeaders(sparseHeaders);
    outputStream.putArchiveEntry(entry);
    assertEquals(sparseHeaders, entry.getSparseHeaders());
}
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
public void testPutArchiveEntry_WithExtraPaxHeaders_hVyz12() throws IOException {
    TarArchiveOutputStream outputStream = new TarArchiveOutputStream(new ByteArrayOutputStream());
    TarArchiveEntry entry = new TarArchiveEntry("test.txt");
    entry.addPaxHeader("customHeader", "customValue");
    outputStream.putArchiveEntry(entry);
    assertEquals("customValue", entry.getExtraPaxHeader("customHeader"));
}
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
public void testPutArchiveEntry_WithFileMode_Akml13() throws IOException {
    TarArchiveOutputStream outputStream = new TarArchiveOutputStream(new ByteArrayOutputStream());
    TarArchiveEntry entry = new TarArchiveEntry("test.txt");
    entry.setMode(0755);
    outputStream.putArchiveEntry(entry);
    assertEquals(0755, entry.getMode());
}
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
public void testPutArchiveEntry_WithDeviceNumbers_Qnmf14_1() throws IOException {
    TarArchiveOutputStream outputStream = new TarArchiveOutputStream(new ByteArrayOutputStream());
    TarArchiveEntry entry = new TarArchiveEntry("test.txt");
    entry.setDevMajor(1);
    entry.setDevMinor(2);
    outputStream.putArchiveEntry(entry);
    assertEquals(1, entry.getDevMajor());}
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
public void testPutArchiveEntry_WithDeviceNumbers_Qnmf14_2() throws IOException {
    TarArchiveOutputStream outputStream = new TarArchiveOutputStream(new ByteArrayOutputStream());
    TarArchiveEntry entry = new TarArchiveEntry("test.txt");
    entry.setDevMajor(1);
    entry.setDevMinor(2);
    outputStream.putArchiveEntry(entry);
    assertEquals(2, entry.getDevMinor());}
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
public void testPutArchiveEntry_WithCheckSum_suXX15() throws IOException {
    TarArchiveOutputStream outputStream = new TarArchiveOutputStream(new ByteArrayOutputStream());
    TarArchiveEntry entry = new TarArchiveEntry("test.txt");
    outputStream.putArchiveEntry(entry);
    assertTrue(entry.isCheckSumOK());
}
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
public void testPutArchiveEntry_WithFIFO_ENsX16() throws IOException {
    TarArchiveOutputStream outputStream = new TarArchiveOutputStream(new ByteArrayOutputStream());
    TarArchiveEntry entry = new TarArchiveEntry("fifo", (byte) 6);
    outputStream.putArchiveEntry(entry);
    assertTrue(entry.isFIFO());
}
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
public void testPutArchiveEntry_WithCharacterDevice_oRbN17() throws IOException {
    TarArchiveOutputStream outputStream = new TarArchiveOutputStream(new ByteArrayOutputStream());
    TarArchiveEntry entry = new TarArchiveEntry("charDevice", (byte) 3);
    outputStream.putArchiveEntry(entry);
    assertTrue(entry.isCharacterDevice());
}
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
public void testPutArchiveEntryWithFinishedStream_EHQq0() throws IOException {
    TarArchiveOutputStream outputStream = new TarArchiveOutputStream(new ByteArrayOutputStream());
    outputStream.finish();
    TarArchiveEntry entry = new TarArchiveEntry("test.txt");
    assertThrows(IOException.class, () -> outputStream.putArchiveEntry(entry));
}
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
public void testPutArchiveEntryWithGlobalPaxHeader_jijm1() throws IOException {
    TarArchiveOutputStream outputStream = new TarArchiveOutputStream(new ByteArrayOutputStream());
    TarArchiveEntry entry = new TarArchiveEntry("test.txt");
    entry.setGlobalPaxHeader(true);
    entry.setSize(100);
    outputStream.putArchiveEntry(entry);
    assertEquals(100, entry.getSize());
}
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
public void testPutArchiveEntryWithLongName_Uypk2() throws IOException {
    TarArchiveOutputStream outputStream = new TarArchiveOutputStream(new ByteArrayOutputStream());
    TarArchiveEntry entry = new TarArchiveEntry("very_long_file_name_that_exceeds_normal_length.txt");
    outputStream.putArchiveEntry(entry);
    assertTrue(entry.getExtraPaxHeaders().containsKey("path"));
}
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
public void testPutArchiveEntryWithLinkPath_nYOH3() throws IOException {
    TarArchiveOutputStream outputStream = new TarArchiveOutputStream(new ByteArrayOutputStream());
    TarArchiveEntry entry = new TarArchiveEntry("test.txt");
    entry.setLinkName("link_to_test.txt");
    outputStream.putArchiveEntry(entry);
    assertTrue(entry.getExtraPaxHeaders().containsKey("linkpath"));
}
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
public void testPutArchiveEntryWithBigNumbers_cShZ4_1() throws IOException {
    TarArchiveOutputStream outputStream = new TarArchiveOutputStream(new ByteArrayOutputStream());
    TarArchiveEntry entry = new TarArchiveEntry("test.txt");
    entry.setSize(Long.MAX_VALUE);
    entry.setLongUserId(Long.MAX_VALUE);
    entry.setLongGroupId(Long.MAX_VALUE);
    outputStream.putArchiveEntry(entry);
    assertTrue(entry.getExtraPaxHeaders().containsKey("size"));}
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
public void testPutArchiveEntryWithBigNumbers_cShZ4_2() throws IOException {
    TarArchiveOutputStream outputStream = new TarArchiveOutputStream(new ByteArrayOutputStream());
    TarArchiveEntry entry = new TarArchiveEntry("test.txt");
    entry.setSize(Long.MAX_VALUE);
    entry.setLongUserId(Long.MAX_VALUE);
    entry.setLongGroupId(Long.MAX_VALUE);
    outputStream.putArchiveEntry(entry);
    assertTrue(entry.getExtraPaxHeaders().containsKey("uid"));}
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
public void testPutArchiveEntryWithBigNumbers_cShZ4_3() throws IOException {
    TarArchiveOutputStream outputStream = new TarArchiveOutputStream(new ByteArrayOutputStream());
    TarArchiveEntry entry = new TarArchiveEntry("test.txt");
    entry.setSize(Long.MAX_VALUE);
    entry.setLongUserId(Long.MAX_VALUE);
    entry.setLongGroupId(Long.MAX_VALUE);
    outputStream.putArchiveEntry(entry);
    assertTrue(entry.getExtraPaxHeaders().containsKey("gid"));}
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
public void testPutArchiveEntryWithNonAsciiName_UrVX5() throws IOException {
    TarArchiveOutputStream outputStream = new TarArchiveOutputStream(new ByteArrayOutputStream());
    TarArchiveEntry entry = new TarArchiveEntry(".txt");
    outputStream.putArchiveEntry(entry);
    assertTrue(entry.getExtraPaxHeaders().containsKey("path"));
}
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
public void testPutArchiveEntryWithDirectory_gslX6() throws IOException {
    TarArchiveOutputStream outputStream = new TarArchiveOutputStream(new ByteArrayOutputStream());
    TarArchiveEntry entry = new TarArchiveEntry("directory/");
    entry.setSize(0);
    outputStream.putArchiveEntry(entry);
    assertEquals(0, outputStream.currSize);
}
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
public void testPutArchiveEntryWithSymbolicLink_AOar7() throws IOException {
    TarArchiveOutputStream outputStream = new TarArchiveOutputStream(new ByteArrayOutputStream());
    TarArchiveEntry entry = new TarArchiveEntry("symlink");
    entry.setLinkName("target.txt");
    entry.setSize(0);
    outputStream.putArchiveEntry(entry);
    assertTrue(entry.getExtraPaxHeaders().containsKey("linkpath"));
}
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
public void testPutArchiveEntryWithEmptyPaxHeaders_DiGE8() throws IOException {
    TarArchiveOutputStream outputStream = new TarArchiveOutputStream(new ByteArrayOutputStream());
    TarArchiveEntry entry = new TarArchiveEntry("test.txt");
    outputStream.putArchiveEntry(entry);
    assertTrue(entry.getExtraPaxHeaders().isEmpty());
}
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
public void testPutArchiveEntryWithInvalidLinkName_AvRU9() throws IOException {
    TarArchiveOutputStream outputStream = new TarArchiveOutputStream(new ByteArrayOutputStream());
    TarArchiveEntry entry = new TarArchiveEntry("test.txt");
    entry.setLinkName("");
    outputStream.putArchiveEntry(entry);
    assertFalse(entry.getExtraPaxHeaders().containsKey("linkpath"));
}
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
public void testPutArchiveEntryWithLargeFileSize_MCAs10() throws IOException {
    TarArchiveOutputStream outputStream = new TarArchiveOutputStream(new ByteArrayOutputStream());
    TarArchiveEntry entry = new TarArchiveEntry("largefile.txt");
    entry.setSize(Long.MAX_VALUE);
    outputStream.putArchiveEntry(entry);
    assertTrue(entry.getExtraPaxHeaders().containsKey("size"));
}
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
public void testPutArchiveEntryWithCreationTime_lfYi11() throws IOException {
    TarArchiveOutputStream outputStream = new TarArchiveOutputStream(new ByteArrayOutputStream());
    TarArchiveEntry entry = new TarArchiveEntry("test.txt");
    entry.setCreationTime(FileTime.fromMillis(System.currentTimeMillis()));
    outputStream.putArchiveEntry(entry);
    assertTrue(entry.getExtraPaxHeaders().containsKey("LIBARCHIVE.creationtime"));
}
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
public void testPutArchiveEntryWithStatusChangeTime_ZzxO12() throws IOException {
    TarArchiveOutputStream outputStream = new TarArchiveOutputStream(new ByteArrayOutputStream());
    TarArchiveEntry entry = new TarArchiveEntry("test.txt");
    entry.setStatusChangeTime(FileTime.fromMillis(System.currentTimeMillis()));
    outputStream.putArchiveEntry(entry);
    assertTrue(entry.getExtraPaxHeaders().containsKey("ctime"));
}
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
public void testPutArchiveEntryWithModTime_FaZj13() throws IOException {
    TarArchiveOutputStream outputStream = new TarArchiveOutputStream(new ByteArrayOutputStream());
    TarArchiveEntry entry = new TarArchiveEntry("test.txt");
    entry.setModTime(FileTime.fromMillis(System.currentTimeMillis()));
    outputStream.putArchiveEntry(entry);
    assertEquals(entry.getLastModifiedTime(), entry.getModTime());
}
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
public void testPutArchiveEntryWithFIFO_BwFI14() throws IOException {
    TarArchiveOutputStream outputStream = new TarArchiveOutputStream(new ByteArrayOutputStream());
    TarArchiveEntry entry = new TarArchiveEntry("fifo");
    entry.setFIFO(true);
    outputStream.putArchiveEntry(entry);
    assertTrue(entry.isFIFO());
}
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
public void testPutArchiveEntryWithCharacterDevice_mCSg15() throws IOException {
    TarArchiveOutputStream outputStream = new TarArchiveOutputStream(new ByteArrayOutputStream());
    TarArchiveEntry entry = new TarArchiveEntry("char_device");
    entry.setCharacterDevice(true);
    outputStream.putArchiveEntry(entry);
    assertTrue(entry.isCharacterDevice());
}
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
public void testPutArchiveEntryWithBlockDevice_EGeD16() throws IOException {
    TarArchiveOutputStream outputStream = new TarArchiveOutputStream(new ByteArrayOutputStream());
    TarArchiveEntry entry = new TarArchiveEntry("block_device");
    entry.setBlockDevice(true);
    outputStream.putArchiveEntry(entry);
    assertTrue(entry.isBlockDevice());
}
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
public void testPutArchiveEntryWithSparseFile_KseR17() throws IOException {
    TarArchiveOutputStream outputStream = new TarArchiveOutputStream(new ByteArrayOutputStream());
    TarArchiveEntry entry = new TarArchiveEntry("sparse_file");
    entry.setSparse(true);
    outputStream.putArchiveEntry(entry);
    assertTrue(entry.isSparse());
}
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
public void testSetAddPaxHeadersForNonAsciiNamesTrue_AmPQ0() {
    TarArchiveOutputStream tarOutputStream = new TarArchiveOutputStream(new ByteArrayOutputStream());
    tarOutputStream.setAddPaxHeadersForNonAsciiNames(true);
    assertTrue(tarOutputStream.addPaxHeadersForNonAsciiNames);
}
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
public void testSetAddPaxHeadersForNonAsciiNamesFalse_gbCA1() {
    TarArchiveOutputStream tarOutputStream = new TarArchiveOutputStream(new ByteArrayOutputStream());
    tarOutputStream.setAddPaxHeadersForNonAsciiNames(false);
    assertFalse(tarOutputStream.addPaxHeadersForNonAsciiNames);
}
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
public void testPutArchiveEntry_GlobalPaxHeader_XTHz0() throws IOException {
    OutputStream os = new ByteArrayOutputStream();
    TarArchiveOutputStream tarOutputStream = new TarArchiveOutputStream(os);
    TarArchiveEntry entry = new TarArchiveEntry("test.txt");
    entry.setGlobalPaxHeader(true);
    entry.setSize(10);
    tarOutputStream.putArchiveEntry(entry);
    assertTrue(tarOutputStream.haveUnclosedEntry);
}
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
public void testPutArchiveEntry_LongName_gjDP1() throws IOException {
    OutputStream os = new ByteArrayOutputStream();
    TarArchiveOutputStream tarOutputStream = new TarArchiveOutputStream(os);
    TarArchiveEntry entry = new TarArchiveEntry("very_long_file_name_that_exceeds_normal_length.txt");
    tarOutputStream.putArchiveEntry(entry);
    assertEquals(entry.getName(), tarOutputStream.currName);
}
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
public void testPutArchiveEntry_SymbolicLink_hXWd2() throws IOException {
    OutputStream os = new ByteArrayOutputStream();
    TarArchiveOutputStream tarOutputStream = new TarArchiveOutputStream(os);
    TarArchiveEntry entry = new TarArchiveEntry("link.txt", (byte) 1);
    entry.setLinkName("target.txt");
    tarOutputStream.putArchiveEntry(entry);
    assertTrue(tarOutputStream.haveUnclosedEntry);
}
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
public void testPutArchiveEntry_Directory_XGLc3() throws IOException {
    OutputStream os = new ByteArrayOutputStream();
    TarArchiveOutputStream tarOutputStream = new TarArchiveOutputStream(os);
    TarArchiveEntry entry = new TarArchiveEntry("directory/");
    entry.setSize(0);
    tarOutputStream.putArchiveEntry(entry);
    assertEquals(0, tarOutputStream.currSize);
}
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
public void testPutArchiveEntry_NonAsciiName_yBHw4() throws IOException {
    OutputStream os = new ByteArrayOutputStream();
    TarArchiveOutputStream tarOutputStream = new TarArchiveOutputStream(os);
    TarArchiveEntry entry = new TarArchiveEntry(".txt");
    tarOutputStream.addPaxHeadersForNonAsciiNames = true;
    tarOutputStream.putArchiveEntry(entry);
    assertTrue(tarOutputStream.haveUnclosedEntry);
}
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
public void testPutArchiveEntry_BigNumbers_Posix_iJYC5() throws IOException {
    OutputStream os = new ByteArrayOutputStream();
    TarArchiveOutputStream tarOutputStream = new TarArchiveOutputStream(os);
    TarArchiveEntry entry = new TarArchiveEntry("bigfile.txt");
    entry.setSize(Long.MAX_VALUE);
    tarOutputStream.bigNumberMode = TarArchiveOutputStream.BIGNUMBER_POSIX;
    tarOutputStream.putArchiveEntry(entry);
    assertTrue(tarOutputStream.haveUnclosedEntry);
}
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
public void testPutArchiveEntry_BigNumbers_Star_wXpH6() throws IOException {
    OutputStream os = new ByteArrayOutputStream();
    TarArchiveOutputStream tarOutputStream = new TarArchiveOutputStream(os);
    TarArchiveEntry entry = new TarArchiveEntry("bigfile.txt");
    entry.setSize(Long.MAX_VALUE);
    tarOutputStream.bigNumberMode = TarArchiveOutputStream.BIGNUMBER_STAR;
    tarOutputStream.putArchiveEntry(entry);
    assertTrue(tarOutputStream.haveUnclosedEntry);
}
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
public void testPutArchiveEntry_FinishedStream_TMuJ7() {
    OutputStream os = new ByteArrayOutputStream();
    TarArchiveOutputStream tarOutputStream = new TarArchiveOutputStream(os);
    tarOutputStream.finished = true;
    TarArchiveEntry entry = new TarArchiveEntry("test.txt");
    assertThrows(IOException.class, () -> tarOutputStream.putArchiveEntry(entry));
}
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
public void testPutArchiveEntry_EmptyPaxHeaders_rbqg8() throws IOException {
    OutputStream os = new ByteArrayOutputStream();
    TarArchiveOutputStream tarOutputStream = new TarArchiveOutputStream(os);
    TarArchiveEntry entry = new TarArchiveEntry("test.txt");
    tarOutputStream.putArchiveEntry(entry);
    assertTrue(tarOutputStream.currBytes == 0);
}
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
public void testPutArchiveEntry_WithExtraPaxHeaders_zzMX9() throws IOException {
    OutputStream os = new ByteArrayOutputStream();
    TarArchiveOutputStream tarOutputStream = new TarArchiveOutputStream(os);
    TarArchiveEntry entry = new TarArchiveEntry("test.txt");
    entry.addPaxHeader("customHeader", "customValue");
    tarOutputStream.putArchiveEntry(entry);
    assertEquals("customValue", entry.getExtraPaxHeader("customHeader"));
}
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
public void testPutArchiveEntry_SparseFile_hfob10() throws IOException {
    OutputStream os = new ByteArrayOutputStream();
    TarArchiveOutputStream tarOutputStream = new TarArchiveOutputStream(os);
    TarArchiveEntry entry = new TarArchiveEntry("sparsefile.txt");
    entry.setSparseHeaders(new ArrayList<>());
    tarOutputStream.putArchiveEntry(entry);
    assertTrue(tarOutputStream.haveUnclosedEntry);
}
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
public void testPutArchiveEntry_ValidLink_gwPp11() throws IOException {
    OutputStream os = new ByteArrayOutputStream();
    TarArchiveOutputStream tarOutputStream = new TarArchiveOutputStream(os);
    TarArchiveEntry entry = new TarArchiveEntry("link.txt", (byte) 1);
    entry.setLinkName("target.txt");
    tarOutputStream.putArchiveEntry(entry);
    assertEquals("target.txt", entry.getLinkName());
}
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
public void testPutArchiveEntry_ValidFileMode_Jond12() throws IOException {
    OutputStream os = new ByteArrayOutputStream();
    TarArchiveOutputStream tarOutputStream = new TarArchiveOutputStream(os);
    TarArchiveEntry entry = new TarArchiveEntry("file.txt");
    entry.setMode(0755);
    tarOutputStream.putArchiveEntry(entry);
    assertEquals(0755, entry.getMode());
}
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
public void testPutArchiveEntry_ValidUserId_IDHy13() throws IOException {
    OutputStream os = new ByteArrayOutputStream();
    TarArchiveOutputStream tarOutputStream = new TarArchiveOutputStream(os);
    TarArchiveEntry entry = new TarArchiveEntry("file.txt");
    entry.setUserId(1001);
    tarOutputStream.putArchiveEntry(entry);
    assertEquals(1001, entry.getUserId());
}
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
public void testPutArchiveEntry_ValidGroupId_XhTP14() throws IOException {
    OutputStream os = new ByteArrayOutputStream();
    TarArchiveOutputStream tarOutputStream = new TarArchiveOutputStream(os);
    TarArchiveEntry entry = new TarArchiveEntry("file.txt");
    entry.setGroupId(1001);
    tarOutputStream.putArchiveEntry(entry);
    assertEquals(1001, entry.getGroupId());
}
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
public void testPutArchiveEntry_ValidCreationTime_MmAp15() throws IOException {
    OutputStream os = new ByteArrayOutputStream();
    TarArchiveOutputStream tarOutputStream = new TarArchiveOutputStream(os);
    TarArchiveEntry entry = new TarArchiveEntry("file.txt");
    FileTime creationTime = FileTime.fromMillis(System.currentTimeMillis());
    entry.setCreationTime(creationTime);
    tarOutputStream.putArchiveEntry(entry);
    assertEquals(creationTime, entry.getCreationTime());
}
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
public void testPutArchiveEntry_ValidLastModifiedTime_dzrG16() throws IOException {
    OutputStream os = new ByteArrayOutputStream();
    TarArchiveOutputStream tarOutputStream = new TarArchiveOutputStream(os);
    TarArchiveEntry entry = new TarArchiveEntry("file.txt");
    FileTime lastModifiedTime = FileTime.fromMillis(System.currentTimeMillis());
    entry.setLastModifiedTime(lastModifiedTime);
    tarOutputStream.putArchiveEntry(entry);
    assertEquals(lastModifiedTime, entry.getLastModifiedTime());
}
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
public void testPutArchiveEntry_ValidLastAccessTime_NcBf17() throws IOException {
    OutputStream os = new ByteArrayOutputStream();
    TarArchiveOutputStream tarOutputStream = new TarArchiveOutputStream(os);
    TarArchiveEntry entry = new TarArchiveEntry("file.txt");
    FileTime lastAccessTime = FileTime.fromMillis(System.currentTimeMillis());
    entry.setLastAccessTime(lastAccessTime);
    tarOutputStream.putArchiveEntry(entry);
    assertEquals(lastAccessTime, entry.getLastAccessTime());
}
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
public void testGetBytesWritten_UsnA0() {
    ByteArrayOutputStream baos = new ByteArrayOutputStream();
    TarArchiveOutputStream tarOutputStream = new TarArchiveOutputStream(baos);
    tarOutputStream.write(new byte[100]);
    long bytesWritten = tarOutputStream.getBytesWritten();
    assertEquals(100, bytesWritten);
}
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
public void testGetCount_ObEi0() {
    ByteArrayOutputStream baos = new ByteArrayOutputStream();
    TarArchiveOutputStream tarOutputStream = new TarArchiveOutputStream(baos);
    tarOutputStream.write(new byte[100]);
    int count = tarOutputStream.getCount();
    assertEquals(100, count);
}
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
public void testPutArchiveEntryWithFinishedStream_skGP0() throws IOException {
    TarArchiveOutputStream outputStream = new TarArchiveOutputStream(new ByteArrayOutputStream());
    outputStream.finished = true;
    TarArchiveEntry entry = new TarArchiveEntry("test.txt");
    assertThrows(IOException.class, () -> outputStream.putArchiveEntry(entry));
}
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
public void testPutArchiveEntryWithLongName_DepO2() throws IOException {
    TarArchiveOutputStream outputStream = new TarArchiveOutputStream(new ByteArrayOutputStream());
    TarArchiveEntry entry = new TarArchiveEntry("very_long_file_name_that_exceeds_normal_length.txt");
    outputStream.putArchiveEntry(entry);
    assertTrue(entry.isGlobalPaxHeader());
}
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
public void testPutArchiveEntryWithLink_HSSA3() throws IOException {
    TarArchiveOutputStream outputStream = new TarArchiveOutputStream(new ByteArrayOutputStream());
    TarArchiveEntry entry = new TarArchiveEntry("link.txt", (byte) 1);
    entry.setLinkName("target.txt");
    outputStream.putArchiveEntry(entry);
    assertEquals("target.txt", entry.getLinkName());
}
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
public void testPutArchiveEntryWithBigNumbers_gjfI4() throws IOException {
    TarArchiveOutputStream outputStream = new TarArchiveOutputStream(new ByteArrayOutputStream());
    TarArchiveEntry entry = new TarArchiveEntry("big_numbers.txt");
    entry.setSize(Long.MAX_VALUE);
    entry.setLongUserId(Long.MAX_VALUE);
    entry.setLongGroupId(Long.MAX_VALUE);
    assertThrows(IllegalArgumentException.class, () -> outputStream.putArchiveEntry(entry));
}
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
public void testPutArchiveEntryWithNonAsciiName_gZsr5() throws IOException {
    TarArchiveOutputStream outputStream = new TarArchiveOutputStream(new ByteArrayOutputStream());
    TarArchiveEntry entry = new TarArchiveEntry(".txt");
    outputStream.addPaxHeadersForNonAsciiNames = true;
    outputStream.putArchiveEntry(entry);
    assertTrue(entry.getExtraPaxHeaders().containsKey("path"));
}
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
public void testPutArchiveEntryWithSymbolicLink_AjKq7() throws IOException {
    TarArchiveOutputStream outputStream = new TarArchiveOutputStream(new ByteArrayOutputStream());
    TarArchiveEntry entry = new TarArchiveEntry("symlink.txt", (byte) 2);
    entry.setLinkName("target.txt");
    outputStream.putArchiveEntry(entry);
    assertTrue(entry.isSymbolicLink());
}
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
public void testPutArchiveEntryWithInvalidSize_eLvx8() throws IOException {
    TarArchiveOutputStream outputStream = new TarArchiveOutputStream(new ByteArrayOutputStream());
    TarArchiveEntry entry = new TarArchiveEntry("invalid_size.txt");
    entry.setSize(-1);
    assertThrows(IllegalArgumentException.class, () -> outputStream.putArchiveEntry(entry));
}
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
public void testPutArchiveEntryWithCreationTime_ZVUu9() throws IOException {
    TarArchiveOutputStream outputStream = new TarArchiveOutputStream(new ByteArrayOutputStream());
    TarArchiveEntry entry = new TarArchiveEntry("creation_time.txt");
    FileTime creationTime = FileTime.fromMillis(System.currentTimeMillis());
    entry.setCreationTime(creationTime);
    outputStream.putArchiveEntry(entry);
    assertEquals(creationTime, entry.getCreationTime());
}
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
public void testPutArchiveEntryWithStatusChangeTime_abEO10() throws IOException {
    TarArchiveOutputStream outputStream = new TarArchiveOutputStream(new ByteArrayOutputStream());
    TarArchiveEntry entry = new TarArchiveEntry("status_change_time.txt");
    FileTime statusChangeTime = FileTime.fromMillis(System.currentTimeMillis());
    entry.setStatusChangeTime(statusChangeTime);
    outputStream.putArchiveEntry(entry);
    assertEquals(statusChangeTime, entry.getStatusChangeTime());
}
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
public void testPutArchiveEntryWithEmptyPaxHeaders_BwFu11() throws IOException {
    TarArchiveOutputStream outputStream = new TarArchiveOutputStream(new ByteArrayOutputStream());
    TarArchiveEntry entry = new TarArchiveEntry("empty_pax.txt");
    entry.clearExtraPaxHeaders();
    outputStream.putArchiveEntry(entry);
    assertTrue(entry.getExtraPaxHeaders().isEmpty());
}
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
public void testPutArchiveEntryWithInvalidMode_yKbP12() throws IOException {
    TarArchiveOutputStream outputStream = new TarArchiveOutputStream(new ByteArrayOutputStream());
    TarArchiveEntry entry = new TarArchiveEntry("invalid_mode.txt");
    entry.setMode(-1);
    assertThrows(IllegalArgumentException.class, () -> outputStream.putArchiveEntry(entry));
}
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
public void testPutArchiveEntryWithFIFO_eCCd13() throws IOException {
    TarArchiveOutputStream outputStream = new TarArchiveOutputStream(new ByteArrayOutputStream());
    TarArchiveEntry entry = new TarArchiveEntry("fifo.txt");
    entry.setMode(0x1000); // FIFO mode
    outputStream.putArchiveEntry(entry);
    assertTrue(entry.isFIFO());
}
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
public void testPutArchiveEntryWithCharacterDevice_tlDZ14() throws IOException {
    TarArchiveOutputStream outputStream = new TarArchiveOutputStream(new ByteArrayOutputStream());
    TarArchiveEntry entry = new TarArchiveEntry("char_device.txt");
    entry.setMode(0x2000); // Character device mode
    outputStream.putArchiveEntry(entry);
    assertTrue(entry.isCharacterDevice());
}
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
public void testPutArchiveEntryWithBlockDevice_bTZn15() throws IOException {
    TarArchiveOutputStream outputStream = new TarArchiveOutputStream(new ByteArrayOutputStream());
    TarArchiveEntry entry = new TarArchiveEntry("block_device.txt");
    entry.setMode(0x6000); // Block device mode
    outputStream.putArchiveEntry(entry);
    assertTrue(entry.isBlockDevice());
}
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
public void testPutArchiveEntryWithSparse_ChQv16() throws IOException {
    TarArchiveOutputStream outputStream = new TarArchiveOutputStream(new ByteArrayOutputStream());
    TarArchiveEntry entry = new TarArchiveEntry("sparse_file.txt");
    entry.setSparseHeaders(new ArrayList<>());
    outputStream.putArchiveEntry(entry);
    assertTrue(entry.isSparse());
}
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
public void testPutArchiveEntryWithGNUSparse_clnz17() throws IOException {
    TarArchiveOutputStream outputStream = new TarArchiveOutputStream(new ByteArrayOutputStream());
    TarArchiveEntry entry = new TarArchiveEntry("gnu_sparse.txt");
    entry.setGNUSparse(true);
    outputStream.putArchiveEntry(entry);
    assertTrue(entry.isGNUSparse());
}
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
public void testPutArchiveEntryWithStarSparse_ZyNN18() throws IOException {
    TarArchiveOutputStream outputStream = new TarArchiveOutputStream(new ByteArrayOutputStream());
    TarArchiveEntry entry = new TarArchiveEntry("star_sparse.txt");
    entry.setStarSparse(true);
    outputStream.putArchiveEntry(entry);
    assertTrue(entry.isStarSparse());
}
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
public void testPutArchiveEntryWithPaxHeader_EISW19() throws IOException {
    TarArchiveOutputStream outputStream = new TarArchiveOutputStream(new ByteArrayOutputStream());
    TarArchiveEntry entry = new TarArchiveEntry("pax_header.txt");
    entry.addPaxHeader("custom", "value");
    outputStream.putArchiveEntry(entry);
    assertEquals("value", entry.getExtraPaxHeader("custom"));
}
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
public void testPutArchiveEntryWithLongName_dUcY2() throws IOException {
    TarArchiveOutputStream outputStream = new TarArchiveOutputStream(new ByteArrayOutputStream());
    TarArchiveEntry entry = new TarArchiveEntry("a_very_long_file_name_that_exceeds_the_normal_length.txt");
    outputStream.putArchiveEntry(entry);
    assertTrue(entry.isGlobalPaxHeader());
}
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
public void testPutArchiveEntryWithLinkPath_HCGu3() throws IOException {
    TarArchiveOutputStream outputStream = new TarArchiveOutputStream(new ByteArrayOutputStream());
    TarArchiveEntry entry = new TarArchiveEntry("test.txt");
    entry.setLinkName("link_to_test.txt");
    outputStream.putArchiveEntry(entry);
    assertNotNull(entry.getLinkName());
}
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
public void testPutArchiveEntryWithBigNumberModePosix_gzgC4() throws IOException {
    TarArchiveOutputStream outputStream = new TarArchiveOutputStream(new ByteArrayOutputStream());
    outputStream.setBigNumberMode(TarArchiveOutputStream.BIGNUMBER_POSIX);
    TarArchiveEntry entry = new TarArchiveEntry("test.txt");
    entry.setSize(Long.MAX_VALUE);
    outputStream.putArchiveEntry(entry);
    assertTrue(entry.getSize() > 0);
}
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
public void testPutArchiveEntryWithBigNumberModeStar_oyOP5() throws IOException {
    TarArchiveOutputStream outputStream = new TarArchiveOutputStream(new ByteArrayOutputStream());
    outputStream.setBigNumberMode(TarArchiveOutputStream.BIGNUMBER_STAR);
    TarArchiveEntry entry = new TarArchiveEntry("test.txt");
    entry.setSize(Long.MAX_VALUE);
    outputStream.putArchiveEntry(entry);
    assertTrue(entry.getSize() > 0);
}
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
public void testPutArchiveEntryWithLinkEntry_TAjH7() throws IOException {
    TarArchiveOutputStream outputStream = new TarArchiveOutputStream(new ByteArrayOutputStream());
    TarArchiveEntry entry = new TarArchiveEntry("test.txt");
    entry.setLinkName("link_to_test.txt");
    entry.setLinkFlag((byte) 1);
    outputStream.putArchiveEntry(entry);
    assertTrue(entry.isLink());
}
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
public void testPutArchiveEntryWithSparseHeaders_sZGi9() throws IOException {
    TarArchiveOutputStream outputStream = new TarArchiveOutputStream(new ByteArrayOutputStream());
    TarArchiveEntry entry = new TarArchiveEntry("sparse_file.txt");
    entry.setSparseHeaders(new ArrayList<>());
    outputStream.putArchiveEntry(entry);
    assertTrue(entry.getSparseHeaders().isEmpty());
}
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
public void testPutArchiveEntryWithCreationTime_lKjy10() throws IOException {
    TarArchiveOutputStream outputStream = new TarArchiveOutputStream(new ByteArrayOutputStream());
    TarArchiveEntry entry = new TarArchiveEntry("test.txt");
    FileTime creationTime = FileTime.fromMillis(System.currentTimeMillis());
    entry.setCreationTime(creationTime);
    outputStream.putArchiveEntry(entry);
    assertEquals(creationTime, entry.getCreationTime());
}
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
public void testPutArchiveEntryWithInvalidSize_NkAk11() throws IOException {
    TarArchiveOutputStream outputStream = new TarArchiveOutputStream(new ByteArrayOutputStream());
    TarArchiveEntry entry = new TarArchiveEntry("test.txt");
    entry.setSize(Long.MAX_VALUE + 1);
    assertThrows(IOException.class, () -> outputStream.putArchiveEntry(entry));
}
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
public void testPutArchiveEntryWithUserId_IxIx12() throws IOException {
    TarArchiveOutputStream outputStream = new TarArchiveOutputStream(new ByteArrayOutputStream());
    TarArchiveEntry entry = new TarArchiveEntry("test.txt");
    entry.setUserId(1001);
    outputStream.putArchiveEntry(entry);
    assertEquals(1001, entry.getUserId());
}
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
public void testPutArchiveEntryWithGroupId_wfMI13() throws IOException {
    TarArchiveOutputStream outputStream = new TarArchiveOutputStream(new ByteArrayOutputStream());
    TarArchiveEntry entry = new TarArchiveEntry("test.txt");
    entry.setGroupId(1001);
    outputStream.putArchiveEntry(entry);
    assertEquals(1001, entry.getGroupId());
}
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
public void testPutArchiveEntryWithStatusChangeTime_hIYs15() throws IOException {
    TarArchiveOutputStream outputStream = new TarArchiveOutputStream(new ByteArrayOutputStream());
    TarArchiveEntry entry = new TarArchiveEntry("test.txt");
    FileTime statusChangeTime = FileTime.fromMillis(System.currentTimeMillis());
    entry.setStatusChangeTime(statusChangeTime);
    outputStream.putArchiveEntry(entry);
    assertEquals(statusChangeTime, entry.getStatusChangeTime());
}
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
public void testPutArchiveEntryWithLastAccessTime_OQxM16() throws IOException {
    TarArchiveOutputStream outputStream = new TarArchiveOutputStream(new ByteArrayOutputStream());
    TarArchiveEntry entry = new TarArchiveEntry("test.txt");
    FileTime lastAccessTime = FileTime.fromMillis(System.currentTimeMillis());
    entry.setLastAccessTime(lastAccessTime);
    outputStream.putArchiveEntry(entry);
    assertEquals(lastAccessTime, entry.getLastAccessTime());
}
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
public void testPutArchiveEntryWithInvalidLinkName_AwQc17() throws IOException {
    TarArchiveOutputStream outputStream = new TarArchiveOutputStream(new ByteArrayOutputStream());
    TarArchiveEntry entry = new TarArchiveEntry("test.txt");
    entry.setLinkName(null);
    outputStream.putArchiveEntry(entry);
    assertNull(entry.getLinkName());
}
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
public void testPutArchiveEntryWithEmptyPaxHeaders_xVJW18() throws IOException {
    TarArchiveOutputStream outputStream = new TarArchiveOutputStream(new ByteArrayOutputStream());
    TarArchiveEntry entry = new TarArchiveEntry("test.txt");
    entry.clearExtraPaxHeaders();
    outputStream.putArchiveEntry(entry);
    assertTrue(entry.getExtraPaxHeaders().isEmpty());
}
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
public void testPutArchiveEntryWithGlobalPaxHeader_vmMi0() throws IOException {
    TarArchiveOutputStream outputStream = new TarArchiveOutputStream(new ByteArrayOutputStream());
    TarArchiveEntry entry = new TarArchiveEntry("test.txt");
    entry.setGlobalPaxHeader(true);
    entry.addPaxHeader("key", "value");
    outputStream.putArchiveEntry(entry);
    assertTrue(outputStream.haveUnclosedEntry);
}
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
public void testPutArchiveEntryWithLongName_calO1() throws IOException {
    TarArchiveOutputStream outputStream = new TarArchiveOutputStream(new ByteArrayOutputStream());
    TarArchiveEntry entry = new TarArchiveEntry("verylongfilename.txt");
    entry.setName("verylongfilename.txt");
    outputStream.putArchiveEntry(entry);
    assertEquals("verylongfilename.txt", outputStream.currName);
}
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
public void testPutArchiveEntryWithLink_NNfj2() throws IOException {
    TarArchiveOutputStream outputStream = new TarArchiveOutputStream(new ByteArrayOutputStream());
    TarArchiveEntry entry = new TarArchiveEntry("link.txt", (byte) 1);
    entry.setLinkName("target.txt");
    outputStream.putArchiveEntry(entry);
    assertTrue(outputStream.haveUnclosedEntry);
}
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
public void testPutArchiveEntryWithBigNumbers_jCCw3() throws IOException {
    TarArchiveOutputStream outputStream = new TarArchiveOutputStream(new ByteArrayOutputStream());
    TarArchiveEntry entry = new TarArchiveEntry("bigfile.txt");
    entry.setSize(TarConstants.MAXSIZE + 1);
    try {
        outputStream.putArchiveEntry(entry);
        fail("Expected IOException for big numbers");
    } catch (IOException e) {
        assertTrue(e.getMessage().contains("entry size"));
    }
}
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
public void testPutArchiveEntryWithPosixBigNumbers_UrGT4() throws IOException {
    TarArchiveOutputStream outputStream = new TarArchiveOutputStream(new ByteArrayOutputStream());
    outputStream.bigNumberMode = TarArchiveOutputStream.BIGNUMBER_POSIX;
    TarArchiveEntry entry = new TarArchiveEntry("posixbigfile.txt");
    entry.setSize(TarConstants.MAXSIZE + 1);
    outputStream.putArchiveEntry(entry);
    assertTrue(outputStream.haveUnclosedEntry);
}
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
public void testPutArchiveEntryWithNonAsciiName_wxJZ5() throws IOException {
    TarArchiveOutputStream outputStream = new TarArchiveOutputStream(new ByteArrayOutputStream());
    TarArchiveEntry entry = new TarArchiveEntry(".txt");
    outputStream.addPaxHeadersForNonAsciiNames = true;
    outputStream.putArchiveEntry(entry);
    assertTrue(outputStream.haveUnclosedEntry);
}
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
public void testPutArchiveEntryWithDirectory_FQTy6() throws IOException {
    TarArchiveOutputStream outputStream = new TarArchiveOutputStream(new ByteArrayOutputStream());
    TarArchiveEntry entry = new TarArchiveEntry("directory/");
    entry.setDirectory(true);
    outputStream.putArchiveEntry(entry);
    assertEquals(0, outputStream.currSize);
}
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
public void testPutArchiveEntryWithSymbolicLink_vwlr7() throws IOException {
    TarArchiveOutputStream outputStream = new TarArchiveOutputStream(new ByteArrayOutputStream());
    TarArchiveEntry entry = new TarArchiveEntry("symlink.txt", (byte) 2);
    entry.setLinkName("target.txt");
    outputStream.putArchiveEntry(entry);
    assertTrue(outputStream.haveUnclosedEntry);
}
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
public void testPutArchiveEntryWithEmptyPaxHeaders_BOEK8() throws IOException {
    TarArchiveOutputStream outputStream = new TarArchiveOutputStream(new ByteArrayOutputStream());
    TarArchiveEntry entry = new TarArchiveEntry("empty.txt");
    outputStream.putArchiveEntry(entry);
    assertFalse(entry.getExtraPaxHeaders().isEmpty());
}
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
public void testPutArchiveEntryWithInvalidLinkName_lvZD9() throws IOException {
    TarArchiveOutputStream outputStream = new TarArchiveOutputStream(new ByteArrayOutputStream());
    TarArchiveEntry entry = new TarArchiveEntry("invalidlink.txt");
    entry.setLinkName("");
    outputStream.putArchiveEntry(entry);
    assertTrue(outputStream.haveUnclosedEntry);
}
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
public void testPutArchiveEntryWithSparseFile_vITB10() throws IOException {
    TarArchiveOutputStream outputStream = new TarArchiveOutputStream(new ByteArrayOutputStream());
    TarArchiveEntry entry = new TarArchiveEntry("sparsefile.txt");
    entry.setSparse(true);
    outputStream.putArchiveEntry(entry);
    assertTrue(outputStream.haveUnclosedEntry);
}
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
public void testPutArchiveEntryWithCharacterDevice_AUwk11() throws IOException {
    TarArchiveOutputStream outputStream = new TarArchiveOutputStream(new ByteArrayOutputStream());
    TarArchiveEntry entry = new TarArchiveEntry("charDevice", (byte) 3);
    entry.setCharacterDevice(true);
    outputStream.putArchiveEntry(entry);
    assertTrue(outputStream.haveUnclosedEntry);
}
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
public void testPutArchiveEntryWithBlockDevice_atTZ12() throws IOException {
    TarArchiveOutputStream outputStream = new TarArchiveOutputStream(new ByteArrayOutputStream());
    TarArchiveEntry entry = new TarArchiveEntry("blockDevice", (byte) 4);
    entry.setBlockDevice(true);
    outputStream.putArchiveEntry(entry);
    assertTrue(outputStream.haveUnclosedEntry);
}
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
public void testPutArchiveEntryWithFIFO_NIjM13() throws IOException {
    TarArchiveOutputStream outputStream = new TarArchiveOutputStream(new ByteArrayOutputStream());
    TarArchiveEntry entry = new TarArchiveEntry("fifo", (byte) 5);
    entry.setFIFO(true);
    outputStream.putArchiveEntry(entry);
    assertTrue(outputStream.haveUnclosedEntry);
}
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
public void testPutArchiveEntryWithExtendedHeaders_GhMK14() throws IOException {
    TarArchiveOutputStream outputStream = new TarArchiveOutputStream(new ByteArrayOutputStream());
    TarArchiveEntry entry = new TarArchiveEntry("extended.txt");
    entry.addPaxHeader("extendedKey", "extendedValue");
    outputStream.putArchiveEntry(entry);
    assertTrue(outputStream.haveUnclosedEntry);
}
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
public void testPutArchiveEntryWithInvalidEntryAfterFinish_fkiK15() throws IOException {
    TarArchiveOutputStream outputStream = new TarArchiveOutputStream(new ByteArrayOutputStream());
    outputStream.finish();
    TarArchiveEntry entry = new TarArchiveEntry("afterFinish.txt");
    try {
        outputStream.putArchiveEntry(entry);
        fail("Expected IOException after finish");
    } catch (IOException e) {
        assertEquals("Stream has already been finished", e.getMessage());
    }
}
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
public void testPutArchiveEntryWithMultiplePaxHeaders_MyMi16() throws IOException {
    TarArchiveOutputStream outputStream = new TarArchiveOutputStream(new ByteArrayOutputStream());
    TarArchiveEntry entry = new TarArchiveEntry("multiplePax.txt");
    entry.addPaxHeader("key1", "value1");
    entry.addPaxHeader("key2", "value2");
    outputStream.putArchiveEntry(entry);
    assertTrue(outputStream.haveUnclosedEntry);
}
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
public void testPutArchiveEntryWithFileSizeZero_yjHF17() throws IOException {
    TarArchiveOutputStream outputStream = new TarArchiveOutputStream(new ByteArrayOutputStream());
    TarArchiveEntry entry = new TarArchiveEntry("emptyfile.txt");
    entry.setSize(0);
    outputStream.putArchiveEntry(entry);
    assertEquals(0, outputStream.currSize);
}
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
public void testPutArchiveEntryWithInvalidUserId_HFjP18() throws IOException {
    TarArchiveOutputStream outputStream = new TarArchiveOutputStream(new ByteArrayOutputStream());
    TarArchiveEntry entry = new TarArchiveEntry("invalidUserId.txt");
    entry.setUserId(TarConstants.MAXID + 1);
    try {
        outputStream.putArchiveEntry(entry);
        fail("Expected IOException for invalid user id");
    } catch (IOException e) {
        assertTrue(e.getMessage().contains("user id"));
    }
}
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
public void testPutArchiveEntryWithGlobalPaxHeader_cNIC0() throws IOException {
    ByteArrayOutputStream baos = new ByteArrayOutputStream();
    TarArchiveOutputStream tarOutputStream = new TarArchiveOutputStream(baos);
    TarArchiveEntry entry = new TarArchiveEntry("test.txt");
    entry.setGlobalPaxHeader(true);
    entry.addPaxHeader("key", "value");
    tarOutputStream.putArchiveEntry(entry);
    assertTrue(baos.size() > 0);
}
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
public void testPutArchiveEntryWithLongName_UyIk1() throws IOException {
    ByteArrayOutputStream baos = new ByteArrayOutputStream();
    TarArchiveOutputStream tarOutputStream = new TarArchiveOutputStream(baos);
    TarArchiveEntry entry = new TarArchiveEntry("very_long_file_name_that_exceeds_normal_length.txt");
    tarOutputStream.putArchiveEntry(entry);
    assertEquals(entry.getName(), "very_long_file_name_that_exceeds_normal_length.txt");
}
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
public void testPutArchiveEntryWithLink_gdSl2() throws IOException {
    ByteArrayOutputStream baos = new ByteArrayOutputStream();
    TarArchiveOutputStream tarOutputStream = new TarArchiveOutputStream(baos);
    TarArchiveEntry entry = new TarArchiveEntry("link.txt", (byte) 1);
    entry.setLinkName("target.txt");
    tarOutputStream.putArchiveEntry(entry);
    assertEquals(entry.getLinkName(), "target.txt");
}
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
public void testPutArchiveEntryWithBigNumbers_fIqX3() throws IOException {
    ByteArrayOutputStream baos = new ByteArrayOutputStream();
    TarArchiveOutputStream tarOutputStream = new TarArchiveOutputStream(baos);
    TarArchiveEntry entry = new TarArchiveEntry("big_numbers.txt");
    entry.setSize(Long.MAX_VALUE);
    entry.setLongGroupId(Long.MAX_VALUE);
    entry.setLongUserId(Long.MAX_VALUE);
    tarOutputStream.putArchiveEntry(entry);
    assertThrows(IOException.class, () -> tarOutputStream.failForBigNumbers(entry));
}
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
public void testPutArchiveEntryWithDirectory_sTFK5() throws IOException {
    ByteArrayOutputStream baos = new ByteArrayOutputStream();
    TarArchiveOutputStream tarOutputStream = new TarArchiveOutputStream(baos);
    TarArchiveEntry entry = new TarArchiveEntry("directory/");
    entry.setSize(0);
    tarOutputStream.putArchiveEntry(entry);
    assertEquals(entry.getSize(), 0);
}
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
public void testPutArchiveEntryWithSymbolicLink_EMtO6() throws IOException {
    ByteArrayOutputStream baos = new ByteArrayOutputStream();
    TarArchiveOutputStream tarOutputStream = new TarArchiveOutputStream(baos);
    TarArchiveEntry entry = new TarArchiveEntry("symlink.txt", (byte) 2);
    entry.setLinkName("target.txt");
    tarOutputStream.putArchiveEntry(entry);
    assertEquals(entry.getLinkName(), "target.txt");
}
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
public void testPutArchiveEntryWithEmptyPaxHeaders_QHKP7() throws IOException {
    ByteArrayOutputStream baos = new ByteArrayOutputStream();
    TarArchiveOutputStream tarOutputStream = new TarArchiveOutputStream(baos);
    TarArchiveEntry entry = new TarArchiveEntry("empty_pax.txt");
    tarOutputStream.putArchiveEntry(entry);
    assertTrue(baos.size() > 0);
}
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
public void testPutArchiveEntryWithFIFO_DxTQ8() throws IOException {
    ByteArrayOutputStream baos = new ByteArrayOutputStream();
    TarArchiveOutputStream tarOutputStream = new TarArchiveOutputStream(baos);
    TarArchiveEntry entry = new TarArchiveEntry("fifo_file", (byte) 6);
    tarOutputStream.putArchiveEntry(entry);
    assertTrue(entry.isFIFO());
}
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
public void testPutArchiveEntryWithCharacterDevice_HEpI9() throws IOException {
    ByteArrayOutputStream baos = new ByteArrayOutputStream();
    TarArchiveOutputStream tarOutputStream = new TarArchiveOutputStream(baos);
    TarArchiveEntry entry = new TarArchiveEntry("char_device", (byte) 2);
    tarOutputStream.putArchiveEntry(entry);
    assertTrue(entry.isCharacterDevice());
}
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
public void testPutArchiveEntryWithSparse_mAjT11() throws IOException {
    ByteArrayOutputStream baos = new ByteArrayOutputStream();
    TarArchiveOutputStream tarOutputStream = new TarArchiveOutputStream(baos);
    TarArchiveEntry entry = new TarArchiveEntry("sparse_file.txt");
    entry.setSparseHeaders(new ArrayList<>());
    tarOutputStream.putArchiveEntry(entry);
    assertTrue(entry.isSparse());
}
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
public void testPutArchiveEntryWithExtended_NzEJ12() throws IOException {
    ByteArrayOutputStream baos = new ByteArrayOutputStream();
    TarArchiveOutputStream tarOutputStream = new TarArchiveOutputStream(baos);
    TarArchiveEntry entry = new TarArchiveEntry("extended_file.txt");
    entry.setExtended(true);
    tarOutputStream.putArchiveEntry(entry);
    assertTrue(entry.isExtended());
}
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
public void testPutArchiveEntryWithInvalidEntryAfterFinish_Ogey13() throws IOException {
    ByteArrayOutputStream baos = new ByteArrayOutputStream();
    TarArchiveOutputStream tarOutputStream = new TarArchiveOutputStream(baos);
    tarOutputStream.finish();
    TarArchiveEntry entry = new TarArchiveEntry("test.txt");
    assertThrows(IOException.class, () -> tarOutputStream.putArchiveEntry(entry));
}
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
public void testPutArchiveEntryWithNullEntry_qDkU14() throws IOException {
    ByteArrayOutputStream baos = new ByteArrayOutputStream();
    TarArchiveOutputStream tarOutputStream = new TarArchiveOutputStream(baos);
    assertThrows(NullPointerException.class, () -> tarOutputStream.putArchiveEntry(null));
}
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
public void testPutArchiveEntryWithEmptyName_vOUx15() throws IOException {
    ByteArrayOutputStream baos = new ByteArrayOutputStream();
    TarArchiveOutputStream tarOutputStream = new TarArchiveOutputStream(baos);
    TarArchiveEntry entry = new TarArchiveEntry("");
    assertThrows(IOException.class, () -> tarOutputStream.putArchiveEntry(entry));
}
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
public void testPutArchiveEntryWithInvalidLinkName_CZzJ16() throws IOException {
    ByteArrayOutputStream baos = new ByteArrayOutputStream();
    TarArchiveOutputStream tarOutputStream = new TarArchiveOutputStream(baos);
    TarArchiveEntry entry = new TarArchiveEntry("link.txt", (byte) 1);
    entry.setLinkName("");
    assertThrows(IOException.class, () -> tarOutputStream.putArchiveEntry(entry));
}
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
public void testPutArchiveEntryWithInvalidSize_fDSr17() throws IOException {
    ByteArrayOutputStream baos = new ByteArrayOutputStream();
    TarArchiveOutputStream tarOutputStream = new TarArchiveOutputStream(baos);
    TarArchiveEntry entry = new TarArchiveEntry("invalid_size.txt");
    entry.setSize(-1);
    assertThrows(IOException.class, () -> tarOutputStream.putArchiveEntry(entry));
}
}