/**
 * Generated by Aster
 */
package org.apache.commons.compress.archivers.zip;
import java.io.File;
import java.io.IOException;
import java.nio.file.Files;
import java.nio.file.LinkOption;
import java.nio.file.Path;
import java.nio.file.attribute.BasicFileAttributes;
import java.nio.file.attribute.FileTime;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Date;
import java.util.LinkedList;
import java.util.List;
import java.util.NoSuchElementException;
import java.util.Objects;
import java.util.function.Function;
import java.util.zip.ZipEntry;
import java.util.zip.ZipException;
import org.apache.commons.compress.archivers.ArchiveEntry;
import org.apache.commons.compress.archivers.EntryStreamOffsets;
import org.apache.commons.compress.utils.ByteUtils;
import org.apache.commons.compress.utils.TimeUtils;
import org.apache.commons.compress.compressors.lz77support.Parameters;
import org.apache.commons.compress.archivers.zip.ZipEightByteInteger;
import org.apache.commons.compress.harmony.unpack200.bytecode.RuntimeVisibleorInvisibleAnnotationsAttribute;
import org.apache.commons.compress.archivers.sevenz.Archive;
import org.apache.commons.compress.archivers.ar.ArArchiveEntry;
import org.apache.commons.compress.compressors.bzip2.BlockSort;
import org.apache.commons.compress.archivers.zip.ZipArchiveEntryRequestSupplier;
import org.apache.commons.compress.archivers.cpio.CpioArchiveInputStream;
import org.apache.commons.compress.compressors.CompressorException;
import org.apache.commons.compress.archivers.zip.ZipFile;
import org.apache.commons.compress.compressors.deflate64.Deflate64CompressorInputStream;
import org.apache.commons.compress.compressors.brotli.BrotliCompressorInputStream;
import org.apache.commons.compress.archivers.dump.DumpArchiveUtil;
import org.apache.commons.compress.compressors.bzip2.CRC;
import org.apache.commons.compress.archivers.zip.UnicodePathExtraField;
import org.apache.commons.compress.utils.IOUtils;
import org.apache.commons.compress.harmony.unpack200.bytecode.forms.ByteForm;
import org.apache.commons.compress.harmony.unpack200.bytecode.forms.IMethodRefForm;
import org.apache.commons.compress.archivers.examples.CloseableConsumer;
import org.apache.commons.compress.compressors.CompressorInputStream;
import org.apache.commons.compress.harmony.unpack200.bytecode.forms.LookupSwitchForm;
import org.apache.commons.compress.harmony.unpack200.bytecode.forms.LocalForm;
import org.apache.commons.compress.archivers.dump.TapeInputStream;
import org.apache.commons.compress.archivers.zip.Zip64Mode;
import org.apache.commons.compress.harmony.unpack200.bytecode.ByteCode;
import org.apache.commons.compress.compressors.gzip.GzipParameters;
import org.apache.commons.compress.harmony.unpack200.CpBands;
import org.apache.commons.compress.archivers.tar.TarArchiveSparseZeroInputStream;
import org.apache.commons.compress.harmony.unpack200.bytecode.DeprecatedAttribute;
import org.apache.commons.compress.harmony.unpack200.bytecode.NewAttribute;
import org.apache.commons.compress.archivers.zip.PKWareExtraHeader;
import org.apache.commons.compress.archivers.arj.MainHeader;
import org.apache.commons.compress.archivers.sevenz.NID;
import org.apache.commons.compress.compressors.lz4.FramedLZ4CompressorInputStream;
import org.apache.commons.compress.harmony.unpack200.ClassBands;
import org.apache.commons.compress.archivers.zip.ZipEncodingHelper;
import org.apache.commons.compress.archivers.zip.ExtraFieldUtils;
import org.apache.commons.compress.harmony.unpack200.bytecode.forms.MultiANewArrayForm;
import org.apache.commons.compress.harmony.pack200.CPSignature;
import org.apache.commons.compress.compressors.pack200.Pack200Utils;
import org.apache.commons.compress.compressors.deflate.DeflateCompressorOutputStream;
import org.apache.commons.compress.harmony.unpack200.bytecode.forms.SingleByteReferenceForm;
import org.apache.commons.compress.archivers.zip.X000A_NTFS;
import org.apache.commons.compress.archivers.zip.SeekableChannelRandomAccessOutputStream;
import org.apache.commons.compress.parallel.FileBasedScatterGatherBackingStore;
import org.apache.commons.compress.archivers.sevenz.StartHeader;
import org.apache.commons.compress.utils.Sets;
import org.apache.commons.compress.utils.Iterators;
import org.apache.commons.compress.archivers.zip.ZipSplitReadOnlySeekableByteChannel;
import org.apache.commons.compress.archivers.zip.UnsupportedZipFeatureException;
import org.apache.commons.compress.archivers.ar.ArArchiveOutputStream;
import org.apache.commons.compress.harmony.unpack200.bytecode.LocalVariableTypeTableAttribute;
import org.apache.commons.compress.utils.CountingInputStream;
import org.apache.commons.compress.harmony.unpack200.SegmentUtils;
import org.apache.commons.compress.harmony.unpack200.bytecode.forms.ThisMethodRefForm;
import org.apache.commons.compress.archivers.zip.BitStream;
import org.apache.commons.compress.archivers.ArchiveInputStream;
import org.apache.commons.compress.compressors.deflate64.HuffmanState;
import org.apache.commons.compress.compressors.CompressorStreamFactory;
import org.apache.commons.compress.archivers.arj.ArjArchiveEntry;
import org.apache.commons.compress.compressors.lzma.LZMACompressorInputStream;
import org.apache.commons.compress.utils.ArchiveUtils;
import org.apache.commons.compress.utils.ChecksumCalculatingInputStream;
import org.apache.commons.compress.compressors.snappy.SnappyCompressorOutputStream;
import org.apache.commons.compress.harmony.pack200.MetadataBandGroup;
import org.apache.commons.compress.archivers.Lister;
import org.apache.commons.compress.harmony.pack200.Codec;
import org.apache.commons.compress.harmony.pack200.CPNameAndType;
import org.apache.commons.compress.archivers.arj.ArjArchiveInputStream;
import org.apache.commons.compress.archivers.dump.DumpArchiveInputStream;
import org.apache.commons.compress.compressors.lz4.BlockLZ4CompressorInputStream;
import org.apache.commons.compress.archivers.sevenz.SevenZArchiveEntry;
import org.apache.commons.compress.harmony.unpack200.bytecode.CPNameAndType;
import org.apache.commons.compress.archivers.sevenz.BoundedSeekableByteChannelInputStream;
import org.apache.commons.compress.archivers.zip.InflaterInputStreamWithStatistics;
import org.apache.commons.compress.utils.ByteUtils;
import org.apache.commons.compress.archivers.zip.ParallelScatterZipCreator;
import org.apache.commons.compress.archivers.zip.UnparseableExtraFieldData;
import org.apache.commons.compress.utils.ServiceLoaderIterator;
import org.apache.commons.compress.archivers.zip.ZipArchiveEntry;
import org.apache.commons.compress.compressors.pack200.Pack200CompressorInputStream;
import org.apache.commons.compress.archivers.cpio.CpioConstants;
import org.apache.commons.compress.harmony.unpack200.bytecode.Attribute;
import org.apache.commons.compress.harmony.pack200.CPClass;
import org.apache.commons.compress.harmony.unpack200.bytecode.AnnotationsAttribute;
import org.apache.commons.compress.utils.SeekableInMemoryByteChannel;
import org.apache.commons.compress.harmony.unpack200.bytecode.CPConstant;
import org.apache.commons.compress.harmony.unpack200.bytecode.forms.ShortForm;
import org.apache.commons.compress.archivers.sevenz.AES256Options;
import org.apache.commons.compress.compressors.zstandard.ZstdCompressorInputStream;
import org.apache.commons.compress.archivers.zip.BinaryTree;
import org.apache.commons.compress.harmony.pack200.FileBands;
import org.apache.commons.compress.utils.CRC32VerifyingInputStream;
import org.apache.commons.compress.harmony.unpack200.bytecode.EnclosingMethodAttribute;
import org.apache.commons.compress.archivers.zip.ZipArchiveEntryPredicate;
import org.apache.commons.compress.archivers.sevenz.StreamMap;
import org.apache.commons.compress.archivers.sevenz.CLI;
import org.apache.commons.compress.harmony.unpack200.bytecode.forms.NewClassRefForm;
import org.apache.commons.compress.compressors.zstandard.ZstdCompressorOutputStream;
import org.apache.commons.compress.archivers.zip.X0017_StrongEncryptionHeader;
import org.apache.commons.compress.utils.BitInputStream;
import org.apache.commons.compress.utils.TimeUtils;
import org.apache.commons.compress.compressors.lzw.LZWInputStream;
import org.apache.commons.compress.harmony.unpack200.bytecode.CPClass;
import org.apache.commons.compress.archivers.zip.UnrecognizedExtraField;
import org.apache.commons.compress.harmony.unpack200.bytecode.LineNumberTableAttribute;
import org.apache.commons.compress.compressors.bzip2.BZip2Constants;
import org.apache.commons.compress.harmony.pack200.AttributeDefinitionBands;
import org.apache.commons.compress.utils.FixedLengthBlockOutputStream;
import org.apache.commons.compress.archivers.cpio.CpioArchiveEntry;
import org.apache.commons.compress.harmony.unpack200.bytecode.forms.StringRefForm;
import org.apache.commons.compress.harmony.pack200.CPConstant;
import org.apache.commons.compress.archivers.zip.ZipArchiveOutputStream;
import org.apache.commons.compress.archivers.jar.JarArchiveInputStream;
import org.apache.commons.compress.harmony.unpack200.bytecode.ConstantValueAttribute;
import org.apache.commons.compress.harmony.pack200.Archive;
import org.apache.commons.compress.compressors.deflate.DeflateCompressorInputStream;
import org.apache.commons.compress.archivers.examples.CloseableConsumerAdapter;
import org.apache.commons.compress.harmony.pack200.RunCodec;
import org.apache.commons.compress.harmony.pack200.CpBands;
import org.apache.commons.compress.utils.BoundedSeekableByteChannelInputStream;
import org.apache.commons.compress.harmony.unpack200.bytecode.forms.ByteCodeForm;
import org.apache.commons.compress.archivers.ArchiveOutputStream;
import org.apache.commons.compress.MemoryLimitException;
import org.apache.commons.compress.compressors.lz77support.AbstractLZ77CompressorInputStream;
import org.apache.commons.compress.harmony.unpack200.Archive;
import org.apache.commons.compress.harmony.unpack200.bytecode.CPLong;
import org.apache.commons.compress.archivers.zip.ScatterStatistics;
import org.apache.commons.compress.java.util.jar.Pack200;
import org.apache.commons.compress.archivers.tar.TarArchiveInputStream;
import org.apache.commons.compress.harmony.unpack200.bytecode.ExceptionTableEntry;
import org.apache.commons.compress.utils.OsgiUtils;
import org.apache.commons.compress.harmony.unpack200.SegmentConstantPool;
import org.apache.commons.compress.archivers.tar.TarArchiveEntry;
import org.apache.commons.compress.archivers.sevenz.LZMA2Decoder;
import org.apache.commons.compress.harmony.unpack200.bytecode.forms.FloatRefForm;
import org.apache.commons.compress.archivers.dump.Dirent;
import org.apache.commons.compress.harmony.unpack200.bytecode.CPMethod;
import org.apache.commons.compress.archivers.sevenz.BindPair;
import org.apache.commons.compress.harmony.unpack200.bytecode.forms.MethodRefForm;
import org.apache.commons.compress.archivers.sevenz.LZMADecoder;
import org.apache.commons.compress.harmony.unpack200.bytecode.CPFieldRef;
import org.apache.commons.compress.archivers.jar.JarArchiveOutputStream;
import org.apache.commons.compress.compressors.xz.XZCompressorInputStream;
import org.apache.commons.compress.utils.ExactMath;
import org.apache.commons.compress.harmony.unpack200.AttributeLayoutMap;
import org.apache.commons.compress.harmony.unpack200.bytecode.CPMember;
import org.apache.commons.compress.changes.ChangeSetResults;
import org.apache.commons.compress.harmony.pack200.CPInt;
import org.apache.commons.compress.harmony.unpack200.bytecode.ExceptionsAttribute;
import org.apache.commons.compress.archivers.tar.TarArchiveOutputStream;
import org.apache.commons.compress.archivers.zip.Zip64ExtendedInformationExtraField;
import org.apache.commons.compress.harmony.unpack200.bytecode.BCIRenumberedAttribute;
import org.apache.commons.compress.compressors.snappy.FramedSnappyCompressorInputStream;
import org.apache.commons.compress.parallel.ScatterGatherBackingStore;
import org.apache.commons.compress.archivers.zip.X0016_CertificateIdForCentralDirectory;
import org.apache.commons.compress.archivers.tar.TarConstants;
import org.apache.commons.compress.harmony.unpack200.bytecode.forms.SuperMethodRefForm;
import org.apache.commons.compress.harmony.unpack200.bytecode.CPInteger;
import org.apache.commons.compress.harmony.pack200.PackingUtils;
import org.apache.commons.compress.parallel.InputStreamSupplier;
import org.apache.commons.compress.harmony.unpack200.Segment;
import org.apache.commons.compress.archivers.zip.RandomAccessOutputStream;
import org.apache.commons.compress.harmony.unpack200.bytecode.CPMethodRef;
import org.apache.commons.compress.harmony.archive.internal.nls.Messages;
import org.apache.commons.compress.harmony.unpack200.bytecode.forms.ClassRefForm;
import org.apache.commons.compress.harmony.unpack200.bytecode.OperandManager;
import org.apache.commons.compress.harmony.unpack200.bytecode.forms.FieldRefForm;
import org.apache.commons.compress.harmony.unpack200.bytecode.LocalVariableTableAttribute;
import org.apache.commons.compress.archivers.sevenz.AbstractCoder;
import org.apache.commons.compress.harmony.unpack200.IMatcher;
import org.apache.commons.compress.harmony.unpack200.bytecode.forms.SwitchForm;
import org.apache.commons.compress.harmony.unpack200.bytecode.forms.LabelForm;
import org.apache.commons.compress.harmony.pack200.BHSDCodec;
import org.apache.commons.compress.archivers.zip.ZipShort;
import org.apache.commons.compress.harmony.unpack200.AttrDefinitionBands;
import org.apache.commons.compress.harmony.unpack200.bytecode.forms.DoubleForm;
import org.apache.commons.compress.harmony.unpack200.SegmentOptions;
import org.apache.commons.compress.archivers.zip.ZipArchiveInputStream;
import org.apache.commons.compress.archivers.dump.DumpArchiveConstants;
import org.apache.commons.compress.archivers.zip.AsiExtraField;
import org.apache.commons.compress.harmony.unpack200.bytecode.CPString;
import org.apache.commons.compress.harmony.pack200.CPString;
import org.apache.commons.compress.archivers.examples.Expander;
import org.apache.commons.compress.harmony.unpack200.bytecode.CPUTF8;
import org.apache.commons.compress.harmony.unpack200.bytecode.CPConstantNumber;
import org.apache.commons.compress.compressors.pack200.Pack200CompressorOutputStream;
import org.apache.commons.compress.compressors.pack200.InMemoryCachingStreamBridge;
import org.apache.commons.compress.harmony.unpack200.bytecode.forms.TableSwitchForm;
import org.apache.commons.compress.compressors.lz77support.LZ77Compressor;
import org.apache.commons.compress.changes.ChangeSetPerformer;
import org.apache.commons.compress.archivers.tar.TarUtils;
import org.apache.commons.compress.archivers.ArchiveStreamFactory;
import org.apache.commons.compress.archivers.ar.ArArchiveInputStream;
import org.apache.commons.compress.compressors.snappy.FramedSnappyDialect;
import org.apache.commons.compress.changes.ChangeSet;
import org.apache.commons.compress.archivers.EntryStreamOffsets;
import org.apache.commons.compress.harmony.pack200.PopulationCodec;
import org.apache.commons.compress.utils.CharsetNames;
import org.apache.commons.compress.compressors.bzip2.Rand;
import org.apache.commons.compress.harmony.unpack200.bytecode.forms.ClassSpecificReferenceForm;
import org.apache.commons.compress.archivers.sevenz.SevenZOutputFile;
import org.apache.commons.compress.harmony.pack200.CPLong;
import org.apache.commons.compress.archivers.zip.Zip64RequiredException;
import org.apache.commons.compress.archivers.sevenz.Folder;
import org.apache.commons.compress.harmony.unpack200.bytecode.ClassConstantPool;
import org.apache.commons.compress.harmony.unpack200.IcBands;
import org.apache.commons.compress.compressors.z.ZCompressorInputStream;
import org.apache.commons.compress.archivers.sevenz.SevenZMethodConfiguration;
import org.apache.commons.compress.compressors.lz4.BlockLZ4CompressorOutputStream;
import org.apache.commons.compress.compressors.CompressorStreamProvider;
import org.apache.commons.compress.harmony.unpack200.bytecode.forms.SuperFieldRefForm;
import org.apache.commons.compress.harmony.unpack200.bytecode.ConstantPoolEntry;
import org.apache.commons.compress.archivers.zip.ZipConstants;
import org.apache.commons.compress.harmony.pack200.PackingOptions;
import org.apache.commons.compress.archivers.tar.TarArchiveStructSparse;
import org.apache.commons.compress.archivers.zip.JarMarker;
import org.apache.commons.compress.harmony.unpack200.bytecode.forms.LongForm;
import org.apache.commons.compress.archivers.zip.X5455_ExtendedTimestamp;
import org.apache.commons.compress.harmony.pack200.CanonicalCodecFamilies;
import org.apache.commons.compress.archivers.zip.CircularBuffer;
import org.apache.commons.compress.harmony.unpack200.bytecode.forms.ReferenceForm;
import org.apache.commons.compress.harmony.pack200.NewAttribute;
import org.apache.commons.compress.harmony.unpack200.BandSet;
import org.apache.commons.compress.compressors.bzip2.BZip2CompressorInputStream;
import org.apache.commons.compress.archivers.zip.ZipMethod;
import org.apache.commons.compress.harmony.unpack200.bytecode.forms.InitMethodReferenceForm;
import org.apache.commons.compress.compressors.snappy.SnappyCompressorInputStream;
import org.apache.commons.compress.archivers.tar.TarArchiveSparseEntry;
import org.apache.commons.compress.utils.FileNameUtils;
import org.apache.commons.compress.harmony.unpack200.SegmentConstantPoolArrayCache;
import org.apache.commons.compress.utils.CloseShieldFilterInputStream;
import org.apache.commons.compress.utils.BoundedArchiveInputStream;
import org.apache.commons.compress.compressors.brotli.BrotliUtils;
import org.apache.commons.compress.harmony.pack200.Segment;
import org.apache.commons.compress.compressors.gzip.GzipCompressorInputStream;
import org.apache.commons.compress.harmony.unpack200.bytecode.CPField;
import org.apache.commons.compress.archivers.ArchiveEntry;
import org.apache.commons.compress.archivers.dump.ShortFileException;
import org.apache.commons.compress.compressors.CompressorOutputStream;
import org.apache.commons.compress.compressors.lzma.LZMACompressorOutputStream;
import org.apache.commons.compress.compressors.bzip2.BZip2Utils;
import org.apache.commons.compress.compressors.zstandard.ZstdUtils;
import org.apache.commons.compress.archivers.zip.NioZipEncoding;
import org.apache.commons.compress.compressors.pack200.AbstractStreamBridge;
import org.apache.commons.compress.compressors.xz.XZUtils;
import org.apache.commons.compress.utils.Charsets;
import org.apache.commons.compress.harmony.unpack200.bytecode.forms.NoArgumentForm;
import org.apache.commons.compress.archivers.zip.UnshrinkingInputStream;
import org.apache.commons.compress.harmony.unpack200.bytecode.forms.ThisFieldRefForm;
import org.apache.commons.compress.utils.ChecksumVerifyingInputStream;
import org.apache.commons.compress.compressors.snappy.FramedSnappyCompressorOutputStream;
import org.apache.commons.compress.harmony.unpack200.bytecode.forms.NarrowClassRefForm;
import org.apache.commons.compress.archivers.dump.DumpArchiveException;
import org.apache.commons.compress.archivers.sevenz.SubStreamsInfo;
import org.apache.commons.compress.harmony.unpack200.bytecode.SourceFileAttribute;
import org.apache.commons.compress.archivers.zip.GeneralPurposeBit;
import org.apache.commons.compress.compressors.pack200.TempFileCachingStreamBridge;
import org.apache.commons.compress.archivers.sevenz.SevenZMethod;
import org.apache.commons.compress.harmony.pack200.SegmentHeader;
import org.apache.commons.compress.compressors.lz4.FramedLZ4CompressorOutputStream;
import org.apache.commons.compress.harmony.pack200.BcBands;
import org.apache.commons.compress.harmony.pack200.CPFloat;
import org.apache.commons.compress.compressors.pack200.Pack200Strategy;
import org.apache.commons.compress.harmony.unpack200.bytecode.CodeAttribute;
import org.apache.commons.compress.archivers.zip.ZipExtraField;
import org.apache.commons.compress.archivers.jar.JarArchiveEntry;
import org.apache.commons.compress.harmony.unpack200.bytecode.ClassFileEntry;
import org.apache.commons.compress.harmony.pack200.CPUTF8;
import org.apache.commons.compress.harmony.pack200.IntList;
import org.apache.commons.compress.harmony.unpack200.bytecode.forms.VariableInstructionForm;
import org.apache.commons.compress.archivers.zip.ZipLong;
import org.apache.commons.compress.harmony.pack200.BandSet;
import org.apache.commons.compress.harmony.pack200.IcBands;
import org.apache.commons.compress.archivers.sevenz.AES256SHA256Decoder;
import org.apache.commons.compress.harmony.unpack200.NewAttributeBands;
import org.apache.commons.compress.changes.Change;
import org.apache.commons.compress.utils.Lists;
import org.apache.commons.compress.PasswordRequiredException;
import org.apache.commons.compress.harmony.unpack200.bytecode.AnnotationDefaultAttribute;
import org.apache.commons.compress.harmony.unpack200.bytecode.forms.IntRefForm;
import org.apache.commons.compress.archivers.zip.ExtraFieldParsingBehavior;
import org.apache.commons.compress.archivers.sevenz.SevenZFile;
import org.apache.commons.compress.archivers.zip.FileRandomAccessOutputStream;
import org.apache.commons.compress.archivers.dump.DumpArchiveEntry;
import org.apache.commons.compress.harmony.pack200.Pack200ClassReader;
import org.apache.commons.compress.harmony.pack200.NewAttributeBands;
import org.apache.commons.compress.compressors.deflate64.HuffmanDecoder;
import org.apache.commons.compress.compressors.deflate.DeflateParameters;
import org.apache.commons.compress.archivers.sevenz.SevenZFileOptions;
import org.apache.commons.compress.harmony.pack200.CPDouble;
import org.apache.commons.compress.archivers.dump.UnrecognizedFormatException;
import org.apache.commons.compress.utils.CountingOutputStream;
import org.apache.commons.compress.utils.InputStreamStatistics;
import org.apache.commons.compress.compressors.xz.XZCompressorOutputStream;
import org.apache.commons.compress.archivers.zip.UnparseableExtraFieldBehavior;
import org.apache.commons.compress.harmony.unpack200.bytecode.SignatureAttribute;
import org.apache.commons.compress.harmony.unpack200.Pack200UnpackerAdapter;
import org.apache.commons.compress.compressors.FileNameUtil;
import org.apache.commons.compress.archivers.zip.X7875_NewUnix;
import org.apache.commons.compress.archivers.tar.TarGnuSparseKeys;
import org.apache.commons.compress.utils.FlushShieldFilterOutputStream;
import org.apache.commons.compress.parallel.ScatterGatherBackingStoreSupplier;
import org.apache.commons.compress.archivers.ArchiveException;
import org.apache.commons.compress.harmony.unpack200.bytecode.forms.WideForm;
import org.apache.commons.compress.harmony.unpack200.bytecode.forms.ThisInitMethodRefForm;
import org.apache.commons.compress.archivers.tar.TarFile;
import org.apache.commons.compress.archivers.dump.InvalidFormatException;
import org.apache.commons.compress.harmony.unpack200.IcTuple;
import org.apache.commons.compress.harmony.unpack200.AttributeLayout;
import org.apache.commons.compress.harmony.unpack200.bytecode.CPRef;
import org.apache.commons.compress.archivers.sevenz.Coders;
import org.apache.commons.compress.archivers.zip.ScatterZipOutputStream;
import org.apache.commons.compress.archivers.arj.LocalFileHeader;
import org.apache.commons.compress.utils.ParsingUtils;
import org.apache.commons.compress.archivers.zip.CharsetAccessor;
import org.apache.commons.compress.archivers.dump.UnsupportedCompressionAlgorithmException;
import org.apache.commons.compress.archivers.zip.DefaultBackingStoreSupplier;
import org.apache.commons.compress.compressors.bzip2.BZip2CompressorOutputStream;
import org.apache.commons.compress.harmony.unpack200.bytecode.RuntimeVisibleorInvisibleParameterAnnotationsAttribute;
import org.apache.commons.compress.compressors.gzip.GzipCompressorOutputStream;
import org.apache.commons.compress.archivers.cpio.CpioArchiveOutputStream;
import org.apache.commons.compress.harmony.unpack200.bytecode.ClassFile;
import org.apache.commons.compress.archivers.zip.ZipSplitOutputStream;
import org.apache.commons.compress.harmony.pack200.Pack200PackerAdapter;
import org.apache.commons.compress.archivers.zip.UnicodeCommentExtraField;
import org.apache.commons.compress.archivers.sevenz.Coder;
import org.apache.commons.compress.archivers.StreamingNotSupportedException;
import org.apache.commons.compress.archivers.dump.DumpArchiveSummary;
import org.apache.commons.compress.compressors.lz4.XXHash32;
import org.apache.commons.compress.archivers.ArchiveStreamProvider;
import org.apache.commons.compress.harmony.pack200.CodecEncoding;
import org.apache.commons.compress.harmony.unpack200.bytecode.forms.NewInitMethodRefForm;
import org.apache.commons.compress.archivers.zip.ResourceAlignmentExtraField;
import org.apache.commons.compress.archivers.zip.X0019_EncryptionRecipientCertificateList;
import org.apache.commons.compress.compressors.gzip.GzipUtils;
import org.apache.commons.compress.harmony.unpack200.MetadataBandGroup;
import org.apache.commons.compress.archivers.zip.UnixStat;
import org.apache.commons.compress.archivers.zip.ExplodingInputStream;
import org.apache.commons.compress.archivers.zip.X0014_X509Certificates;
import org.apache.commons.compress.archivers.zip.AbstractUnicodeExtraField;
import org.apache.commons.compress.harmony.unpack200.bytecode.CPInterfaceMethodRef;
import org.apache.commons.compress.harmony.unpack200.bytecode.forms.IincForm;
import org.apache.commons.compress.utils.BoundedInputStream;
import org.apache.commons.compress.harmony.pack200.ConstantPoolEntry;
import org.apache.commons.compress.archivers.zip.StreamCompressor;
import org.apache.commons.compress.harmony.pack200.CPMethodOrField;
import org.apache.commons.compress.harmony.unpack200.bytecode.forms.SuperInitMethodRefForm;
import org.apache.commons.compress.archivers.zip.X0015_CertificateIdForFile;
import org.apache.commons.compress.harmony.unpack200.bytecode.InnerClassesAttribute;
import org.apache.commons.compress.archivers.zip.ZipArchiveEntryRequest;
import org.apache.commons.compress.compressors.lzma.LZMAUtils;
import org.apache.commons.compress.harmony.unpack200.BcBands;
import org.apache.commons.compress.utils.MultiReadOnlySeekableByteChannel;
import org.apache.commons.compress.harmony.pack200.ClassBands;
import org.apache.commons.compress.harmony.pack200.Pack200Exception;
import org.apache.commons.compress.archivers.zip.ZipIoUtil;
import org.apache.commons.compress.harmony.unpack200.bytecode.CPFloat;
import org.apache.commons.compress.utils.SkipShieldingInputStream;
import org.apache.commons.compress.archivers.zip.ZipEncoding;
import org.apache.commons.compress.archivers.examples.Archiver;
import org.apache.commons.compress.harmony.unpack200.SegmentHeader;
import org.apache.commons.compress.harmony.unpack200.FileBands;
import org.apache.commons.compress.archivers.zip.ZipUtil;
import org.apache.commons.compress.harmony.pack200.Pack200Adapter;
import org.apache.commons.compress.harmony.unpack200.bytecode.CPDouble;
import org.apache.commons.compress.archivers.sevenz.DeltaDecoder;
import org.apache.commons.compress.archivers.cpio.CpioUtil;
import static org.junit.jupiter.api.Assertions.*;
import java.util.*;
import org.junit.jupiter.api.*;
import java.util.concurrent.TimeUnit;
import static org.mockito.Mockito.when;
import static org.mockito.Mockito.*;
import static org.junit.jupiter.api.Timeout.ThreadMode.SEPARATE_THREAD;
import org.junit.jupiter.api.extension.ExtendWith;
import org.mockito.junit.jupiter.MockitoSettings;
import org.mockito.quality.Strictness;
import org.mockito.InjectMocks;
import org.mockito.*;
import org.mockito.Mockito;
import java.sql.*;
import org.mockito.MockitoAnnotations;
import org.mockito.junit.MockitoJUnitRunner;
import org.mockito.junit.jupiter.MockitoExtension;
import static org.mockito.Mockito.*;
import java.lang.reflect.Field;
import org.springframework.mock.web.MockHttpServletRequest;
import org.springframework.mock.web.MockHttpServletResponse; 
import static org.junit.jupiter.api.Assertions.*;
import java.util.*;
import org.junit.jupiter.api.*;
import java.util.concurrent.TimeUnit;
import static org.mockito.Mockito.when;
import static org.mockito.Mockito.*;
import static org.junit.jupiter.api.Timeout.ThreadMode.SEPARATE_THREAD;
import org.junit.jupiter.api.extension.ExtendWith;
import org.mockito.junit.jupiter.MockitoSettings;
import org.mockito.quality.Strictness;
import org.mockito.InjectMocks;
import org.mockito.*;
import org.mockito.Mockito;
import java.sql.*;
import org.mockito.MockitoAnnotations;
import org.mockito.junit.MockitoJUnitRunner;
import org.mockito.junit.jupiter.MockitoExtension;
import static org.mockito.Mockito.*;
import java.lang.reflect.Field;
import org.springframework.mock.web.MockHttpServletRequest;
import org.springframework.mock.web.MockHttpServletResponse;   
@ExtendWith(MockitoExtension.class)
@MockitoSettings(strictness = Strictness.LENIENT)
public class Aster_ZipArchiveEntry_Test_Passing {
private int versionRequired;
ZipArchiveEntry ziparchiveentry;
private GeneralPurposeBit generalPurposeBit;
private static final int PLATFORM_FAT = 0;
private static final int PLATFORM_UNIX = 1;
private static final int SHORT_SHIFT = 16;
private long externalAttributes;
private long localHeaderOffset = OFFSET_UNKNOWN;
private GeneralPurposeBit generalPurposeBit = new GeneralPurposeBit();
private long dataOffset = OFFSET_UNKNOWN;
ZipArchiveEntry zipArchiveEntry1;
ZipArchiveEntry zipArchiveEntry2;
private UnparseableExtraFieldData unparseableExtra;
private int internalAttributes;
private int rawFlag;
private long time = -1;
private long diskNumberStart;
private CommentSource commentSource = CommentSource.COMMENT;
private String name;
private byte[] rawName;
private int alignment;
private static final long OFFSET_UNKNOWN = -1L;
private ZipExtraField[] extraFields;
private static final long SIZE_UNKNOWN = -1;
private long size = SIZE_UNKNOWN;
private static final int PLATFORM_UNIX = 3;
private int versionMadeBy;
private NameSource nameSource = NameSource.NAME;
private int method = ZipMethod.UNKNOWN_CODE;
ZipExtraField mockExtraField;
ZipShort mockZipShort;
private static String ZIP_DIR_SEP = "/";
private static final int EXTERNAL_ATTRIBUTES = 0x12345678;
private static final int SHORT_MASK = 0xFFFF;
ExtraFieldParsingBehavior parsingBehavior;
private boolean isStreamContiguous;
    private int platform = PLATFORM_FAT;
@Test(expected = IllegalArgumentException.class)
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
public void testSetSizeNegative_mcSF1() {
    ZipArchiveEntry entry = new ZipArchiveEntry("testEntry");
    entry.setSize(-1);
}
    private boolean isStreamContiguous;
    private int platform = PLATFORM_FAT;
    private long localHeaderOffset = OFFSET_UNKNOWN;
@Test(expected = IllegalArgumentException.class)
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
public void testSetCentralDirectoryExtra_InvalidInput_DMun1() {
    ZipArchiveEntry entry = new ZipArchiveEntry("testEntry");
    byte[] invalidExtraFields = null; // Example of invalid input
    entry.setCentralDirectoryExtra(invalidExtraFields);
}
@Test(expected = IllegalArgumentException.class)
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
public void testSetExtraWithInvalidData_Wwdc1() {
    ZipArchiveEntry entry = new ZipArchiveEntry("testEntry");
    byte[] extra = null; // Invalid input
    entry.setExtra(extra);
}
@Test(expected = IllegalArgumentException.class)
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
public void testSetExtraWithMalformedData_IaHr4() {
    ZipArchiveEntry entry = new ZipArchiveEntry("testEntry");
    byte[] extra = new byte[]{(byte) 255}; // Malformed data
    entry.setExtra(extra);
}
@Test(expected = IllegalArgumentException.class)
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
public void testSetExtraWithInvalidLength_npXM9() {
    ZipArchiveEntry entry = new ZipArchiveEntry("testEntry");
    byte[] extra = new byte[1024]; // Assuming 1024 is invalid length
    entry.setExtra(extra);
}
    private long time = -1;
    private boolean lastModifiedDateSet;
    private int platform = PLATFORM_FAT;
@Test(expected = NoSuchElementException.class)
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
public void testRemoveExtraFieldThrowsException_Emre1() throws ZipException {
    ZipArchiveEntry entry = new ZipArchiveEntry("testEntry");
    ZipShort type = new ZipShort(2);
    entry.removeExtraField(type); // This should throw NoSuchElementException
}
@Test(expected = IllegalArgumentException.class)
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
public void testSetAlignment_InvalidPowerOfTwo_ilRs1() {
    ZipArchiveEntry entry = new ZipArchiveEntry("testEntry");
    entry.setAlignment(10); // 10 is not a power of two
}
@Test(expected = IllegalArgumentException.class)
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
public void testSetAlignment_ExceedsMaxValue_MQrK2() {
    ZipArchiveEntry entry = new ZipArchiveEntry("testEntry");
    entry.setAlignment(65536); // exceeds 0xffff
}
@Test(expected = IllegalArgumentException.class)
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
public void testSetMethodNegative_LQdh1() {
    ZipArchiveEntry entry = new ZipArchiveEntry("testEntry.zip");
    entry.setMethod(-1);
}
    private long dataOffset = OFFSET_UNKNOWN;
    private long size = SIZE_UNKNOWN;
    private int platform = PLATFORM_FAT;
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testgetVersionRequired() throws Exception {
        ziparchiveentry = Mockito.mock(ZipArchiveEntry.class);
        Mockito.when(ziparchiveentry.getVersionRequired()).thenReturn(5);
        int expectedVersion = 5;
        int actualVersion = ziparchiveentry.getVersionRequired();
        Assertions.assertEquals(expectedVersion, actualVersion);
    }
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
public void testGetVersionRequired_gigg0() throws ZipException {
    ZipArchiveEntry entry = new ZipArchiveEntry("testEntry");
    int expectedVersion = 0; // Set the expected version based on your logic
    assertEquals(expectedVersion, entry.getVersionRequired());
}
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testsetGeneralPurposeBit() throws Exception {
        generalPurposeBit = Mockito.mock(GeneralPurposeBit.class);
        ziparchiveentry = new ZipArchiveEntry("testEntry");
        ziparchiveentry.setGeneralPurposeBit(generalPurposeBit);
        // Use reflection to access the private field for assertion
        Field field = ZipArchiveEntry.class.getDeclaredField("generalPurposeBit");
        field.setAccessible(true);
        GeneralPurposeBit actualGeneralPurposeBit = (GeneralPurposeBit) field.get(ziparchiveentry);
        assertEquals(generalPurposeBit, actualGeneralPurposeBit);
    }
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testSetUnixMode_1() throws Exception {
        ziparchiveentry = new ZipArchiveEntry();
        int mode = 0755; // Example Unix mode
        ziparchiveentry.setUnixMode(mode);
        // Using reflection to access private fields for assertions
        Field platformField = ZipArchiveEntry.class.getDeclaredField("platform");
        platformField.setAccessible(true);
        int platformValue = (int) platformField.get(ziparchiveentry);
        // Check the external attributes using reflection
        Field externalAttributesField = ZipArchiveEntry.class.getDeclaredField("externalAttributes");
        externalAttributesField.setAccessible(true);
        int externalAttributesValue = (int) externalAttributesField.get(ziparchiveentry);
        int expectedExternalAttributes = (mode << SHORT_SHIFT) | ((mode & 0200) == 0 ? 1 : 0) | 0;
        assertEquals(PLATFORM_UNIX, platformValue);}
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testSetUnixMode_2() throws Exception {
        ziparchiveentry = new ZipArchiveEntry();
        int mode = 0755; // Example Unix mode
        ziparchiveentry.setUnixMode(mode);
        // Using reflection to access private fields for assertions
        Field platformField = ZipArchiveEntry.class.getDeclaredField("platform");
        platformField.setAccessible(true);
        int platformValue = (int) platformField.get(ziparchiveentry);
        // Check the external attributes using reflection
        Field externalAttributesField = ZipArchiveEntry.class.getDeclaredField("externalAttributes");
        externalAttributesField.setAccessible(true);
        int externalAttributesValue = (int) externalAttributesField.get(ziparchiveentry);
        int expectedExternalAttributes = (mode << SHORT_SHIFT) | ((mode & 0200) == 0 ? 1 : 0) | 0;
        assertEquals(expectedExternalAttributes, externalAttributesValue);}
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
public void testSetGeneralPurposeBit_NlxS0_1() throws ZipException {
    ZipArchiveEntry entry = new ZipArchiveEntry("testEntry.zip");
    GeneralPurposeBit generalPurposeBit = new GeneralPurposeBit();
    entry.setGeneralPurposeBit(generalPurposeBit);
    assertNotNull(entry.generalPurposeBit);}
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
public void testSetGeneralPurposeBit_NlxS0_2() throws ZipException {
    ZipArchiveEntry entry = new ZipArchiveEntry("testEntry.zip");
    GeneralPurposeBit generalPurposeBit = new GeneralPurposeBit();
    entry.setGeneralPurposeBit(generalPurposeBit);
    assertEquals(generalPurposeBit, entry.generalPurposeBit);}
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
public void testSetUnixModeWithRegularFile_toZE0_1() throws ZipException {
    ZipArchiveEntry entry = new ZipArchiveEntry("testFile.txt");
    entry.setUnixMode(0755);
    assertEquals(PLATFORM_UNIX, entry.getPlatform());}
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
public void testSetUnixModeWithRegularFile_toZE0_2() throws ZipException {
    ZipArchiveEntry entry = new ZipArchiveEntry("testFile.txt");
    entry.setUnixMode(0755);
    assertEquals(0755 << SHORT_SHIFT | 0x10, entry.getExternalAttributes());}
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
public void testSetUnixModeWithDirectory_lIgF1_1() throws ZipException {
    ZipArchiveEntry entry = new ZipArchiveEntry("testDirectory/");
    entry.setUnixMode(0755);
    assertEquals(PLATFORM_UNIX, entry.getPlatform());}
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
public void testSetUnixModeWithDirectory_lIgF1_2() throws ZipException {
    ZipArchiveEntry entry = new ZipArchiveEntry("testDirectory/");
    entry.setUnixMode(0755);
    assertEquals(0755 << SHORT_SHIFT, entry.getExternalAttributes());}
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
public void testSetUnixModeWithNoPermissions_rHFv2_1() throws ZipException {
    ZipArchiveEntry entry = new ZipArchiveEntry("testFile.txt");
    entry.setUnixMode(0000);
    assertEquals(PLATFORM_UNIX, entry.getPlatform());}
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
public void testSetUnixModeWithNoPermissions_rHFv2_2() throws ZipException {
    ZipArchiveEntry entry = new ZipArchiveEntry("testFile.txt");
    entry.setUnixMode(0000);
    assertEquals(0 << SHORT_SHIFT | 1, entry.getExternalAttributes());}
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testgetExternalAttributes() throws Exception {
        ziparchiveentry = Mockito.mock(ZipArchiveEntry.class);
        Mockito.when(ziparchiveentry.getExternalAttributes()).thenReturn(externalAttributes);
        externalAttributes = 12345L;
        long result = ziparchiveentry.getExternalAttributes();
        assertEquals(12345L, result);
    }
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testEquals_1() throws Exception {
        zipArchiveEntry1 = Mockito.mock(ZipArchiveEntry.class);
        zipArchiveEntry2 = Mockito.mock(ZipArchiveEntry.class);
        Mockito.when(zipArchiveEntry1.getName()).thenReturn("entry1");
        Mockito.when(zipArchiveEntry2.getName()).thenReturn("entry1");
        Mockito.when(zipArchiveEntry1.getComment()).thenReturn("comment");
        Mockito.when(zipArchiveEntry2.getComment()).thenReturn("comment");
        Mockito.when(zipArchiveEntry1.getLastModifiedTime()).thenReturn(1000L);
        Mockito.when(zipArchiveEntry2.getLastModifiedTime()).thenReturn(1000L);
        Mockito.when(zipArchiveEntry1.getLastAccessTime()).thenReturn(2000L);
        Mockito.when(zipArchiveEntry2.getLastAccessTime()).thenReturn(2000L);
        Mockito.when(zipArchiveEntry1.getCreationTime()).thenReturn(3000L);
        Mockito.when(zipArchiveEntry2.getCreationTime()).thenReturn(3000L);
        Mockito.when(zipArchiveEntry1.getInternalAttributes()).thenReturn(1);
        Mockito.when(zipArchiveEntry2.getInternalAttributes()).thenReturn(1);
        Mockito.when(zipArchiveEntry1.getPlatform()).thenReturn(2);
        Mockito.when(zipArchiveEntry2.getPlatform()).thenReturn(2);
        Mockito.when(zipArchiveEntry1.getExternalAttributes()).thenReturn(3);
        Mockito.when(zipArchiveEntry2.getExternalAttributes()).thenReturn(3);
        Mockito.when(zipArchiveEntry1.getMethod()).thenReturn(4);
        Mockito.when(zipArchiveEntry2.getMethod()).thenReturn(4);
        Mockito.when(zipArchiveEntry1.getSize()).thenReturn(500L);
        Mockito.when(zipArchiveEntry2.getSize()).thenReturn(500L);
        Mockito.when(zipArchiveEntry1.getCrc()).thenReturn(123456789L);
        Mockito.when(zipArchiveEntry2.getCrc()).thenReturn(123456789L);
        Mockito.when(zipArchiveEntry1.getCompressedSize()).thenReturn(400L);
        Mockito.when(zipArchiveEntry2.getCompressedSize()).thenReturn(400L);
        Mockito.when(zipArchiveEntry1.getCentralDirectoryExtra()).thenReturn(new byte[]{1, 2, 3});
        Mockito.when(zipArchiveEntry2.getCentralDirectoryExtra()).thenReturn(new byte[]{1, 2, 3});
        Mockito.when(zipArchiveEntry1.getLocalFileDataExtra()).thenReturn(new byte[]{4, 5, 6});
        Mockito.when(zipArchiveEntry2.getLocalFileDataExtra()).thenReturn(new byte[]{4, 5, 6});
        Mockito.when(zipArchiveEntry1.localHeaderOffset).thenReturn(localHeaderOffset);
        Mockito.when(localHeaderOffset).thenReturn(localHeaderOffset);
        Mockito.when(zipArchiveEntry1.dataOffset).thenReturn(dataOffset);
        Mockito.when(dataOffset).thenReturn(dataOffset);
        Mockito.when(zipArchiveEntry1.generalPurposeBit).thenReturn(generalPurposeBit);
        Mockito.when(generalPurposeBit).thenReturn(generalPurposeBit);
        Mockito.when(zipArchiveEntry2.getName()).thenReturn("entry2");
        Mockito.when(zipArchiveEntry2.getName()).thenReturn("entry1");
        Mockito.when(zipArchiveEntry2.getComment()).thenReturn(null);
        Mockito.when(zipArchiveEntry2.getComment()).thenReturn("comment");
        Mockito.when(zipArchiveEntry2.getLastModifiedTime()).thenReturn(999L);
        assertTrue(zipArchiveEntry1.equals(zipArchiveEntry2));}
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testEquals_2() throws Exception {
        zipArchiveEntry1 = Mockito.mock(ZipArchiveEntry.class);
        zipArchiveEntry2 = Mockito.mock(ZipArchiveEntry.class);
        Mockito.when(zipArchiveEntry1.getName()).thenReturn("entry1");
        Mockito.when(zipArchiveEntry2.getName()).thenReturn("entry1");
        Mockito.when(zipArchiveEntry1.getComment()).thenReturn("comment");
        Mockito.when(zipArchiveEntry2.getComment()).thenReturn("comment");
        Mockito.when(zipArchiveEntry1.getLastModifiedTime()).thenReturn(1000L);
        Mockito.when(zipArchiveEntry2.getLastModifiedTime()).thenReturn(1000L);
        Mockito.when(zipArchiveEntry1.getLastAccessTime()).thenReturn(2000L);
        Mockito.when(zipArchiveEntry2.getLastAccessTime()).thenReturn(2000L);
        Mockito.when(zipArchiveEntry1.getCreationTime()).thenReturn(3000L);
        Mockito.when(zipArchiveEntry2.getCreationTime()).thenReturn(3000L);
        Mockito.when(zipArchiveEntry1.getInternalAttributes()).thenReturn(1);
        Mockito.when(zipArchiveEntry2.getInternalAttributes()).thenReturn(1);
        Mockito.when(zipArchiveEntry1.getPlatform()).thenReturn(2);
        Mockito.when(zipArchiveEntry2.getPlatform()).thenReturn(2);
        Mockito.when(zipArchiveEntry1.getExternalAttributes()).thenReturn(3);
        Mockito.when(zipArchiveEntry2.getExternalAttributes()).thenReturn(3);
        Mockito.when(zipArchiveEntry1.getMethod()).thenReturn(4);
        Mockito.when(zipArchiveEntry2.getMethod()).thenReturn(4);
        Mockito.when(zipArchiveEntry1.getSize()).thenReturn(500L);
        Mockito.when(zipArchiveEntry2.getSize()).thenReturn(500L);
        Mockito.when(zipArchiveEntry1.getCrc()).thenReturn(123456789L);
        Mockito.when(zipArchiveEntry2.getCrc()).thenReturn(123456789L);
        Mockito.when(zipArchiveEntry1.getCompressedSize()).thenReturn(400L);
        Mockito.when(zipArchiveEntry2.getCompressedSize()).thenReturn(400L);
        Mockito.when(zipArchiveEntry1.getCentralDirectoryExtra()).thenReturn(new byte[]{1, 2, 3});
        Mockito.when(zipArchiveEntry2.getCentralDirectoryExtra()).thenReturn(new byte[]{1, 2, 3});
        Mockito.when(zipArchiveEntry1.getLocalFileDataExtra()).thenReturn(new byte[]{4, 5, 6});
        Mockito.when(zipArchiveEntry2.getLocalFileDataExtra()).thenReturn(new byte[]{4, 5, 6});
        Mockito.when(zipArchiveEntry1.localHeaderOffset).thenReturn(localHeaderOffset);
        Mockito.when(localHeaderOffset).thenReturn(localHeaderOffset);
        Mockito.when(zipArchiveEntry1.dataOffset).thenReturn(dataOffset);
        Mockito.when(dataOffset).thenReturn(dataOffset);
        Mockito.when(zipArchiveEntry1.generalPurposeBit).thenReturn(generalPurposeBit);
        Mockito.when(generalPurposeBit).thenReturn(generalPurposeBit);
        Mockito.when(zipArchiveEntry2.getName()).thenReturn("entry2");
        Mockito.when(zipArchiveEntry2.getName()).thenReturn("entry1");
        Mockito.when(zipArchiveEntry2.getComment()).thenReturn(null);
        Mockito.when(zipArchiveEntry2.getComment()).thenReturn("comment");
        Mockito.when(zipArchiveEntry2.getLastModifiedTime()).thenReturn(999L);
        assertFalse(zipArchiveEntry1.equals(zipArchiveEntry2));}
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
public void testGetExternalAttributes_dVOh0() throws ZipException {
    ZipArchiveEntry entry = new ZipArchiveEntry("testEntry");
    long expectedAttributes = 0; // Set expected attributes based on your logic
    entry.externalAttributes = expectedAttributes; // Assuming externalAttributes is accessible for testing
    assertEquals(expectedAttributes, entry.getExternalAttributes());
}
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testgetLastModifiedDate() throws Exception {
        ziparchiveentry = Mockito.mock(ZipArchiveEntry.class);
        Mockito.when(ziparchiveentry.getTime()).thenReturn(1633072800000L); // Example timestamp
        Date expectedDate = new Date(1633072800000L);
        Date actualDate = ziparchiveentry.getLastModifiedDate();
        Assertions.assertEquals(expectedDate, actualDate);
    }
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
public void testGetLastModifiedDate_CqhP0() throws ZipException {
    ZipArchiveEntry entry = new ZipArchiveEntry("testEntry.zip");
    long expectedTime = System.currentTimeMillis();
    entry.setTime(expectedTime); // Hypothetical method to set time for testing
    Date expectedDate = new Date(expectedTime);
    Date actualDate = entry.getLastModifiedDate();
    assertEquals(expectedDate, actualDate);
}
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testRemoveUnparseableExtraFieldData() {
        unparseableExtra = Mockito.mock(UnparseableExtraFieldData.class);
        ziparchiveentry = Mockito.spy(new ZipArchiveEntry());
        Field field = ZipArchiveEntry.class.getDeclaredField("unparseableExtra");
        field.setAccessible(true);
        field.set(ziparchiveentry, unparseableExtra);
        ziparchiveentry.removeUnparseableExtraFieldData();
        assertNull(ziparchiveentry.getUnparseableExtraFieldData());
        Mockito.verify(ziparchiveentry).setExtra();
    }
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testRemoveUnparseableExtraFieldDataThrowsException() {
        unparseableExtra = Mockito.mock(UnparseableExtraFieldData.class);
        ziparchiveentry = Mockito.spy(new ZipArchiveEntry());
        Field field = ZipArchiveEntry.class.getDeclaredField("unparseableExtra");
        field.setAccessible(true);
        field.set(ziparchiveentry, unparseableExtra);
        ziparchiveentry.removeUnparseableExtraFieldData();
        assertThrows(NoSuchElementException.class, () -> ziparchiveentry.removeUnparseableExtraFieldData());
    }
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
public void testRemoveUnparseableExtraFieldData_WhenUnparseableExtraIsNull_ThrowsNoSuchElementException_mVCB0_1() {
    ZipArchiveEntry entry = new ZipArchiveEntry("testEntry");
    Exception exception = assertThrows(NoSuchElementException.class, entry::removeUnparseableExtraFieldData);}
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
public void testRemoveUnparseableExtraFieldData_WhenUnparseableExtraIsNull_ThrowsNoSuchElementException_mVCB0_2() {
    ZipArchiveEntry entry = new ZipArchiveEntry("testEntry");
    assertEquals("No such element", exception.getMessage());}
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
public void testRemoveUnparseableExtraFieldData_WhenUnparseableExtraIsNotNull_SetsExtraToNull_ZxUG1() {
    ZipArchiveEntry entry = new ZipArchiveEntry("testEntry");
    entry.unparseableExtra = new byte[]{1, 2, 3}; // Assuming unparseableExtra is a byte array
    entry.removeUnparseableExtraFieldData();
    assertNull(entry.unparseableExtra);
}
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testgetInternalAttributes() throws Exception {
        ziparchiveentry = new ZipArchiveEntry();
        // Using reflection to set the private field internalAttributes for testing
        java.lang.reflect.Field field = ZipArchiveEntry.class.getDeclaredField("internalAttributes");
        field.setAccessible(true);
        field.setInt(ziparchiveentry, 42); // Setting a test value
        int result = ziparchiveentry.getInternalAttributes();
        assertEquals(42, result);
    }
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
public void testEquals_SameInstance_cykb0() {
    ZipArchiveEntry entry = new ZipArchiveEntry("test.txt");
    assertTrue(entry.equals(entry));
}
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
public void testEquals_NullObject_wMeY1() {
    ZipArchiveEntry entry = new ZipArchiveEntry("test.txt");
    assertFalse(entry.equals(null));
}
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
public void testEquals_DifferentClass_djOD2() {
    ZipArchiveEntry entry = new ZipArchiveEntry("test.txt");
    assertFalse(entry.equals("Not a ZipArchiveEntry"));
}
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
public void testEquals_DifferentNames_OKcD3() {
    ZipArchiveEntry entry1 = new ZipArchiveEntry("test1.txt");
    ZipArchiveEntry entry2 = new ZipArchiveEntry("test2.txt");
    assertFalse(entry1.equals(entry2));
}
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
public void testEquals_SameNameDifferentComment_LoyQ4() {
    ZipArchiveEntry entry1 = new ZipArchiveEntry("test.txt");
    entry1.setComment("Comment 1");
    ZipArchiveEntry entry2 = new ZipArchiveEntry("test.txt");
    entry2.setComment("Comment 2");
    assertFalse(entry1.equals(entry2));
}
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
public void testEquals_SameNameNullComment_SYzQ5() {
    ZipArchiveEntry entry1 = new ZipArchiveEntry("test.txt");
    entry1.setComment(null);
    ZipArchiveEntry entry2 = new ZipArchiveEntry("test.txt");
    entry2.setComment("Comment");
    assertFalse(entry1.equals(entry2));
}
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
public void testEquals_SameNameSameComment_gKil6() {
    ZipArchiveEntry entry1 = new ZipArchiveEntry("test.txt");
    entry1.setComment("Comment");
    ZipArchiveEntry entry2 = new ZipArchiveEntry("test.txt");
    entry2.setComment("Comment");
    assertTrue(entry1.equals(entry2));
}
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
public void testEquals_SameAttributes_DzeB7() {
    ZipArchiveEntry entry1 = new ZipArchiveEntry("test.txt");
    entry1.setLastModifiedTime(1000L);
    entry1.setSize(500);
    ZipArchiveEntry entry2 = new ZipArchiveEntry("test.txt");
    entry2.setLastModifiedTime(1000L);
    entry2.setSize(500);
    assertTrue(entry1.equals(entry2));
}
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
public void testEquals_DifferentLastModifiedTime_gNqm8() {
    ZipArchiveEntry entry1 = new ZipArchiveEntry("test.txt");
    entry1.setLastModifiedTime(1000L);
    ZipArchiveEntry entry2 = new ZipArchiveEntry("test.txt");
    entry2.setLastModifiedTime(2000L);
    assertFalse(entry1.equals(entry2));
}
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
public void testEquals_DifferentSize_jEoW9() {
    ZipArchiveEntry entry1 = new ZipArchiveEntry("test.txt");
    entry1.setSize(500);
    ZipArchiveEntry entry2 = new ZipArchiveEntry("test.txt");
    entry2.setSize(600);
    assertFalse(entry1.equals(entry2));
}
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
public void testEquals_SameInternalAttributes_RvnC10() {
    ZipArchiveEntry entry1 = new ZipArchiveEntry("test.txt");
    entry1.setInternalAttributes(1);
    ZipArchiveEntry entry2 = new ZipArchiveEntry("test.txt");
    entry2.setInternalAttributes(1);
    assertTrue(entry1.equals(entry2));
}
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
public void testEquals_DifferentInternalAttributes_BeqL11() {
    ZipArchiveEntry entry1 = new ZipArchiveEntry("test.txt");
    entry1.setInternalAttributes(1);
    ZipArchiveEntry entry2 = new ZipArchiveEntry("test.txt");
    entry2.setInternalAttributes(2);
    assertFalse(entry1.equals(entry2));
}
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
public void testEquals_SamePlatform_tLhO12() {
    ZipArchiveEntry entry1 = new ZipArchiveEntry("test.txt");
    entry1.setPlatform(1);
    ZipArchiveEntry entry2 = new ZipArchiveEntry("test.txt");
    entry2.setPlatform(1);
    assertTrue(entry1.equals(entry2));
}
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
public void testEquals_DifferentPlatform_FxOM13() {
    ZipArchiveEntry entry1 = new ZipArchiveEntry("test.txt");
    entry1.setPlatform(1);
    ZipArchiveEntry entry2 = new ZipArchiveEntry("test.txt");
    entry2.setPlatform(2);
    assertFalse(entry1.equals(entry2));
}
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
public void testEquals_SameExternalAttributes_RGCw14() {
    ZipArchiveEntry entry1 = new ZipArchiveEntry("test.txt");
    entry1.setExternalAttributes(1);
    ZipArchiveEntry entry2 = new ZipArchiveEntry("test.txt");
    entry2.setExternalAttributes(1);
    assertTrue(entry1.equals(entry2));
}
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
public void testEquals_DifferentExternalAttributes_KOoM15() {
    ZipArchiveEntry entry1 = new ZipArchiveEntry("test.txt");
    entry1.setExternalAttributes(1);
    ZipArchiveEntry entry2 = new ZipArchiveEntry("test.txt");
    entry2.setExternalAttributes(2);
    assertFalse(entry1.equals(entry2));
}
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
public void testEquals_SameMethod_xtgq16() {
    ZipArchiveEntry entry1 = new ZipArchiveEntry("test.txt");
    entry1.setMethod(1);
    ZipArchiveEntry entry2 = new ZipArchiveEntry("test.txt");
    entry2.setMethod(1);
    assertTrue(entry1.equals(entry2));
}
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
public void testEquals_DifferentMethod_SbdI17() {
    ZipArchiveEntry entry1 = new ZipArchiveEntry("test.txt");
    entry1.setMethod(1);
    ZipArchiveEntry entry2 = new ZipArchiveEntry("test.txt");
    entry2.setMethod(2);
    assertFalse(entry1.equals(entry2));
}
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
public void testEquals_SameCrc_zgub18() {
    ZipArchiveEntry entry1 = new ZipArchiveEntry("test.txt");
    entry1.setCrc(12345);
    ZipArchiveEntry entry2 = new ZipArchiveEntry("test.txt");
    entry2.setCrc(12345);
    assertTrue(entry1.equals(entry2));
}
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
public void testEquals_DifferentCrc_QZrA19() {
    ZipArchiveEntry entry1 = new ZipArchiveEntry("test.txt");
    entry1.setCrc(12345);
    ZipArchiveEntry entry2 = new ZipArchiveEntry("test.txt");
    entry2.setCrc(54321);
    assertFalse(entry1.equals(entry2));
}
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
public void testEquals_SameCompressedSize_xGzV20() {
    ZipArchiveEntry entry1 = new ZipArchiveEntry("test.txt");
    entry1.setCompressedSize(100);
    ZipArchiveEntry entry2 = new ZipArchiveEntry("test.txt");
    entry2.setCompressedSize(100);
    assertTrue(entry1.equals(entry2));
}
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
public void testEquals_DifferentCompressedSize_Dxgq21() {
    ZipArchiveEntry entry1 = new ZipArchiveEntry("test.txt");
    entry1.setCompressedSize(100);
    ZipArchiveEntry entry2 = new ZipArchiveEntry("test.txt");
    entry2.setCompressedSize(200);
    assertFalse(entry1.equals(entry2));
}
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
public void testEquals_SameCentralDirectoryExtra_kCWR22() {
    ZipArchiveEntry entry1 = new ZipArchiveEntry("test.txt");
    entry1.setCentralDirectoryExtra(new byte[]{1, 2, 3});
    ZipArchiveEntry entry2 = new ZipArchiveEntry("test.txt");
    entry2.setCentralDirectoryExtra(new byte[]{1, 2, 3});
    assertTrue(entry1.equals(entry2));
}
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
public void testEquals_DifferentCentralDirectoryExtra_qILA23() {
    ZipArchiveEntry entry1 = new ZipArchiveEntry("test.txt");
    entry1.setCentralDirectoryExtra(new byte[]{1, 2, 3});
    ZipArchiveEntry entry2 = new ZipArchiveEntry("test.txt");
    entry2.setCentralDirectoryExtra(new byte[]{4, 5, 6});
    assertFalse(entry1.equals(entry2));
}
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
public void testEquals_SameLocalFileDataExtra_CcVM24() {
    ZipArchiveEntry entry1 = new ZipArchiveEntry("test.txt");
    entry1.setLocalFileDataExtra(new byte[]{1, 2, 3});
    ZipArchiveEntry entry2 = new ZipArchiveEntry("test.txt");
    entry2.setLocalFileDataExtra(new byte[]{1, 2, 3});
    assertTrue(entry1.equals(entry2));
}
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
public void testEquals_DifferentLocalFileDataExtra_tcbu25() {
    ZipArchiveEntry entry1 = new ZipArchiveEntry("test.txt");
    entry1.setLocalFileDataExtra(new byte[]{1, 2, 3});
    ZipArchiveEntry entry2 = new ZipArchiveEntry("test.txt");
    entry2.setLocalFileDataExtra(new byte[]{4, 5, 6});
    assertFalse(entry1.equals(entry2));
}
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
public void testEquals_SameOffsets_CyyU26() {
    ZipArchiveEntry entry1 = new ZipArchiveEntry("test.txt");
    entry1.localHeaderOffset = 100;
    entry1.dataOffset = 200;
    ZipArchiveEntry entry2 = new ZipArchiveEntry("test.txt");
    entry2.localHeaderOffset = 100;
    entry2.dataOffset = 200;
    assertTrue(entry1.equals(entry2));
}
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
public void testEquals_DifferentOffsets_WOUf27() {
    ZipArchiveEntry entry1 = new ZipArchiveEntry("test.txt");
    entry1.localHeaderOffset = 100;
    entry1.dataOffset = 200;
    ZipArchiveEntry entry2 = new ZipArchiveEntry("test.txt");
    entry2.localHeaderOffset = 150;
    entry2.dataOffset = 250;
    assertFalse(entry1.equals(entry2));
}
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
public void testEquals_SameGeneralPurposeBit_kLVT28() {
    ZipArchiveEntry entry1 = new ZipArchiveEntry("test.txt");
    entry1.generalPurposeBit = new GeneralPurposeBit();
    ZipArchiveEntry entry2 = new ZipArchiveEntry("test.txt");
    entry2.generalPurposeBit = new GeneralPurposeBit();
    assertTrue(entry1.equals(entry2));
}
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
public void testEquals_DifferentGeneralPurposeBit_MBDd29() {
    ZipArchiveEntry entry1 = new ZipArchiveEntry("test.txt");
    entry1.generalPurposeBit = new GeneralPurposeBit();
    entry1.generalPurposeBit.setBit(1);
    ZipArchiveEntry entry2 = new ZipArchiveEntry("test.txt");
    entry2.generalPurposeBit = new GeneralPurposeBit();
    entry2.generalPurposeBit.setBit(2);
    assertFalse(entry1.equals(entry2));
}
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
public void testGetInternalAttributes_PmEh0() throws ZipException {
    ZipArchiveEntry entry = new ZipArchiveEntry("testEntry");
    assertEquals(0, entry.getInternalAttributes());
}
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testgetRawFlag() throws Exception {
        ziparchiveentry = Mockito.spy(new ZipArchiveEntry());
        Mockito.doReturn(rawFlag).when(ziparchiveentry).getRawFlag();
        rawFlag = 5; // Set a value for testing
        int result = ziparchiveentry.getRawFlag();
        Assertions.assertEquals(rawFlag, result);
    }
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
public void testGetRawFlag_Gwrj0() throws ZipException {
    ZipArchiveEntry entry = new ZipArchiveEntry("testEntry");
    assertEquals(0, entry.getRawFlag());
}
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testsetCreationTime_1() throws Exception {
        ziparchiveentry = new ZipArchiveEntry();
        FileTime fileTime = FileTime.fromMillis(System.currentTimeMillis());
        ZipEntry result = ziparchiveentry.setCreationTime(fileTime);
        // Assuming there's a way to verify the internal state of time
        // This part would depend on how the time is stored or accessed
        // For example, if there's a method to get the creation time:
        assertNotNull(result);}
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testsetCreationTime_2() throws Exception {
        ziparchiveentry = new ZipArchiveEntry();
        FileTime fileTime = FileTime.fromMillis(System.currentTimeMillis());
        ZipEntry result = ziparchiveentry.setCreationTime(fileTime);
        // Assuming there's a way to verify the internal state of time
        // This part would depend on how the time is stored or accessed
        // For example, if there's a method to get the creation time:
        assertEquals(ziparchiveentry, result);}
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testsetCreationTime_3() throws Exception {
        ziparchiveentry = new ZipArchiveEntry();
        FileTime fileTime = FileTime.fromMillis(System.currentTimeMillis());
        ZipEntry result = ziparchiveentry.setCreationTime(fileTime);
        // Assuming there's a way to verify the internal state of time
        // This part would depend on how the time is stored or accessed
        // For example, if there's a method to get the creation time:
        assertEquals(fileTime.toMillis(), ziparchiveentry.getCreationTime().toMillis());}
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
public void testSetCreationTime_IjqI0_1() throws IOException, ZipException {
    Path inputPath = Paths.get("test.zip");
    String entryName = "testEntry.txt";
    ZipArchiveEntry zipEntry = new ZipArchiveEntry(inputPath, entryName);
    FileTime creationTime = FileTime.fromMillis(System.currentTimeMillis());
    ZipEntry result = zipEntry.setCreationTime(creationTime);
    assertNotNull(result);}
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
public void testSetCreationTime_IjqI0_2() throws IOException, ZipException {
    Path inputPath = Paths.get("test.zip");
    String entryName = "testEntry.txt";
    ZipArchiveEntry zipEntry = new ZipArchiveEntry(inputPath, entryName);
    FileTime creationTime = FileTime.fromMillis(System.currentTimeMillis());
    ZipEntry result = zipEntry.setCreationTime(creationTime);
    assertEquals(creationTime, zipEntry.getCreationTime());}
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
public void testSetCreationTime_IjqI0_3() throws IOException, ZipException {
    Path inputPath = Paths.get("test.zip");
    String entryName = "testEntry.txt";
    ZipArchiveEntry zipEntry = new ZipArchiveEntry(inputPath, entryName);
    FileTime creationTime = FileTime.fromMillis(System.currentTimeMillis());
    ZipEntry result = zipEntry.setCreationTime(creationTime);
    assertNotNull(zipEntry.getExtraField(X5455_ExtendedTimestamp.HEADER_ID));}
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
public void testSetCreationTime_IjqI0_4() throws IOException, ZipException {
    Path inputPath = Paths.get("test.zip");
    String entryName = "testEntry.txt";
    ZipArchiveEntry zipEntry = new ZipArchiveEntry(inputPath, entryName);
    FileTime creationTime = FileTime.fromMillis(System.currentTimeMillis());
    ZipEntry result = zipEntry.setCreationTime(creationTime);
    assertNotNull(zipEntry.getExtraField(X000A_NTFS.HEADER_ID));}
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
public void testSetCreationTime_gqlh0_1() throws IOException, ZipException {
    Path inputPath = Paths.get("test.zip");
    String entryName = "testEntry";
    FileTime creationTime = FileTime.fromMillis(System.currentTimeMillis());
    ZipArchiveEntry zipEntry = new ZipArchiveEntry(inputPath, entryName);
    zipEntry.setCreationTime(creationTime);
    assertEquals(creationTime, zipEntry.getCreationTime());}
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
public void testSetCreationTime_gqlh0_2() throws IOException, ZipException {
    Path inputPath = Paths.get("test.zip");
    String entryName = "testEntry";
    FileTime creationTime = FileTime.fromMillis(System.currentTimeMillis());
    ZipArchiveEntry zipEntry = new ZipArchiveEntry(inputPath, entryName);
    zipEntry.setCreationTime(creationTime);
    assertNotNull(zipEntry.getExtraField(X5455_ExtendedTimestamp.HEADER_ID));}
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
public void testSetCreationTime_gqlh0_3() throws IOException, ZipException {
    Path inputPath = Paths.get("test.zip");
    String entryName = "testEntry";
    FileTime creationTime = FileTime.fromMillis(System.currentTimeMillis());
    ZipArchiveEntry zipEntry = new ZipArchiveEntry(inputPath, entryName);
    zipEntry.setCreationTime(creationTime);
    assertNotNull(zipEntry.getExtraField(X000A_NTFS.HEADER_ID));}
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
public void testSetCreationTime_EwNn0_1() throws IOException, ZipException {
    Path inputPath = Paths.get("test.zip");
    String entryName = "testEntry";
    ZipArchiveEntry zipEntry = new ZipArchiveEntry(inputPath, entryName);
    FileTime creationTime = FileTime.fromMillis(System.currentTimeMillis());
    zipEntry.setCreationTime(creationTime);
    assertNotNull(zipEntry.getExtraField(X5455_ExtendedTimestamp.HEADER_ID));}
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
public void testSetCreationTime_EwNn0_2() throws IOException, ZipException {
    Path inputPath = Paths.get("test.zip");
    String entryName = "testEntry";
    ZipArchiveEntry zipEntry = new ZipArchiveEntry(inputPath, entryName);
    FileTime creationTime = FileTime.fromMillis(System.currentTimeMillis());
    zipEntry.setCreationTime(creationTime);
    assertEquals(creationTime, zipEntry.getCreationTime());}
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
public void testSetCreationTime_gyHk0_1() throws IOException {
    Path inputPath = Paths.get("test.zip");
    String entryName = "testEntry";
    ZipArchiveEntry zipEntry = new ZipArchiveEntry(inputPath, entryName);
    FileTime creationTime = FileTime.fromMillis(System.currentTimeMillis());
    ZipEntry result = zipEntry.setCreationTime(creationTime);
    assertNotNull(result);}
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
public void testSetCreationTime_gyHk0_2() throws IOException {
    Path inputPath = Paths.get("test.zip");
    String entryName = "testEntry";
    ZipArchiveEntry zipEntry = new ZipArchiveEntry(inputPath, entryName);
    FileTime creationTime = FileTime.fromMillis(System.currentTimeMillis());
    ZipEntry result = zipEntry.setCreationTime(creationTime);
    assertEquals(zipEntry, result);}
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
public void testSetCreationTime_gyHk0_3() throws IOException {
    Path inputPath = Paths.get("test.zip");
    String entryName = "testEntry";
    ZipArchiveEntry zipEntry = new ZipArchiveEntry(inputPath, entryName);
    FileTime creationTime = FileTime.fromMillis(System.currentTimeMillis());
    ZipEntry result = zipEntry.setCreationTime(creationTime);
    assertNotNull(zipEntry.getExtraField(X5455_ExtendedTimestamp.HEADER_ID));}
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
public void testSetCreationTime_gyHk0_4() throws IOException {
    Path inputPath = Paths.get("test.zip");
    String entryName = "testEntry";
    ZipArchiveEntry zipEntry = new ZipArchiveEntry(inputPath, entryName);
    FileTime creationTime = FileTime.fromMillis(System.currentTimeMillis());
    ZipEntry result = zipEntry.setCreationTime(creationTime);
    assertNotNull(zipEntry.getExtraField(X000A_NTFS.HEADER_ID));}
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
public void testSetCreationTime_HEfv0_3() throws IOException, ZipException {
    Path inputPath = Paths.get("test.zip");
    String entryName = "testEntry";
    ZipArchiveEntry zipEntry = new ZipArchiveEntry(inputPath, entryName);
    FileTime creationTime = FileTime.fromMillis(System.currentTimeMillis());
    zipEntry.setCreationTime(creationTime);
    assertNotNull(zipEntry.getExtraField(X000A_NTFS.HEADER_ID));}
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
public void testSetCreationTime_XVEE0_2() throws IOException, ZipException {
    Path inputPath = Paths.get("test.zip");
    String entryName = "testEntry";
    ZipArchiveEntry zipEntry = new ZipArchiveEntry(inputPath, entryName);
    FileTime creationTime = FileTime.fromMillis(System.currentTimeMillis());
    ZipEntry result = zipEntry.setCreationTime(creationTime);
    assertEquals(creationTime, zipEntry.getCreationTime());}
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
public void testSetCreationTime_WithValidTime_ShouldSetCreationTimeAndExtraFields_Tqnl0_2() throws IOException {
    Path inputPath = Paths.get("test.zip");
    String entryName = "testEntry";
    ZipArchiveEntry zipEntry = new ZipArchiveEntry(inputPath, entryName);
    FileTime creationTime = FileTime.fromMillis(System.currentTimeMillis());
    zipEntry.setCreationTime(creationTime);
    assertTrue(zipEntry.getExtraField(X5455_ExtendedTimestamp.HEADER_ID) != null || 
               zipEntry.getExtraField(X000A_NTFS.HEADER_ID) != null);}
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
public void testSetCreationTime_withValidTime_updatesExtraTimeFields_bqQc0_1() throws IOException {
    Path inputPath = Paths.get("test.zip");
    String entryName = "testEntry";
    ZipArchiveEntry zipEntry = new ZipArchiveEntry(inputPath, entryName);
    FileTime creationTime = FileTime.fromMillis(System.currentTimeMillis());
    FileTime lastModifiedTime = FileTime.fromMillis(System.currentTimeMillis());
    FileTime lastAccessTime = FileTime.fromMillis(System.currentTimeMillis());
    zipEntry.setCreationTime(creationTime);
    assertNotNull(zipEntry.getExtraField(X5455_ExtendedTimestamp.HEADER_ID));}
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
public void testSetCreationTime_withValidTime_updatesExtraTimeFields_bqQc0_2() throws IOException {
    Path inputPath = Paths.get("test.zip");
    String entryName = "testEntry";
    ZipArchiveEntry zipEntry = new ZipArchiveEntry(inputPath, entryName);
    FileTime creationTime = FileTime.fromMillis(System.currentTimeMillis());
    FileTime lastModifiedTime = FileTime.fromMillis(System.currentTimeMillis());
    FileTime lastAccessTime = FileTime.fromMillis(System.currentTimeMillis());
    zipEntry.setCreationTime(creationTime);
    assertNotNull(zipEntry.getExtraField(X000A_NTFS.HEADER_ID));}
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
public void testSetCreationTime_withValidTime_updatesExtraTimeFields_bqQc0_3() throws IOException {
    Path inputPath = Paths.get("test.zip");
    String entryName = "testEntry";
    ZipArchiveEntry zipEntry = new ZipArchiveEntry(inputPath, entryName);
    FileTime creationTime = FileTime.fromMillis(System.currentTimeMillis());
    FileTime lastModifiedTime = FileTime.fromMillis(System.currentTimeMillis());
    FileTime lastAccessTime = FileTime.fromMillis(System.currentTimeMillis());
    zipEntry.setCreationTime(creationTime);
    assertTrue(zipEntry.canConvertToInfoZipExtendedTimestamp(lastModifiedTime, lastAccessTime, creationTime));}
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testsetDiskNumberStart() throws Exception {
        ziparchiveentry = new ZipArchiveEntry();
        diskNumberStart = 5L;
        ziparchiveentry.setDiskNumberStart(diskNumberStart);
        Field field = ZipArchiveEntry.class.getDeclaredField("diskNumberStart");
        field.setAccessible(true);
        long actualDiskNumberStart = (long) field.get(ziparchiveentry);
        assertEquals(diskNumberStart, actualDiskNumberStart);
    }
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
public void testSetDiskNumberStart_qRYj0() throws ZipException {
    ZipArchiveEntry entry = new ZipArchiveEntry("testEntry");
    entry.setDiskNumberStart(5L);
    assertEquals(5L, entry.diskNumberStart);
}
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testGetCommentSource() throws Exception {
        ziparchiveentry = new ZipArchiveEntry("testEntry");
        CommentSource result = ziparchiveentry.getCommentSource();
        assertEquals(commentSource, result);
    }
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
public void testGetCommentSource_qzfL0() throws IOException {
    ZipArchiveEntry entry = new ZipArchiveEntry(new File("test.zip"), "testEntry");
    CommentSource expectedSource = CommentSource.SOME_SOURCE; // Replace with actual expected value
    entry.commentSource = expectedSource; // Assuming commentSource is accessible for testing
    assertEquals(expectedSource, entry.getCommentSource());
}
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testsetName_1() throws Exception {
        name = "testEntry";
        rawName = new byte[]{1, 2, 3};
        ziparchiveentry = new ZipArchiveEntry(name);
        ziparchiveentry.setName(name, rawName);
        // Using reflection to access the private field 'rawName'
        Field rawNameField = ZipArchiveEntry.class.getDeclaredField("rawName");
        rawNameField.setAccessible(true);
        byte[] actualRawName = (byte[]) rawNameField.get(ziparchiveentry);
        assertEquals(name, ziparchiveentry.getName());}
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testsetName_2() throws Exception {
        name = "testEntry";
        rawName = new byte[]{1, 2, 3};
        ziparchiveentry = new ZipArchiveEntry(name);
        ziparchiveentry.setName(name, rawName);
        // Using reflection to access the private field 'rawName'
        Field rawNameField = ZipArchiveEntry.class.getDeclaredField("rawName");
        rawNameField.setAccessible(true);
        byte[] actualRawName = (byte[]) rawNameField.get(ziparchiveentry);
        assertArrayEquals(rawName, actualRawName);}
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
public void testSetNameWithRawName_RhHw0_1() throws ZipException {
    ZipArchiveEntry entry = new ZipArchiveEntry("testEntry");
    byte[] rawName = "testEntry".getBytes();
    entry.setName("newTestEntry", rawName);
    assertEquals("newTestEntry", entry.getName());}
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
public void testSetNameWithRawName_RhHw0_2() throws ZipException {
    ZipArchiveEntry entry = new ZipArchiveEntry("testEntry");
    byte[] rawName = "testEntry".getBytes();
    entry.setName("newTestEntry", rawName);
    assertArrayEquals(rawName, entry.rawName);}
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testgetAlignment() throws Exception {
        ziparchiveentry = new ZipArchiveEntry() {
            {
                // Set the alignment directly for testing purposes
                alignment = 10; // Example value
            }
        };
        int result = ziparchiveentry.getAlignment();
        assertEquals(10, result);
    }
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
public void testGetAlignment_iZUp0() throws ZipException {
    ZipArchiveEntry entry = new ZipArchiveEntry("testEntry");
    assertEquals(0, entry.getAlignment());
}
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testsetExtra() throws Exception {
        ziparchiveentry = new ZipArchiveEntry("testEntry");
        // Mocking the necessary dependencies
        ExtraFieldUtils extraFieldUtilsMock = Mockito.mock(ExtraFieldUtils.class);
        Mockito.when(extraFieldUtilsMock.mergeLocalFileDataData(Mockito.any())).thenReturn(new byte[]{});
        // Assuming we have a way to set the mocked ExtraFieldUtils in the ZipArchiveEntry
        ziparchiveentry.setExtra();
        // Verify that the setExtra method behaves as expected
        // You can add assertions based on the expected state of ziparchiveentry after calling setExtra
        // For example, if you expect some internal state to change, you can assert that here
        // assertEquals(expectedValue, ziparchiveentry.getSomeValue());
    }
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
public void testSetExtraWithNoExtraFields_lmWQ0() throws ZipException, IOException {
    ZipArchiveEntry entry = new ZipArchiveEntry("testEntry");
    entry.setExtra();
    assertArrayEquals(new ZipExtraField[0], entry.getAllExtraFieldsNoCopy());
}
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
public void testSetExtraWithUnparseableExtraFields_QFIJ1_1() throws ZipException, IOException {
    ZipArchiveEntry entry = new ZipArchiveEntry("testEntry");
    entry.setUnparseableExtra(new ZipExtraField[]{new ZipExtraField("unparseableField")});
    entry.setExtra();
    assertNotNull(entry.getAllExtraFieldsNoCopy());}
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
public void testSetExtraWithUnparseableExtraFields_QFIJ1_2() throws ZipException, IOException {
    ZipArchiveEntry entry = new ZipArchiveEntry("testEntry");
    entry.setUnparseableExtra(new ZipExtraField[]{new ZipExtraField("unparseableField")});
    entry.setExtra();
    assertTrue(entry.getAllExtraFieldsNoCopy().length > 0);}
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
public void testSetExtraWithMergedFields_Jhay2_1() throws ZipException, IOException {
    ZipArchiveEntry entry = new ZipArchiveEntry("testEntry");
    entry.setExtraFields(new ZipExtraField[]{new ZipExtraField("field1"), new ZipExtraField("field2")});
    entry.setExtra();
    assertNotNull(entry.getAllExtraFieldsNoCopy());}
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
public void testSetExtraWithMergedFields_Jhay2_2() throws ZipException, IOException {
    ZipArchiveEntry entry = new ZipArchiveEntry("testEntry");
    entry.setExtraFields(new ZipExtraField[]{new ZipExtraField("field1"), new ZipExtraField("field2")});
    entry.setExtra();
    assertEquals(2, entry.getAllExtraFieldsNoCopy().length);}
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
public void testSetExtraWithNoExtraFields_tndB0() throws ZipException {
    ZipArchiveEntry entry = new ZipArchiveEntry("testEntry");
    entry.setExtra();
    assertArrayEquals(ExtraFieldUtils.EMPTY_ZIP_EXTRA_FIELD_ARRAY, entry.getAllExtraFieldsNoCopy());
}
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
public void testSetExtraWithUnparseableExtraField_KThS1() throws ZipException {
    ZipArchiveEntry entry = new ZipArchiveEntry("testEntry");
    ZipExtraField unparseableField = new ZipExtraField() {
    };
    entry.setUnparseableExtra(unparseableField); // Assuming a method to set unparseable extra field
    entry.setExtra();
    assertArrayEquals(new ZipExtraField[]{unparseableField}, entry.getAllExtraFieldsNoCopy());
}
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
public void testSetExtraWithMergedFields_FxRS2() throws ZipException {
    ZipArchiveEntry entry = new ZipArchiveEntry("testEntry");
    ZipExtraField field1 = new ZipExtraField() {
    };
    ZipExtraField field2 = new ZipExtraField() {
    };
    entry.addExtraField(field1); // Assuming a method to add extra fields
    entry.addExtraField(field2); // Assuming a method to add extra fields
    entry.setExtra();
    assertArrayEquals(new ZipExtraField[]{field1, field2}, entry.getAllExtraFieldsNoCopy());
}
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
public void testSetExtraWithNoExtraFields_XGao0_1() throws ZipException {
    ZipArchiveEntry entry = new ZipArchiveEntry("testEntry");
    entry.setExtra();
    assertNotNull(entry.getAllExtraFieldsNoCopy());}
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
public void testSetExtraWithNoExtraFields_XGao0_2() throws ZipException {
    ZipArchiveEntry entry = new ZipArchiveEntry("testEntry");
    entry.setExtra();
    assertEquals(0, entry.getAllExtraFieldsNoCopy().length);}
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
public void testSetExtraWithUnparseableExtraField_AjlM1_1() throws ZipException, IOException {
    ZipArchiveEntry entry = new ZipArchiveEntry(new File("testFile.zip"), "testEntry");
    entry.setExtra();
    assertNotNull(entry.getAllExtraFieldsNoCopy());}
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
public void testSetExtraWithUnparseableExtraField_AjlM1_2() throws ZipException, IOException {
    ZipArchiveEntry entry = new ZipArchiveEntry(new File("testFile.zip"), "testEntry");
    entry.setExtra();
    assertTrue(entry.getAllExtraFieldsNoCopy().length > 0);}
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
public void testSetExtraWithMergedFields_tNGN2_1() throws ZipException {
    ZipArchiveEntry entry = new ZipArchiveEntry("testEntry");
    entry.setExtra();
    ZipExtraField[] extraFields = entry.getAllExtraFieldsNoCopy();
    assertNotNull(extraFields);}
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
public void testSetExtraWithMergedFields_tNGN2_2() throws ZipException {
    ZipArchiveEntry entry = new ZipArchiveEntry("testEntry");
    entry.setExtra();
    ZipExtraField[] extraFields = entry.getAllExtraFieldsNoCopy();
    assertTrue(extraFields.length > 0);}
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
public void testSetExtraWithMergedFields_tNGN2_3() throws ZipException {
    ZipArchiveEntry entry = new ZipArchiveEntry("testEntry");
    entry.setExtra();
    ZipExtraField[] extraFields = entry.getAllExtraFieldsNoCopy();
    assertNotNull(extraFields[extraFields.length - 1]); // Check last field is not null}
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
public void testSetExtra_IEeq0() throws IOException, ZipException {
    ZipArchiveEntry entry = new ZipArchiveEntry("testEntry");
    ExtraFieldUtils mockUtils = Mockito.mock(ExtraFieldUtils.class);
    Mockito.when(mockUtils.mergeLocalFileDataData(Mockito.any())).thenReturn(new byte[]{/* mock data */});
    entry.setExtra();
    assertNotNull(entry.getAllExtraFieldsNoCopy());
}
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
public void testSetExtra_allz0_1() throws ZipException, IOException {
    ZipArchiveEntry entry = new ZipArchiveEntry("testEntry");
    byte[] extraFields = new byte[] { /* mock data */ };
    entry.setExtra(extraFields);
    assertTrue(entry.lastModifiedDateSet);}
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
public void testSetExtra_allz0_2() throws ZipException, IOException {
    ZipArchiveEntry entry = new ZipArchiveEntry("testEntry");
    byte[] extraFields = new byte[] { /* mock data */ };
    entry.setExtra(extraFields);
    assertEquals(expectedTimeInMillis, entry.time);}
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
public void testSetExtra_mOuX0() throws IOException, ZipException {
    Path inputPath = Paths.get("test.zip");
    String entryName = "testEntry";
    ZipArchiveEntry zipEntry = new ZipArchiveEntry(inputPath, entryName);
    zipEntry.setExtra();
    FileTime expectedModifyTime = FileTime.fromMillis(System.currentTimeMillis());
    assertEquals(expectedModifyTime, zipEntry.getLastModifiedTime());
}
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
public void testSetExtraWithNewExtraFields_AimF0_1() throws ZipException, IOException {
    ZipArchiveEntry entry = new ZipArchiveEntry("testEntry");
    ZipExtraField[] extraFields = new ZipExtraField[] {
        new SomeExtraField("field1", "value1"),
        new SomeExtraField("field2", "value2")
    };
    entry.mergeExtraFields(extraFields, true);
    entry.setExtra();
    assertNotNull(entry.getAllExtraFieldsNoCopy());}
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
public void testSetExtraWithNewExtraFields_AimF0_2() throws ZipException, IOException {
    ZipArchiveEntry entry = new ZipArchiveEntry("testEntry");
    ZipExtraField[] extraFields = new ZipExtraField[] {
        new SomeExtraField("field1", "value1"),
        new SomeExtraField("field2", "value2")
    };
    entry.mergeExtraFields(extraFields, true);
    entry.setExtra();
    assertEquals(2, entry.getAllExtraFieldsNoCopy().length);}
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
public void testSetExtraWithNewExtraFields_AimF0_3() throws ZipException, IOException {
    ZipArchiveEntry entry = new ZipArchiveEntry("testEntry");
    ZipExtraField[] extraFields = new ZipExtraField[] {
        new SomeExtraField("field1", "value1"),
        new SomeExtraField("field2", "value2")
    };
    entry.mergeExtraFields(extraFields, true);
    entry.setExtra();
    assertEquals("value1", entry.getExtraField("field1").getValue());}
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
public void testSetExtraWithNewExtraFields_AimF0_4() throws ZipException, IOException {
    ZipArchiveEntry entry = new ZipArchiveEntry("testEntry");
    ZipExtraField[] extraFields = new ZipExtraField[] {
        new SomeExtraField("field1", "value1"),
        new SomeExtraField("field2", "value2")
    };
    entry.mergeExtraFields(extraFields, true);
    entry.setExtra();
    assertEquals("value2", entry.getExtraField("field2").getValue());}
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testSetDataOffset() throws Exception {
        ziparchiveentry = new ZipArchiveEntry();
        long newOffset = 12345L;
        ziparchiveentry.setDataOffset(newOffset);
        // Using reflection to access the private field for assertion
        Field field = ZipArchiveEntry.class.getDeclaredField("dataOffset");
        field.setAccessible(true);
        long actualOffset = (long) field.get(ziparchiveentry);
        assertEquals(newOffset, actualOffset);
    }
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
public void testSetDataOffset_WmgQ0() throws ZipException {
    ZipArchiveEntry entry = new ZipArchiveEntry("testEntry");
    long expectedOffset = 1024L;
    entry.setDataOffset(expectedOffset);
    assertEquals(expectedOffset, entry.dataOffset);
}
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testsetExtraFields_1() throws Exception {
        ziparchiveentry = new ZipArchiveEntry();
        extraFields = new ZipExtraField[] {
            Mockito.mock(ZipExtraField.class),
            Mockito.mock(UnparseableExtraFieldData.class)
        };
        unparseableExtra = (UnparseableExtraFieldData) extraFields[1];
        ziparchiveentry.setExtraFields(extraFields);
        ziparchiveentry.setExtraFields(new ZipExtraField[] { unparseableExtra });
        assertNotNull(ziparchiveentry.extraFields);}
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testsetExtraFields_2() throws Exception {
        ziparchiveentry = new ZipArchiveEntry();
        extraFields = new ZipExtraField[] {
            Mockito.mock(ZipExtraField.class),
            Mockito.mock(UnparseableExtraFieldData.class)
        };
        unparseableExtra = (UnparseableExtraFieldData) extraFields[1];
        ziparchiveentry.setExtraFields(extraFields);
        ziparchiveentry.setExtraFields(new ZipExtraField[] { unparseableExtra });
        assertEquals(1, zextraFieldsh);}
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testsetExtraFields_3() throws Exception {
        ziparchiveentry = new ZipArchiveEntry();
        extraFields = new ZipExtraField[] {
            Mockito.mock(ZipExtraField.class),
            Mockito.mock(UnparseableExtraFieldData.class)
        };
        unparseableExtra = (UnparseableExtraFieldData) extraFields[1];
        ziparchiveentry.setExtraFields(extraFields);
        ziparchiveentry.setExtraFields(new ZipExtraField[] { unparseableExtra });
        assertEquals(extraFields[0], ziparchiveentry.extraFields[0]);}
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testsetExtraFields_4() throws Exception {
        ziparchiveentry = new ZipArchiveEntry();
        extraFields = new ZipExtraField[] {
            Mockito.mock(ZipExtraField.class),
            Mockito.mock(UnparseableExtraFieldData.class)
        };
        unparseableExtra = (UnparseableExtraFieldData) extraFields[1];
        ziparchiveentry.setExtraFields(extraFields);
        ziparchiveentry.setExtraFields(new ZipExtraField[] { unparseableExtra });
        assertNull(ziparchiveentry.unparseableExtra);}
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testsetExtraFields_5() throws Exception {
        ziparchiveentry = new ZipArchiveEntry();
        extraFields = new ZipExtraField[] {
            Mockito.mock(ZipExtraField.class),
            Mockito.mock(UnparseableExtraFieldData.class)
        };
        unparseableExtra = (UnparseableExtraFieldData) extraFields[1];
        ziparchiveentry.setExtraFields(extraFields);
        ziparchiveentry.setExtraFields(new ZipExtraField[] { unparseableExtra });
        assertNotNull(ziparchiveentry.unparseableExtra);}
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testsetExtraFields_6() throws Exception {
        ziparchiveentry = new ZipArchiveEntry();
        extraFields = new ZipExtraField[] {
            Mockito.mock(ZipExtraField.class),
            Mockito.mock(UnparseableExtraFieldData.class)
        };
        unparseableExtra = (UnparseableExtraFieldData) extraFields[1];
        ziparchiveentry.setExtraFields(extraFields);
        ziparchiveentry.setExtraFields(new ZipExtraField[] { unparseableExtra });
        assertEquals(unparseableExtra);}
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testsetExtraFields_7() throws Exception {
        ziparchiveentry = new ZipArchiveEntry();
        extraFields = new ZipExtraField[] {
            Mockito.mock(ZipExtraField.class),
            Mockito.mock(UnparseableExtraFieldData.class)
        };
        unparseableExtra = (UnparseableExtraFieldData) extraFields[1];
        ziparchiveentry.setExtraFields(extraFields);
        ziparchiveentry.setExtraFields(new ZipExtraField[] { unparseableExtra });
        assertEquals(0, zextraFieldsh);}
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testSetCommentSource() throws Exception {
        ziparchiveentry = new ZipArchiveEntry("testEntry.zip");
        ziparchiveentry.setCommentSource(CommentSource.UNICODE_EXTRA_FIELD);
        assertEquals(CommentSource.UNICODE_EXTRA_FIELD, ziparchiveentry.getCommentSource());
    }
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
public void testSetExtraFieldsWithNull_gdXH0_1() {
    ZipArchiveEntry entry = new ZipArchiveEntry("testEntry");
    entry.setExtraFields(null);
    assertArrayEquals(ExtraFieldUtils.EMPTY_ZIP_EXTRA_FIELD_ARRAY, entry.extraFields);}
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
public void testSetExtraFieldsWithNull_gdXH0_2() {
    ZipArchiveEntry entry = new ZipArchiveEntry("testEntry");
    entry.setExtraFields(null);
    assertNull(entry.unparseableExtra);}
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
public void testSetExtraFieldsWithEmptyArray_danY1_1() {
    ZipExtraField[] fields = new ZipExtraField[0];
    ZipArchiveEntry entry = new ZipArchiveEntry("testEntry");
    entry.setExtraFields(fields);
    assertArrayEquals(ExtraFieldUtils.EMPTY_ZIP_EXTRA_FIELD_ARRAY, entry.extraFields);}
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
public void testSetExtraFieldsWithEmptyArray_danY1_2() {
    ZipExtraField[] fields = new ZipExtraField[0];
    ZipArchiveEntry entry = new ZipArchiveEntry("testEntry");
    entry.setExtraFields(fields);
    assertNull(entry.unparseableExtra);}
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
public void testSetExtraFieldsWithValidFields_FEQm2_1() {
    ZipExtraField field1 = new SomeValidZipExtraField(); // Assume this is a valid implementation
    ZipExtraField field2 = new SomeOtherValidZipExtraField(); // Assume this is a valid implementation
    ZipExtraField[] fields = new ZipExtraField[]{field1, field2};
    ZipArchiveEntry entry = new ZipArchiveEntry("testEntry");
    entry.setExtraFields(fields);
    assertArrayEquals(new ZipExtraField[]{field1, field2}, entry.extraFields);}
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
public void testSetExtraFieldsWithValidFields_FEQm2_2() {
    ZipExtraField field1 = new SomeValidZipExtraField(); // Assume this is a valid implementation
    ZipExtraField field2 = new SomeOtherValidZipExtraField(); // Assume this is a valid implementation
    ZipExtraField[] fields = new ZipExtraField[]{field1, field2};
    ZipArchiveEntry entry = new ZipArchiveEntry("testEntry");
    entry.setExtraFields(fields);
    assertNull(entry.unparseableExtra);}
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
public void testSetExtraFieldsWithUnparseableField_XEQO3_1() {
    ZipExtraField unparseableField = new UnparseableExtraFieldData(); // Assume this is a valid implementation
    ZipExtraField validField = new SomeValidZipExtraField(); // Assume this is a valid implementation
    ZipExtraField[] fields = new ZipExtraField[]{unparseableField, validField};
    ZipArchiveEntry entry = new ZipArchiveEntry("testEntry");
    entry.setExtraFields(fields);
    assertArrayEquals(new ZipExtraField[]{validField}, entry.extraFields);}
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
public void testSetExtraFieldsWithUnparseableField_XEQO3_2() {
    ZipExtraField unparseableField = new UnparseableExtraFieldData(); // Assume this is a valid implementation
    ZipExtraField validField = new SomeValidZipExtraField(); // Assume this is a valid implementation
    ZipExtraField[] fields = new ZipExtraField[]{unparseableField, validField};
    ZipArchiveEntry entry = new ZipArchiveEntry("testEntry");
    entry.setExtraFields(fields);
    assertNotNull(entry.unparseableExtra);}
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
public void testSetExtraFieldsWithUnparseableField_XEQO3_3() {
    ZipExtraField unparseableField = new UnparseableExtraFieldData(); // Assume this is a valid implementation
    ZipExtraField validField = new SomeValidZipExtraField(); // Assume this is a valid implementation
    ZipExtraField[] fields = new ZipExtraField[]{unparseableField, validField};
    ZipArchiveEntry entry = new ZipArchiveEntry("testEntry");
    entry.setExtraFields(fields);
    assertEquals(unparseableField, entry.unparseableExtra);}
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
public void testSetCommentSourceWithComment_QVmW0() {
    ZipArchiveEntry entry = new ZipArchiveEntry("test.zip");
    entry.setCommentSource(CommentSource.COMMENT);
    assertEquals(CommentSource.COMMENT, entry.getCommentSource());
}
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
public void testSetCommentSourceWithUnicodeExtraField_yOqT1() {
    ZipArchiveEntry entry = new ZipArchiveEntry("test.zip");
    entry.setCommentSource(CommentSource.UNICODE_EXTRA_FIELD);
    assertEquals(CommentSource.UNICODE_EXTRA_FIELD, entry.getCommentSource());
}
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testgetUnparseableExtraFieldData_1() throws Exception {
        unparseableExtra = Mockito.mock(UnparseableExtraFieldData.class);
        ziparchiveentry = Mockito.spy(new ZipArchiveEntry());
        Mockito.when(ziparchiveentry.getUnparseableExtraFieldData()).thenReturn(unparseableExtra);
        UnparseableExtraFieldData result = ziparchiveentry.getUnparseableExtraFieldData();
        assertNotNull(result);}
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testgetUnparseableExtraFieldData_2() throws Exception {
        unparseableExtra = Mockito.mock(UnparseableExtraFieldData.class);
        ziparchiveentry = Mockito.spy(new ZipArchiveEntry());
        Mockito.when(ziparchiveentry.getUnparseableExtraFieldData()).thenReturn(unparseableExtra);
        UnparseableExtraFieldData result = ziparchiveentry.getUnparseableExtraFieldData();
        assertSame(unparseableExtra, result);}
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
public void testGetUnparseableExtraFieldData_ksIT0_1() throws IOException {
    File inputFile = new File("path/to/your/file.zip");
    String entryName = "entryName";
    ZipArchiveEntry zipEntry = new ZipArchiveEntry(inputFile, entryName);
    UnparseableExtraFieldData result = zipEntry.getUnparseableExtraFieldData();
    assertNotNull(result);}
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
public void testGetUnparseableExtraFieldData_ksIT0_2() throws IOException {
    File inputFile = new File("path/to/your/file.zip");
    String entryName = "entryName";
    ZipArchiveEntry zipEntry = new ZipArchiveEntry(inputFile, entryName);
    UnparseableExtraFieldData result = zipEntry.getUnparseableExtraFieldData();
    assertArrayEquals(new byte[0], result.getCentralDirectoryData());}
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
public void testGetUnparseableExtraFieldData_ksIT0_3() throws IOException {
    File inputFile = new File("path/to/your/file.zip");
    String entryName = "entryName";
    ZipArchiveEntry zipEntry = new ZipArchiveEntry(inputFile, entryName);
    UnparseableExtraFieldData result = zipEntry.getUnparseableExtraFieldData();
    assertEquals(new ZipShort(0), result.getHeaderId());}
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
public void testGetUnparseableExtraFieldData_ksIT0_4() throws IOException {
    File inputFile = new File("path/to/your/file.zip");
    String entryName = "entryName";
    ZipArchiveEntry zipEntry = new ZipArchiveEntry(inputFile, entryName);
    UnparseableExtraFieldData result = zipEntry.getUnparseableExtraFieldData();
    assertArrayEquals(new byte[0], result.getLocalFileDataData());}
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
public void testGetUnparseableExtraFieldData_ksIT0_5() throws IOException {
    File inputFile = new File("path/to/your/file.zip");
    String entryName = "entryName";
    ZipArchiveEntry zipEntry = new ZipArchiveEntry(inputFile, entryName);
    UnparseableExtraFieldData result = zipEntry.getUnparseableExtraFieldData();
    assertEquals(new ZipShort(0), result.getLocalFileDataLength());}
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
public void testGetUnparseableExtraFieldData_ksIT0_6() throws IOException {
    File inputFile = new File("path/to/your/file.zip");
    String entryName = "entryName";
    ZipArchiveEntry zipEntry = new ZipArchiveEntry(inputFile, entryName);
    UnparseableExtraFieldData result = zipEntry.getUnparseableExtraFieldData();
    assertEquals(new ZipShort(0), result.getCentralDirectoryLength());}
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testSetName_ValidName_ChangesName() throws Exception {
        ziparchiveentry = new ZipArchiveEntry("initialName");
        String newName = "newName";
        ziparchiveentry.setName(newName);
        assertEquals(newName, ziparchiveentry.getName());
    }
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testSetName_NullName_SetsNameToNull() throws Exception {
        ziparchiveentry = new ZipArchiveEntry("initialName");
        ziparchiveentry.setName(null);
        assertNull(ziparchiveentry.getName());
    }
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testSetName_ValidName_ChangesNameToUnixStyle() throws Exception {
        ziparchiveentry = new ZipArchiveEntry("initialName");
        String newName = "folder\\file.txt";
        ziparchiveentry.setName(newName);
        assertEquals("folder/file.txt", ziparchiveentry.getName());
    }
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testSetName_ValidName_NoChangeIfAlreadyUnixStyle() throws Exception {
        ziparchiveentry = new ZipArchiveEntry("initialName");
        String newName = "folder/file.txt";
        ziparchiveentry.setName(newName);
        assertEquals(newName, ziparchiveentry.getName());
    }
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testSetName_EmptyString_SetsNameToEmpty() throws Exception {
        ziparchiveentry = new ZipArchiveEntry("initialName");
        ziparchiveentry.setName("");
        assertEquals("", ziparchiveentry.getName());
    }
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testSetSize_ValidSize() {
        ziparchiveentry = new ZipArchiveEntry();
        long validSize = 100L;
        ziparchiveentry.setSize(validSize);
        assertEquals(validSize, ziparchiveentry.getSize());
    }
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testSetSize_NegativeSize_1() {
        ziparchiveentry = new ZipArchiveEntry();
        long negativeSize = -1L;
        IllegalArgumentException exception = assertThrows(IllegalArgumentException.class, () -> {
            ziparchiveentry.setSize(negativeSize);
        });}
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testSetSize_NegativeSize_2() {
        ziparchiveentry = new ZipArchiveEntry();
        long negativeSize = -1L;
        assertEquals("Invalid entry size", exception.getMessage());}
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
public void testSetNameWithValidNameOnFATPlatform_mJDb0() {
    ZipArchiveEntry entry = new ZipArchiveEntry("testEntry");
    entry.setPlatform(ZipArchiveEntry.PLATFORM_FAT);
    entry.setName("validName");
    assertEquals("validName", entry.getName());
}
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
public void testSetNameWithBackslashesOnFATPlatform_exhH1() {
    ZipArchiveEntry entry = new ZipArchiveEntry("testEntry");
    entry.setPlatform(ZipArchiveEntry.PLATFORM_FAT);
    entry.setName("valid\\Name");
    assertEquals("valid/Name", entry.getName());
}
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
public void testSetNameWithNullName_PKfk2() {
    ZipArchiveEntry entry = new ZipArchiveEntry("testEntry");
    entry.setName(null);
    assertNull(entry.getName());
}
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
public void testSetNameOnNonFATPlatform_Tayu3() {
    ZipArchiveEntry entry = new ZipArchiveEntry("testEntry");
    entry.setPlatform(ZipArchiveEntry.PLATFORM_OTHER);
    entry.setName("validName");
    assertEquals("validName", entry.getName());
}
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
public void testSetSizeValid_mLiT0() {
    ZipArchiveEntry entry = new ZipArchiveEntry("testEntry");
    entry.setSize(1000);
    assertEquals(1000, entry.getSize());
}
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testIsStreamContiguous_1() throws Exception {
        ziparchiveentry = new ZipArchiveEntry("testEntry");
        // Directly setting the private field for testing purposes
        Field field = ZipArchiveEntry.class.getDeclaredField("isStreamContiguous");
        field.setAccessible(true);
        field.set(ziparchiveentry, true); // Set to true for this test case
        // Change the state to false for another assertion
        Field field = ZipArchiveEntry.class.getDeclaredField("isStreamContiguous");
        field.setAccessible(true);
        field.set(ziparchiveentry, false); // Set to false for this test case
        assertTrue(ziparchiveentry.isStreamContiguous(), "Expected isStreamContiguous to be true");}
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testIsStreamContiguous_2() throws Exception {
        ziparchiveentry = new ZipArchiveEntry("testEntry");
        // Directly setting the private field for testing purposes
        Field field = ZipArchiveEntry.class.getDeclaredField("isStreamContiguous");
        field.setAccessible(true);
        field.set(ziparchiveentry, true); // Set to true for this test case
        // Change the state to false for another assertion
        Field field = ZipArchiveEntry.class.getDeclaredField("isStreamContiguous");
        field.setAccessible(true);
        field.set(ziparchiveentry, false); // Set to false for this test case
        assertFalse(ziparchiveentry.isStreamContiguous(), "Expected isStreamContiguous to be false");}
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
public void testIsStreamContiguous_eljA0() throws ZipException {
    ZipArchiveEntry entry = new ZipArchiveEntry("testEntry");
    entry.isStreamContiguous = true; 
    assertTrue(entry.isStreamContiguous());
}
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testhashCode() throws Exception {
        ziparchiveentry = Mockito.mock(ZipArchiveEntry.class);
        Mockito.when(ziparchiveentry.getName()).thenReturn("testEntry");
        int expectedHashCode = "testEntry".hashCode();
        assertEquals(expectedHashCode, ziparchiveentry.hashCode());
    }
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
public void testHashCodeWithName_WzNh0() throws ZipException {
    ZipArchiveEntry entry1 = new ZipArchiveEntry("test.txt");
    ZipArchiveEntry entry2 = new ZipArchiveEntry("test.txt");
    assertEquals(entry1.hashCode(), entry2.hashCode());
}
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
public void testHashCodeWithDifferentNames_DNAp1() throws ZipException {
    ZipArchiveEntry entry1 = new ZipArchiveEntry("test1.txt");
    ZipArchiveEntry entry2 = new ZipArchiveEntry("test2.txt");
    assertNotEquals(entry1.hashCode(), entry2.hashCode());
}
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
public void testHashCodeWithNullName_uWLk2() throws ZipException {
    ZipArchiveEntry entry = new ZipArchiveEntry((String) null);
    assertEquals(0, entry.hashCode());
}
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testSetPlatform() throws Exception {
        ziparchiveentry = new ZipArchiveEntry("testEntry");
        ziparchiveentry.setPlatform(PLATFORM_UNIX);
        Field platformField = ZipArchiveEntry.class.getDeclaredField("platform");
        platformField.setAccessible(true);
        int actualPlatform = (int) platformField.get(ziparchiveentry);
        assertEquals(PLATFORM_UNIX, actualPlatform);
    }
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
public void testSetPlatform_DGXa0() {
    ZipArchiveEntry entry = new ZipArchiveEntry("testEntry");
    entry.setPlatform(5);
    assertEquals(5, entry.platform);
}
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testSetVersionMadeBy() throws Exception {
        ziparchiveentry = new ZipArchiveEntry("testEntry");
        versionMadeBy = 20;
        ziparchiveentry.setVersionMadeBy(versionMadeBy);
        Field field = ZipArchiveEntry.class.getDeclaredField("versionMadeBy");
        field.setAccessible(true);
        int actualVersionMadeBy = (int) field.get(ziparchiveentry);
        assertEquals(versionMadeBy, actualVersionMadeBy);
    }
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
public void testSetVersionMadeBy_SJQX0() throws ZipException {
    ZipArchiveEntry entry = new ZipArchiveEntry("testEntry.zip");
    entry.setVersionMadeBy(20);
    assertEquals(20, entry.getVersionMadeBy());
}
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testGetLocalHeaderOffset() throws Exception {
        ziparchiveentry = new ZipArchiveEntry("testEntry");
        long offset = ziparchiveentry.getLocalHeaderOffset();
        assertEquals(OFFSET_UNKNOWN, offset);
    }
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testgetNameSource() throws Exception {
        ziparchiveentry = new ZipArchiveEntry("testEntry");
        NameSource result = ziparchiveentry.getNameSource();
        assertEquals(nameSource, result);
    }
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
public void testGetLocalHeaderOffset_woVh0() throws ZipException {
    ZipArchiveEntry entry = new ZipArchiveEntry("testEntry.zip");
    long expectedOffset = 0; // Set the expected value based on your logic
    entry.localHeaderOffset = expectedOffset; // Assuming you can set this for testing
    assertEquals(expectedOffset, entry.getLocalHeaderOffset());
}
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
public void testGetNameSource_JsMA0() throws IOException {
    ZipArchiveEntry entry = new ZipArchiveEntry(new File("test.zip"), "testEntry");
    entry.nameSource = NameSource.SOME_SOURCE; // Assuming nameSource is set to a valid value
    assertEquals(NameSource.SOME_SOURCE, entry.getNameSource());
}
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testSetLocalHeaderOffset() throws Exception {
        ziparchiveentry = new ZipArchiveEntry();
        long newOffset = 100L;
        ziparchiveentry.setLocalHeaderOffset(newOffset);
        // Use reflection to access the private field localHeaderOffset
        Field field = ZipArchiveEntry.class.getDeclaredField("localHeaderOffset");
        field.setAccessible(true);
        long actualOffset = (long) field.get(ziparchiveentry);
        assertEquals(newOffset, actualOffset);
    }
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
public void testSetLocalHeaderOffset_Pywl0() throws ZipException {
    ZipArchiveEntry entry = new ZipArchiveEntry("testEntry");
    long expectedOffset = 1024L;
    entry.setLocalHeaderOffset(expectedOffset);
    assertEquals(expectedOffset, entry.localHeaderOffset);
}
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testsetExternalAttributes() throws Exception {
        ziparchiveentry = new ZipArchiveEntry();
        externalAttributes = 12345L; // Example value for testing
        ziparchiveentry.setExternalAttributes(externalAttributes);
        assertEquals(externalAttributes, ziparchiveentry.getExternalAttributes());
    }
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
public void testSetExternalAttributes_jPLk0() throws ZipException {
    ZipArchiveEntry entry = new ZipArchiveEntry("testEntry");
    long expectedValue = 123456789L;
    entry.setExternalAttributes(expectedValue);
    assertEquals(expectedValue, entry.externalAttributes);
}
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testSetCentralDirectoryExtra() throws Exception {
        ziparchiveentry = new ZipArchiveEntry("testEntry");
        byte[] extraData = new byte[]{1, 2, 3, 4}; // Example byte array
        // Assuming mergeExtraFields and parseExtraFields are private methods,
        // we can use a spy to verify their interactions.
        ZipArchiveEntry spyEntry = Mockito.spy(ziparchiveentry);
        spyEntry.setCentralDirectoryExtra(extraData);
        Mockito.verify(spyEntry).mergeExtraFields(Mockito.any(), Mockito.eq(false));
    }
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testSetCentralDirectoryExtraThrowsIllegalArgumentException_1() {
        ziparchiveentry = new ZipArchiveEntry("testEntry");
        byte[] extraData = new byte[]{1, 2, 3, 4}; // Example byte array
        ZipArchiveEntry spyEntry = Mockito.spy(ziparchiveentry);
        Mockito.doThrow(new ZipException("Test Exception")).when(spyEntry).mergeExtraFields(Mockito.any(), Mockito.eq(false));
        IllegalArgumentException thrown = assertThrows(IllegalArgumentException.class, () -> {
            spyEntry.setCentralDirectoryExtra(extraData);
        });}
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testSetCentralDirectoryExtraThrowsIllegalArgumentException_2() {
        ziparchiveentry = new ZipArchiveEntry("testEntry");
        byte[] extraData = new byte[]{1, 2, 3, 4}; // Example byte array
        ZipArchiveEntry spyEntry = Mockito.spy(ziparchiveentry);
        Mockito.doThrow(new ZipException("Test Exception")).when(spyEntry).mergeExtraFields(Mockito.any(), Mockito.eq(false));
        assertEquals("Test Exception", thrown.getMessage());}
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testSetExtra_ValidInput() throws Exception {
        ziparchiveentry = new ZipArchiveEntry("testEntry");
        byte[] extra = new byte[]{1, 2, 3, 4}; // Example valid extra field data
        assertDoesNotThrow(() -> ziparchiveentry.setExtra(extra));
    }
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testSetExtra_InvalidInput_1() {
        ziparchiveentry = new ZipArchiveEntry("testEntry");
        byte[] extra = new byte[]{-1}; // Example invalid extra field data that causes ZipException
        IllegalArgumentException thrown = assertThrows(IllegalArgumentException.class, () -> ziparchiveentry.setExtra(extra));}
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testSetExtra_InvalidInput_2() {
        ziparchiveentry = new ZipArchiveEntry("testEntry");
        byte[] extra = new byte[]{-1}; // Example invalid extra field data that causes ZipException
        assertTrue(thrown.getMessage().contains("Error parsing extra fields for entry: testEntry"));}
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
public void testSetCentralDirectoryExtra_ValidInput_aTwA0() {
    ZipArchiveEntry entry = new ZipArchiveEntry("testEntry");
    byte[] extraFields = new byte[]{0x01, 0x02, 0x03}; // Example valid byte array
    entry.setCentralDirectoryExtra(extraFields);
    assertArrayEquals(extraFields, entry.getCentralDirectoryExtra());
}
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testGetExtraFields_WithIncludeUnparseable() throws Exception {
        ziparchiveentry = new ZipArchiveEntry("testEntry");
        ZipExtraField[] expectedFields = new ZipExtraField[] { /* mock or create expected fields */ };
        when(ziparchiveentry.getAllExtraFields()).thenReturn(expectedFields);
        ZipExtraField[] actualFields = ziparchiveentry.getExtraFields(true);
        assertArrayEquals(expectedFields, actualFields);
    }
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testGetExtraFields_WithoutIncludeUnparseable() throws Exception {
        ziparchiveentry = new ZipArchiveEntry("testEntry");
        ZipExtraField[] expectedFields = new ZipExtraField[] { /* mock or create expected parseable fields */ };
        when(ziparchiveentry.getParseableExtraFields()).thenReturn(expectedFields);
        ZipExtraField[] actualFields = ziparchiveentry.getExtraFields(false);
        assertArrayEquals(expectedFields, actualFields);
    }
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
public void testSetExtraWithValidData_KucL0() {
    ZipArchiveEntry entry = new ZipArchiveEntry("testEntry");
    byte[] extra = new byte[]{1, 2, 3, 4};
    entry.setExtra(extra);
    assertArrayEquals(extra, entry.getExtraFields());
}
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
public void testSetExtraWithEmptyArray_cRGH2() {
    ZipArchiveEntry entry = new ZipArchiveEntry("testEntry");
    byte[] extra = new byte[]{};
    entry.setExtra(extra);
    assertArrayEquals(extra, entry.getExtraFields());
}
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
public void testSetExtraWithLargeData_WioQ3() {
    ZipArchiveEntry entry = new ZipArchiveEntry("testEntry");
    byte[] extra = new byte[1000]; // Large data
    entry.setExtra(extra);
    assertArrayEquals(extra, entry.getExtraFields());
}
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
public void testSetExtraWithMultipleCalls_SOMn5() {
    ZipArchiveEntry entry = new ZipArchiveEntry("testEntry");
    byte[] extra1 = new byte[]{1, 2};
    byte[] extra2 = new byte[]{3, 4};
    entry.setExtra(extra1);
    entry.setExtra(extra2);
    assertArrayEquals(extra2, entry.getExtraFields());
}
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
public void testSetExtraWithDifferentDataTypes_NWLu6() {
    ZipArchiveEntry entry = new ZipArchiveEntry("testEntry");
    byte[] extra = new byte[]{0, 1, 2, 3, 4, 5};
    entry.setExtra(extra);
    assertArrayEquals(extra, entry.getExtraFields());
}
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
public void testSetExtraWithBoundaryValues_CFGt7() {
    ZipArchiveEntry entry = new ZipArchiveEntry("testEntry");
    byte[] extra = new byte[]{Byte.MIN_VALUE, Byte.MAX_VALUE};
    entry.setExtra(extra);
    assertArrayEquals(extra, entry.getExtraFields());
}
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
public void testSetExtraWithRandomData_bhPL8() {
    ZipArchiveEntry entry = new ZipArchiveEntry("testEntry");
    byte[] extra = new byte[]{10, 20, 30, 40, 50};
    entry.setExtra(extra);
    assertArrayEquals(extra, entry.getExtraFields());
}
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
public void testGetExtraFieldsWithIncludeUnparseable_CBjH0_1() throws ZipException {
    ZipArchiveEntry entry = new ZipArchiveEntry("testEntry");
    ZipExtraField[] extraFields = entry.getExtraFields(true);
    assertNotNull(extraFields);}
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
public void testGetExtraFieldsWithIncludeUnparseable_CBjH0_2() throws ZipException {
    ZipArchiveEntry entry = new ZipArchiveEntry("testEntry");
    ZipExtraField[] extraFields = entry.getExtraFields(true);
    assertTrue(extraFields.length > 0); // Adjust based on expected behavior}
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
public void testGetExtraFieldsWithoutIncludeUnparseable_egyl1_1() throws ZipException {
    ZipArchiveEntry entry = new ZipArchiveEntry("testEntry");
    ZipExtraField[] extraFields = entry.getExtraFields(false);
    assertNotNull(extraFields);}
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
public void testGetExtraFieldsWithoutIncludeUnparseable_egyl1_2() throws ZipException {
    ZipArchiveEntry entry = new ZipArchiveEntry("testEntry");
    ZipExtraField[] extraFields = entry.getExtraFields(false);
    assertEquals(0, extraFields.length); // Adjust based on expected behavior}
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
public void testGetExtraFieldsWithIncludeUnparseable_Vqja0_1() throws ZipException {
    ZipArchiveEntry entry = new ZipArchiveEntry("testEntry");
    ZipExtraField[] extraFields = entry.getExtraFields(true);
    assertNotNull(extraFields);}
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
public void testGetExtraFieldsWithIncludeUnparseable_Vqja0_2() throws ZipException {
    ZipArchiveEntry entry = new ZipArchiveEntry("testEntry");
    ZipExtraField[] extraFields = entry.getExtraFields(true);
    assertEquals(expectedNumberOfExtraFields, extraFields.length);}
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
public void testGetExtraFieldsWithoutIncludeUnparseable_OfKa1_1() throws ZipException {
    ZipArchiveEntry entry = new ZipArchiveEntry("testEntry");
    ZipExtraField[] extraFields = entry.getExtraFields(false);
    assertNotNull(extraFields);}
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
public void testGetExtraFieldsWithoutIncludeUnparseable_OfKa1_2() throws ZipException {
    ZipArchiveEntry entry = new ZipArchiveEntry("testEntry");
    ZipExtraField[] extraFields = entry.getExtraFields(false);
    assertEquals(expectedNumberOfParseableExtraFields, extraFields.length);}
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
public void testGetExtraFieldsWithParseableFields_FHCl0_1() throws ZipException {
    ZipArchiveEntry entry = new ZipArchiveEntry("testEntry");
    ZipExtraField[] extraFields = entry.getExtraFields(false);
    assertNotNull(extraFields);}
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
public void testGetExtraFieldsWithParseableFields_FHCl0_2() throws ZipException {
    ZipArchiveEntry entry = new ZipArchiveEntry("testEntry");
    ZipExtraField[] extraFields = entry.getExtraFields(false);
    assertEquals(ExtraFieldUtils.EMPTY_ZIP_EXTRA_FIELD_ARRAY, extraFields);}
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
public void testGetExtraFieldsWithUnparseableFields_oDaJ1_1() throws ZipException {
    ZipArchiveEntry entry = new ZipArchiveEntry("testEntry");
    ZipExtraField[] extraFields = entry.getExtraFields(true);
    assertNotNull(extraFields);}
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
public void testGetExtraFieldsWithUnparseableFields_oDaJ1_2() throws ZipException {
    ZipArchiveEntry entry = new ZipArchiveEntry("testEntry");
    ZipExtraField[] extraFields = entry.getExtraFields(true);
    assertEquals(ExtraFieldUtils.EMPTY_ZIP_EXTRA_FIELD_ARRAY, extraFields);}
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testGetMethod() throws Exception {
        ziparchiveentry = new ZipArchiveEntry();
        int result = ziparchiveentry.getMethod();
        assertEquals(method, result);
    }
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
public void testGetMethod_Yzyc0() throws ZipException {
    ZipArchiveEntry entry = new ZipArchiveEntry("testEntry");
    assertEquals(0, entry.getMethod()); // Replace 0 with the expected value based on your logic
}
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testgetExtraField_1() throws Exception {
        mockExtraField = Mockito.mock(ZipExtraField.class);
        mockZipShort = Mockito.mock(ZipShort.class);
        extraFields = new ArrayList<>();
        extraFields.add(mockExtraField);
        ziparchiveentry = Mockito.spy(new ZipArchiveEntry("testEntry"));
        Mockito.doReturn(extraFields).when(ziparchiveentry).getExtraFields();
        Mockito.when(mockExtraField.getHeaderId()).thenReturn(mockZipShort);
        Mockito.when(mockZipShort.equals(mockZipShort)).thenReturn(true);
        ZipExtraField result = ziparchiveentry.getExtraField(mockZipShort);
        Assertions.assertNotNull(result);}
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testgetExtraField_2() throws Exception {
        mockExtraField = Mockito.mock(ZipExtraField.class);
        mockZipShort = Mockito.mock(ZipShort.class);
        extraFields = new ArrayList<>();
        extraFields.add(mockExtraField);
        ziparchiveentry = Mockito.spy(new ZipArchiveEntry("testEntry"));
        Mockito.doReturn(extraFields).when(ziparchiveentry).getExtraFields();
        Mockito.when(mockExtraField.getHeaderId()).thenReturn(mockZipShort);
        Mockito.when(mockZipShort.equals(mockZipShort)).thenReturn(true);
        ZipExtraField result = ziparchiveentry.getExtraField(mockZipShort);
        Assertions.assertEquals(mockExtraField, result);}
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testGetTime_WhenLastModifiedDateSet() throws Exception {
        ziparchiveentry = new ZipArchiveEntry("testEntry");
        // Mock the behavior of getLastModifiedTime
        ziparchiveentry.lastModifiedDateSet = true;
        long expectedTime = 1000L; // Example expected time in milliseconds
        // Use reflection to set the private time field
        Field timeField = ZipArchiveEntry.class.getDeclaredField("time");
        timeField.setAccessible(true);
        timeField.set(ziparchiveentry, expectedTime);
        // Call the method under test
        long actualTime = ziparchiveentry.getTime();
        // Assert the expected outcome
        assertEquals(expectedTime, actualTime);
    }
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testGetTime_WhenTimeIsSet() throws Exception {
        ziparchiveentry = new ZipArchiveEntry("testEntry");
        long expectedTime = 2000L; // Example expected time in milliseconds
        zlastModifiedDateSete;
        // Use reflection to set the private time field
        Field timeField = ZipArchiveEntry.class.getDeclaredField("time");
        timeField.setAccessible(true);
        timeField.set(ziparchiveentry, expectedTime);
        // Call the method under test
        long actualTime = ziparchiveentry.getTime();
        // Assert the expected outcome
        assertEquals(expectedTime, actualTime);
    }
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testGetTime_WhenTimeIsNotSet() throws Exception {
        ziparchiveentry = new ZipArchiveEntry("testEntry");
        zlastModifiedDateSete;
        // Use reflection to set the private time field to -1
        Field timeField = ZipArchiveEntry.class.getDeclaredField("time");
        timeField.setAccessible(true);
        timeField.set(ziparchiveentry, -1L);
        // Call the method under test
        long actualTime = ziparchiveentry.getTime();
        // Assert the expected outcome (assuming super.getTime() returns a default value)
        long expectedTime = ziparchiveentry.super.getTime(); // Replace with actual expected value from super.getTime()
        assertEquals(expectedTime, actualTime);
    }
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
public void testGetExtraFieldWithExistingType_Rwot0() {
    ZipShort type = new ZipShort(1);
    ZipExtraField extraField = new ZipExtraField();
    ZipArchiveEntry entry = new ZipArchiveEntry("testEntry");
    entry.extraFields = new ZipExtraField[]{extraField};
    assertEquals(extraField, entry.getExtraField(type));
}
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
public void testGetExtraFieldWithNonExistingType_xFTs1() {
    ZipShort type = new ZipShort(2);
    ZipExtraField extraField = new ZipExtraField();
    ZipArchiveEntry entry = new ZipArchiveEntry("testEntry");
    entry.extraFields = new ZipExtraField[]{extraField};
    assertNull(entry.getExtraField(type));
}
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
public void testGetExtraFieldWithNullExtraFields_CAqI2() {
    ZipShort type = new ZipShort(1);
    ZipArchiveEntry entry = new ZipArchiveEntry("testEntry");
    entry.extraFields = null;
    assertNull(entry.getExtraField(type));
}
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
public void testGetExtraFieldWithMultipleFields_UwaO3_1() {
    ZipShort type1 = new ZipShort(1);
    ZipShort type2 = new ZipShort(2);
    ZipExtraField extraField1 = new ZipExtraField();
    ZipExtraField extraField2 = new ZipExtraField();
    ZipArchiveEntry entry = new ZipArchiveEntry("testEntry");
    entry.extraFields = new ZipExtraField[]{extraField1, extraField2};
    assertEquals(extraField1, entry.getExtraField(type1));}
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
public void testGetExtraFieldWithMultipleFields_UwaO3_2() {
    ZipShort type1 = new ZipShort(1);
    ZipShort type2 = new ZipShort(2);
    ZipExtraField extraField1 = new ZipExtraField();
    ZipExtraField extraField2 = new ZipExtraField();
    ZipArchiveEntry entry = new ZipArchiveEntry("testEntry");
    entry.extraFields = new ZipExtraField[]{extraField1, extraField2};
    assertEquals(extraField2, entry.getExtraField(type2));}
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testsetLastModifiedTime_1() throws Exception {
        ziparchiveentry = new ZipArchiveEntry("testEntry");
        FileTime fileTime = FileTime.fromMillis(System.currentTimeMillis());
        ZipEntry result = ziparchiveentry.setLastModifiedTime(fileTime);
        assertNotNull(result);}
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testsetLastModifiedTime_2() throws Exception {
        ziparchiveentry = new ZipArchiveEntry("testEntry");
        FileTime fileTime = FileTime.fromMillis(System.currentTimeMillis());
        ZipEntry result = ziparchiveentry.setLastModifiedTime(fileTime);
        assertEquals(ziparchiveentry, result);}
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
public void testGetTimeWithLastModifiedDateSet_BHDs0() throws ZipException {
    ZipArchiveEntry entry = new ZipArchiveEntry("test.txt");
    entry.lastModifiedDateSet = true; // Assuming this field is accessible for testing
    entry.setLastModifiedTime(Instant.ofEpochMilli(1620000000000L)); // Set a specific last modified time
    long expectedTime = 1620000000000L; // Expected time in milliseconds
    assertEquals(expectedTime, entry.getTime());
}
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
public void testGetTimeWithTimeSet_SLSk1() throws ZipException {
    ZipArchiveEntry entry = new ZipArchiveEntry("test.txt");
    entry.time = 1620000000000L; // Set a specific time
    long expectedTime = 1620000000000L; // Expected time in milliseconds
    assertEquals(expectedTime, entry.getTime());
}
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
public void testGetTimeWithDefaultSuperMethod_REOQ2() throws ZipException {
    ZipArchiveEntry entry = new ZipArchiveEntry("test.txt");
    entry.time = -1; // Ensure time is not set
    long expectedTime = super.getTime(); // Assuming super.getTime() returns a specific value
    assertEquals(expectedTime, entry.getTime());
}
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
public void testSetLastModifiedTime_JpEJ0_1() throws IOException {
    ZipArchiveEntry zipEntry = new ZipArchiveEntry(new File("test.txt"), "entryName");
    FileTime fileTime = FileTime.fromMillis(System.currentTimeMillis());
    ZipEntry result = zipEntry.setLastModifiedTime(fileTime);
    assertNotNull(result);}
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
public void testSetLastModifiedTime_JpEJ0_2() throws IOException {
    ZipArchiveEntry zipEntry = new ZipArchiveEntry(new File("test.txt"), "entryName");
    FileTime fileTime = FileTime.fromMillis(System.currentTimeMillis());
    ZipEntry result = zipEntry.setLastModifiedTime(fileTime);
    assertEquals(zipEntry, result);}
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testsetLastAccessTime_1() throws Exception {
        ziparchiveentry = new ZipArchiveEntry("testEntry");
        FileTime fileTime = FileTime.fromMillis(System.currentTimeMillis());
        ZipEntry result = ziparchiveentry.setLastAccessTime(fileTime);
        // Assuming there's a way to verify the last access time was set correctly
        // This would depend on the implementation of setLastAccessTime in the superclass
        // assertEquals(fileTime, ziparchiveentry.getLastAccessTime());
        assertNotNull(result);}
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testsetLastAccessTime_2() throws Exception {
        ziparchiveentry = new ZipArchiveEntry("testEntry");
        FileTime fileTime = FileTime.fromMillis(System.currentTimeMillis());
        ZipEntry result = ziparchiveentry.setLastAccessTime(fileTime);
        // Assuming there's a way to verify the last access time was set correctly
        // This would depend on the implementation of setLastAccessTime in the superclass
        // assertEquals(fileTime, ziparchiveentry.getLastAccessTime());
        assertEquals(ziparchiveentry, result);}
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
public void testSetLastAccessTime_qKuJ0_1() throws IOException {
    ZipArchiveEntry zipEntry = new ZipArchiveEntry("testEntry.zip");
    FileTime fileTime = FileTime.fromMillis(System.currentTimeMillis());
    ZipEntry result = zipEntry.setLastAccessTime(fileTime);
    assertNotNull(result);}
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
public void testSetLastAccessTime_qKuJ0_2() throws IOException {
    ZipArchiveEntry zipEntry = new ZipArchiveEntry("testEntry.zip");
    FileTime fileTime = FileTime.fromMillis(System.currentTimeMillis());
    ZipEntry result = zipEntry.setLastAccessTime(fileTime);
    assertEquals(fileTime, zipEntry.getLastAccessTime());}
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testgetVersionMadeBy() throws Exception {
        ziparchiveentry = Mockito.mock(ZipArchiveEntry.class);
        versionMadeBy = 20; // Example version
        Mockito.when(ziparchiveentry.getVersionMadeBy()).thenReturn(versionMadeBy);
        int result = ziparchiveentry.getVersionMadeBy();
        Assertions.assertEquals(versionMadeBy, result);
    }
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
public void testGetVersionMadeBy_UeSh0() throws ZipException {
    ZipArchiveEntry entry = new ZipArchiveEntry("testEntry.zip");
    int expectedVersion = 20; // Replace with the actual expected value
    assertEquals(expectedVersion, entry.getVersionMadeBy());
}
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testGetName_ReturnsCorrectName_WhenNameIsNotNull() throws Exception {
        ziparchiveentry = new ZipArchiveEntry("testEntryName");
        String expectedName = "testEntryName";
        String actualName = ziparchiveentry.getName();
        assertEquals(expectedName, actualName);
    }
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testGetName_ReturnsSuperName_WhenNameIsNull() throws Exception {
        ziparchiveentry = new ZipArchiveEntry("testEntryName");
        ziparchiveentry = new ZipArchiveEntry(); // Using the default constructor
        String actualName = ziparchiveentry.getName();
        assertNotNull(actualName); // Assuming super.getName() returns a non-null value
    }
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
public void testGetNameWithNullName_YUZQ0() throws ZipException {
    ZipArchiveEntry entry = new ZipArchiveEntry();
    assertEquals(super.getName(), entry.getName());
}
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
public void testGetNameWithNonNullName_SbMC1() throws ZipException {
    ZipArchiveEntry entry = new ZipArchiveEntry("testEntry");
    assertEquals("testEntry", entry.getName());
}
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testGetLocalFileDataExtra_ReturnsExtraData() throws Exception {
        ziparchiveentry = Mockito.mock(ZipArchiveEntry.class);
        byte[] expectedExtra = new byte[]{1, 2, 3, 4};
        Mockito.when(ziparchiveentry.getExtra()).thenReturn(expectedExtra);
        byte[] result = ziparchiveentry.getLocalFileDataExtra();
        Assertions.assertArrayEquals(expectedExtra, result);
    }
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testGetLocalFileDataExtra_ReturnsEmptyArrayWhenExtraIsNull() throws Exception {
        ziparchiveentry = Mockito.mock(ZipArchiveEntry.class);
        Mockito.when(ziparchiveentry.getExtra()).thenReturn(null);
        byte[] result = ziparchiveentry.getLocalFileDataExtra();
        Assertions.assertArrayEquals(ByteUtils.EMPTY_BYTE_ARRAY, result);
    }
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
public void testGetLocalFileDataExtraWithNullExtra_vxvM0() throws ZipException {
    ZipArchiveEntry entry = new ZipArchiveEntry("testEntry");
    byte[] result = entry.getLocalFileDataExtra();
    assertArrayEquals(ByteUtils.EMPTY_BYTE_ARRAY, result);
}
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
public void testGetLocalFileDataExtraWithNonNullExtra_aYDJ1() throws ZipException {
    ZipArchiveEntry entry = new ZipArchiveEntry("testEntry");
    byte[] expectedExtra = new byte[]{1, 2, 3, 4}; // Assuming this is the expected extra data
    entry.setExtra(expectedExtra); // Hypothetical method to set extra data for testing
    byte[] result = entry.getLocalFileDataExtra();
    assertArrayEquals(expectedExtra, result);
}
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testisDirectory_1() throws Exception {
        ziparchiveentry = new ZipArchiveEntry("testDirectory" + ZIP_DIR_SEP);
        ziparchiveentry = new ZipArchiveEntry("testFile.txt");
        assertTrue(ziparchiveentry.isDirectory());}
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testisDirectory_2() throws Exception {
        ziparchiveentry = new ZipArchiveEntry("testDirectory" + ZIP_DIR_SEP);
        ziparchiveentry = new ZipArchiveEntry("testFile.txt");
        assertFalse(ziparchiveentry.isDirectory());}
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
public void testIsDirectory_WhenEntryNameEndsWithZipDirSep_ShouldReturnTrue_vCMf0() throws ZipException {
    ZipArchiveEntry entry = new ZipArchiveEntry("example/directory/");
    assertTrue(entry.isDirectory());
}
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
public void testIsDirectory_WhenEntryNameDoesNotEndWithZipDirSep_ShouldReturnFalse_fcSb1() throws ZipException {
    ZipArchiveEntry entry = new ZipArchiveEntry("example/file.txt");
    assertFalse(entry.isDirectory());
}
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testSetTime() throws Exception {
        ziparchiveentry = new ZipArchiveEntry("testEntry");
        FileTime mockFileTime = Mockito.mock(FileTime.class);
        Mockito.when(mockFileTime.toMillis()).thenReturn(123456789L);
        ziparchiveentry.setTime(mockFileTime);
        // Assuming there's a way to verify the internal state or behavior after setTime is called.
        // Since the original class does not expose any state, we would typically need to check
        // if the method behaves correctly or interacts with other components as expected.
        // Here, we can only assert that the method was called correctly.
        Mockito.verify(mockFileTime).toMillis();
    }
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
public void testSetTime_GIIh0() throws IOException {
    ZipArchiveEntry entry = new ZipArchiveEntry(new File("test.txt"), "entryName");
    FileTime fileTime = FileTime.fromMillis(System.currentTimeMillis());
    entry.setTime(fileTime);
    assertEquals(fileTime.toMillis(), entry.getTime().toMillis());
}
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testsetRawFlag() throws Exception {
        ziparchiveentry = new ZipArchiveEntry();
        rawFlag = 5;
        ziparchiveentry.setRawFlag(rawFlag);
        Field field = ZipArchiveEntry.class.getDeclaredField("rawFlag");
        field.setAccessible(true);
        int actualRawFlag = (int) field.get(ziparchiveentry);
        assertEquals(rawFlag, actualRawFlag);
    }
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
public void testSetRawFlag_Jpty0() throws ZipException {
    ZipArchiveEntry entry = new ZipArchiveEntry("testEntry");
    entry.setRawFlag(1);
    assertEquals(1, entry.rawFlag);
}
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testgetDiskNumberStart() throws Exception {
        ziparchiveentry = new ZipArchiveEntry();
        // Directly setting the private field for testing purposes
        // This assumes you have access to modify the field for testing
        // If not, you may need to use reflection or modify the class design
        Field field = ZipArchiveEntry.class.getDeclaredField("diskNumberStart");
        field.setAccessible(true);
        field.set(ziparchiveentry, 5L); // Set a test value
        long result = ziparchiveentry.getDiskNumberStart();
        assertEquals(5L, result);
    }
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
public void testGetDiskNumberStart_QOEO0() throws ZipException {
    ZipArchiveEntry entry = new ZipArchiveEntry("testEntry.zip");
    long expectedDiskNumberStart = 0; // Set this to the expected value based on your logic
    assertEquals(expectedDiskNumberStart, entry.getDiskNumberStart());
}
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testGetUnixMode_WhenPlatformIsUnix() throws Exception {
        ziparchiveentry = Mockito.spy(new ZipArchiveEntry());
        Mockito.doReturn(EXTERNAL_ATTRIBUTES).when(ziparchiveentry).getExternalAttributes();
        ziparchiveentry = Mockito.spy(new ZipArchiveEntry());
        Mockito.doReturn(PLATFORM_UNIX).when(ziparchiveentry).getPlatform(); // Mocking platform to UNIX
        int mode = ziparchiveentry.getUnixMode();
        Assertions.assertEquals((EXTERNAL_ATTRIBUTES >> SHORT_SHIFT) & SHORT_MASK, mode);
    }
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testGetUnixMode_WhenPlatformIsNotUnix() throws Exception {
        ziparchiveentry = Mockito.spy(new ZipArchiveEntry());
        Mockito.doReturn(EXTERNAL_ATTRIBUTES).when(ziparchiveentry).getExternalAttributes();
        ziparchiveentry = Mockito.spy(new ZipArchiveEntry());
        Mockito.doReturn(PLATFORM_FAT).when(ziparchiveentry).getPlatform(); // Mocking platform to FAT
        int mode = ziparchiveentry.getUnixMode();
        Assertions.assertEquals(0, mode);
    }
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
public void testGetUnixModeWhenPlatformIsUnix_Yrla0() throws ZipException {
    ZipArchiveEntry entry = new ZipArchiveEntry("testEntry");
    entry.platform = ZipArchiveEntry.PLATFORM_UNIX; // Assuming platform is a field in the class
    entry.setExternalAttributes(0b00000000000000001111111111111111); // Set external attributes for testing
    assertEquals(0b000000000000000011111111, entry.getUnixMode());
}
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
public void testGetUnixModeWhenPlatformIsNotUnix_rubg1() throws ZipException {
    ZipArchiveEntry entry = new ZipArchiveEntry("testEntry");
    entry.platform = ZipArchiveEntry.PLATFORM_WINDOWS; // Assuming platform is a field in the class
    assertEquals(0, entry.getUnixMode());
}
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testGetExtraFields() throws Exception {
        parsingBehavior = Mockito.mock(ExtraFieldParsingBehavior.class);
        ziparchiveentry = new ZipArchiveEntry("test.zip");
        ZipExtraField[] expectedFields = new ZipExtraField[] { /* populate with expected fields */ };
        Mockito.when(parsingBehavior.getExtraFields(Mockito.any())).thenReturn(expectedFields);
        ZipExtraField[] actualFields = ziparchiveentry.getExtraFields(parsingBehavior);
        Assertions.assertArrayEquals(expectedFields, actualFields);
    }
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
public void testGetExtraFields_BestEffortParsing_qtdu0() throws ZipException {
    ZipArchiveEntry entry = new ZipArchiveEntry("test.zip");
    ExtraFieldParsingBehavior behavior = ExtraFieldParsingMode.BEST_EFFORT;
    ZipExtraField[] result = entry.getExtraFields(behavior);
    assertNotNull(result);
}
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
public void testGetExtraFields_OnlyParseableLenient_ZnRZ1() throws ZipException {
    ZipArchiveEntry entry = new ZipArchiveEntry("test.zip");
    ExtraFieldParsingBehavior behavior = ExtraFieldParsingMode.ONLY_PARSEABLE_LENIENT;
    ZipExtraField[] result = entry.getExtraFields(behavior);
    assertNotNull(result);
}
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
public void testGetExtraFields_WithUnparseableFields_wOuY2() throws ZipException {
    ZipArchiveEntry entry = new ZipArchiveEntry("test.zip");
    ExtraFieldParsingBehavior behavior = ExtraFieldParsingMode.BEST_EFFORT;
    ZipExtraField[] result = entry.getExtraFields(behavior);
    assertTrue(Arrays.stream(result).anyMatch(field -> field instanceof UnparseableExtraFieldData));
}
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
public void testGetExtraFields_MergesLocalAndCentralFields_Ybky3() throws ZipException {
    ZipArchiveEntry entry = new ZipArchiveEntry("test.zip");
    ExtraFieldParsingBehavior behavior = ExtraFieldParsingMode.BEST_EFFORT;
    ZipExtraField[] result = entry.getExtraFields(behavior);
    assertTrue(result.length > 0);
}
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
public void testGetExtraFields_EmptyLocalAndCentralFields_tsPv5() throws ZipException {
    ZipArchiveEntry entry = new ZipArchiveEntry("empty.zip");
    ExtraFieldParsingBehavior behavior = ExtraFieldParsingMode.BEST_EFFORT;
    ZipExtraField[] result = entry.getExtraFields(behavior);
    assertEquals(0, result.length);
}
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
public void testGetExtraFields_OnlyCentralFieldsParsed_rRsj6() throws ZipException {
    ZipArchiveEntry entry = new ZipArchiveEntry("test.zip");
    ExtraFieldParsingBehavior behavior = ExtraFieldParsingMode.ONLY_PARSEABLE_LENIENT;
    ZipExtraField[] result = entry.getExtraFields(behavior);
    assertTrue(Arrays.stream(result).allMatch(field -> field instanceof ParseableExtraFieldData));
}
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
public void testGetExtraFields_MultipleUnparseableFields_fcDD7() throws ZipException {
    ZipArchiveEntry entry = new ZipArchiveEntry("test.zip");
    ExtraFieldParsingBehavior behavior = ExtraFieldParsingMode.BEST_EFFORT;
    ZipExtraField[] result = entry.getExtraFields(behavior);
    assertTrue(Arrays.stream(result).filter(field -> field instanceof UnparseableExtraFieldData).count() > 1);
}
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testgetRawName_1() throws Exception {
        rawName = new byte[]{1, 2, 3, 4, 5};
        ziparchiveentry = new ZipArchiveEntry("testEntry");
        // Use reflection to set the private rawName field
        Field field = ZipArchiveEntry.class.getDeclaredField("rawName");
        field.setAccessible(true);
        field.set(ziparchiveentry, rawName);
        byte[] result = ziparchiveentry.getRawName();
        assertNotNull(result);}
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testgetRawName_2() throws Exception {
        rawName = new byte[]{1, 2, 3, 4, 5};
        ziparchiveentry = new ZipArchiveEntry("testEntry");
        // Use reflection to set the private rawName field
        Field field = ZipArchiveEntry.class.getDeclaredField("rawName");
        field.setAccessible(true);
        field.set(ziparchiveentry, rawName);
        byte[] result = ziparchiveentry.getRawName();
        assertArrayEquals(rawName, result);}
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testgetRawName_3() throws Exception {
        rawName = new byte[]{1, 2, 3, 4, 5};
        ziparchiveentry = new ZipArchiveEntry("testEntry");
        // Use reflection to set the private rawName field
        Field field = ZipArchiveEntry.class.getDeclaredField("rawName");
        field.setAccessible(true);
        field.set(ziparchiveentry, rawName);
        byte[] result = ziparchiveentry.getRawName();
        assertNotSame(rawName, result);}
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
public void testGetExtraFieldsWithBestEffortParsing_WFwq0_1() throws ZipException {
    ZipArchiveEntry entry = new ZipArchiveEntry("test.zip");
    ZipExtraField[] result = entry.getExtraFields(ExtraFieldParsingMode.BEST_EFFORT);
    assertNotNull(result);}
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
public void testGetExtraFieldsWithBestEffortParsing_WFwq0_2() throws ZipException {
    ZipArchiveEntry entry = new ZipArchiveEntry("test.zip");
    ZipExtraField[] result = entry.getExtraFields(ExtraFieldParsingMode.BEST_EFFORT);
    assertTrue(result.length > 0);}
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
public void testGetExtraFieldsWithOnlyParseableLenient_OuXD1_1() throws ZipException {
    ZipArchiveEntry entry = new ZipArchiveEntry("test.zip");
    ZipExtraField[] result = entry.getExtraFields(ExtraFieldParsingMode.ONLY_PARSEABLE_LENIENT);
    assertNotNull(result);}
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
public void testGetExtraFieldsWithOnlyParseableLenient_OuXD1_2() throws ZipException {
    ZipArchiveEntry entry = new ZipArchiveEntry("test.zip");
    ZipExtraField[] result = entry.getExtraFields(ExtraFieldParsingMode.ONLY_PARSEABLE_LENIENT);
    assertTrue(result.length > 0);}
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
public void testGetExtraFieldsWithValidLocalAndCentralFields_ujDk2_1() throws ZipException {
    ZipArchiveEntry entry = new ZipArchiveEntry("test.zip");
    ZipExtraField[] result = entry.getExtraFields(ExtraFieldParsingMode.DEFAULT);
    assertNotNull(result);}
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
public void testGetExtraFieldsWithValidLocalAndCentralFields_ujDk2_2() throws ZipException {
    ZipArchiveEntry entry = new ZipArchiveEntry("test.zip");
    ZipExtraField[] result = entry.getExtraFields(ExtraFieldParsingMode.DEFAULT);
    assertEquals(expectedCount, result.length); // Replace expectedCount with the expected number of fields}
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
public void testGetExtraFieldsWithUnparseableFields_FcdI3_1() throws ZipException {
    ZipArchiveEntry entry = new ZipArchiveEntry("test.zip");
    ZipExtraField[] result = entry.getExtraFields(ExtraFieldParsingMode.DEFAULT);
    assertNotNull(result);}
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
public void testGetExtraFieldsWithUnparseableFields_FcdI3_2() throws ZipException {
    ZipArchiveEntry entry = new ZipArchiveEntry("test.zip");
    ZipExtraField[] result = entry.getExtraFields(ExtraFieldParsingMode.DEFAULT);
    assertTrue(Arrays.stream(result).anyMatch(field -> field instanceof UnparseableExtraFieldData));}
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
public void testGetExtraFieldsWithNoCentralDirectoryData_VpDD4_1() throws ZipException {
    ZipArchiveEntry entry = new ZipArchiveEntry("test.zip");
    ZipExtraField[] result = entry.getExtraFields(ExtraFieldParsingMode.DEFAULT);
    assertNotNull(result);}
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
public void testGetExtraFieldsWithNoCentralDirectoryData_VpDD4_2() throws ZipException {
    ZipArchiveEntry entry = new ZipArchiveEntry("test.zip");
    ZipExtraField[] result = entry.getExtraFields(ExtraFieldParsingMode.DEFAULT);
    assertFalse(Arrays.stream(result).anyMatch(field -> field.getCentralDirectoryData() != null));}
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
public void testGetExtraFieldsWithMatchingHeaderId_GRLc5_1() throws ZipException {
    ZipArchiveEntry entry = new ZipArchiveEntry("test.zip");
    ZipExtraField[] result = entry.getExtraFields(ExtraFieldParsingMode.DEFAULT);
    assertNotNull(result);}
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
public void testGetExtraFieldsWithMatchingHeaderId_GRLc5_2() throws ZipException {
    ZipArchiveEntry entry = new ZipArchiveEntry("test.zip");
    ZipExtraField[] result = entry.getExtraFields(ExtraFieldParsingMode.DEFAULT);
    assertTrue(Arrays.stream(result).anyMatch(field -> field.getHeaderId().equals(expectedHeaderId))); // Replace expectedHeaderId with the expected header ID}
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
public void testGetExtraFieldsWithEmptyLocalFields_GLvN6_1() throws ZipException {
    ZipArchiveEntry entry = new ZipArchiveEntry("empty.zip");
    ZipExtraField[] result = entry.getExtraFields(ExtraFieldParsingMode.DEFAULT);
    assertNotNull(result);}
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
public void testGetExtraFieldsWithEmptyLocalFields_GLvN6_2() throws ZipException {
    ZipArchiveEntry entry = new ZipArchiveEntry("empty.zip");
    ZipExtraField[] result = entry.getExtraFields(ExtraFieldParsingMode.DEFAULT);
    assertEquals(0, result.length);}
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
public void testGetExtraFieldsWithOnlyCentralFields_lCQa7_1() throws ZipException {
    ZipArchiveEntry entry = new ZipArchiveEntry("onlyCentral.zip");
    ZipExtraField[] result = entry.getExtraFields(ExtraFieldParsingMode.DEFAULT);
    assertNotNull(result);}
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
public void testGetExtraFieldsWithOnlyCentralFields_lCQa7_2() throws ZipException {
    ZipArchiveEntry entry = new ZipArchiveEntry("onlyCentral.zip");
    ZipExtraField[] result = entry.getExtraFields(ExtraFieldParsingMode.DEFAULT);
    assertTrue(result.length > 0); // Assuming there are central fields}
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
public void testGetRawNameWithNonNullRawName_YGSy0() throws ZipException {
    byte[] expectedRawName = new byte[]{1, 2, 3}; // Example byte array
    ZipArchiveEntry entry = new ZipArchiveEntry("example.txt");
    entry.rawName = expectedRawName; // Hypothetical setter for rawName
    byte[] actualRawName = entry.getRawName();
    assertArrayEquals(expectedRawName, actualRawName);
}
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
public void testGetRawNameWithNullRawName_fTdN1() {
    ZipArchiveEntry entry = new ZipArchiveEntry("example.txt");
    byte[] actualRawName = entry.getRawName();
    assertNull(actualRawName);
}
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testClone_1() throws Exception {
        ziparchiveentry = new ZipArchiveEntry("testEntry");
        ZipArchiveEntry clonedEntry = (ZipArchiveEntry) ziparchiveentry.clone();
        assertNotNull(clonedEntry);}
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testClone_2() throws Exception {
        ziparchiveentry = new ZipArchiveEntry("testEntry");
        ZipArchiveEntry clonedEntry = (ZipArchiveEntry) ziparchiveentry.clone();
        assertNotSame(ziparchiveentry, clonedEntry);}
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testClone_3() throws Exception {
        ziparchiveentry = new ZipArchiveEntry("testEntry");
        ZipArchiveEntry clonedEntry = (ZipArchiveEntry) ziparchiveentry.clone();
        assertEquals(ziparchiveentry.getInternalAttributes(), clonedEntry.getInternalAttributes());}
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testClone_4() throws Exception {
        ziparchiveentry = new ZipArchiveEntry("testEntry");
        ZipArchiveEntry clonedEntry = (ZipArchiveEntry) ziparchiveentry.clone();
        assertEquals(ziparchiveentry.getExternalAttributes(), clonedEntry.getExternalAttributes());}
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testClone_5() throws Exception {
        ziparchiveentry = new ZipArchiveEntry("testEntry");
        ZipArchiveEntry clonedEntry = (ZipArchiveEntry) ziparchiveentry.clone();
        assertArrayEquals(ziparchiveentry.getAllExtraFieldsNoCopy(), clonedEntry.getAllExtraFieldsNoCopy());}
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testgetCentralDirectoryExtra() throws Exception {
        ziparchiveentry = Mockito.mock(ZipArchiveEntry.class);
        Mockito.when(ziparchiveentry.getAllExtraFieldsNoCopy()).thenReturn(new byte[]{1, 2, 3});
        Mockito.when(ExtraFieldUtils.mergeCentralDirectoryData(Mockito.any())).thenReturn(new byte[]{4, 5, 6});
        byte[] result = ziparchiveentry.getCentralDirectoryExtra();
        assertArrayEquals(new byte[]{4, 5, 6}, result);
    }
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
public void testClone_FOnE0_1() throws ZipException {
    ZipArchiveEntry originalEntry = new ZipArchiveEntry("originalEntry");
    originalEntry.setInternalAttributes(123);
    originalEntry.setExternalAttributes(456);
    originalEntry.setExtraFields(new byte[]{1, 2, 3});
    ZipArchiveEntry clonedEntry = (ZipArchiveEntry) originalEntry.clone();
    assertNotSame(originalEntry, clonedEntry);}
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
public void testClone_FOnE0_2() throws ZipException {
    ZipArchiveEntry originalEntry = new ZipArchiveEntry("originalEntry");
    originalEntry.setInternalAttributes(123);
    originalEntry.setExternalAttributes(456);
    originalEntry.setExtraFields(new byte[]{1, 2, 3});
    ZipArchiveEntry clonedEntry = (ZipArchiveEntry) originalEntry.clone();
    assertEquals(originalEntry.getInternalAttributes(), clonedEntry.getInternalAttributes());}
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
public void testClone_FOnE0_3() throws ZipException {
    ZipArchiveEntry originalEntry = new ZipArchiveEntry("originalEntry");
    originalEntry.setInternalAttributes(123);
    originalEntry.setExternalAttributes(456);
    originalEntry.setExtraFields(new byte[]{1, 2, 3});
    ZipArchiveEntry clonedEntry = (ZipArchiveEntry) originalEntry.clone();
    assertEquals(originalEntry.getExternalAttributes(), clonedEntry.getExternalAttributes());}
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
public void testClone_FOnE0_4() throws ZipException {
    ZipArchiveEntry originalEntry = new ZipArchiveEntry("originalEntry");
    originalEntry.setInternalAttributes(123);
    originalEntry.setExternalAttributes(456);
    originalEntry.setExtraFields(new byte[]{1, 2, 3});
    ZipArchiveEntry clonedEntry = (ZipArchiveEntry) originalEntry.clone();
    assertArrayEquals(originalEntry.getAllExtraFieldsNoCopy(), clonedEntry.getAllExtraFieldsNoCopy());}
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
public void testGetCentralDirectoryExtra_KLPS0_1() throws ZipException {
    ZipArchiveEntry entry = new ZipArchiveEntry("testEntry");
    byte[] result = entry.getCentralDirectoryExtra();
    assertNotNull(result);}
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
public void testGetCentralDirectoryExtra_KLPS0_2() throws ZipException {
    ZipArchiveEntry entry = new ZipArchiveEntry("testEntry");
    byte[] result = entry.getCentralDirectoryExtra();
    assertEquals(0, result.length); // Assuming no extra fields are set initially}
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testRemoveExtraField() throws Exception {
        ziparchiveentry = new ZipArchiveEntry("testEntry");
        ZipShort type = new ZipShort(new byte[]{0x01});
        // Mocking the behavior of getExtraField to return a non-null value
        ziparchiveentry.setExtraField(type, new byte[]{0x02}); // Assume this method exists for setup
        // Call the method under test
        ziparchiveentry.removeExtraField(type);
        // Verify that the extra field has been removed
        assertThrows(NoSuchElementException.class, () -> {
            ziparchiveentry.removeExtraField(type);
        });
    }
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
public void testRemoveExtraFieldSuccessfully_zbVX0() throws ZipException {
    ZipArchiveEntry entry = new ZipArchiveEntry("testEntry");
    ZipShort type = new ZipShort(1);
    entry.setExtraField(type, new byte[]{0x01}); // Assuming a method to set extra field exists
    entry.removeExtraField(type);
    assertNull(entry.getExtraField(type));
}
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testIsUnixSymlink_WhenIsSymlink_ReturnsTrue() throws Exception {
        ziparchiveentry = Mockito.spy(new ZipArchiveEntry());
        Mockito.when(ziparchiveentry.getUnixMode()).thenReturn(UnixStat.LINK_FLAG);
        assertTrue(ziparchiveentry.isUnixSymlink());
    }
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testIsUnixSymlink_WhenIsNotSymlink_ReturnsFalse() throws Exception {
        ziparchiveentry = Mockito.spy(new ZipArchiveEntry());
        Mockito.when(ziparchiveentry.getUnixMode()).thenReturn(UnixStat.FILE_TYPE_FLAG);
        assertFalse(ziparchiveentry.isUnixSymlink());
    }
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testIsUnixSymlink_WhenModeIsZero_ReturnsFalse() throws Exception {
        ziparchiveentry = Mockito.spy(new ZipArchiveEntry());
        Mockito.when(ziparchiveentry.getUnixMode()).thenReturn(0);
        assertFalse(ziparchiveentry.isUnixSymlink());
    }
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
public void testIsUnixSymlink_WhenEntryIsSymlink_ShouldReturnTrue_tJrj0() throws ZipException {
    ZipArchiveEntry entry = new ZipArchiveEntry("symlinkEntry");
    entry.setUnixMode(UnixStat.LINK_FLAG); // Assuming there's a method to set the Unix mode
    assertTrue(entry.isUnixSymlink());
}
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
public void testIsUnixSymlink_WhenEntryIsNotSymlink_ShouldReturnFalse_LWVd1() throws ZipException {
    ZipArchiveEntry entry = new ZipArchiveEntry("regularFile");
    entry.setUnixMode(UnixStat.FILE_TYPE_FLAG); // Assuming there's a method to set the Unix mode
    assertFalse(entry.isUnixSymlink());
}
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testsetVersionRequired() throws Exception {
        ziparchiveentry = new ZipArchiveEntry();
        versionRequired = 10;
        ziparchiveentry.setVersionRequired(versionRequired);
        Field field = ZipArchiveEntry.class.getDeclaredField("versionRequired");
        field.setAccessible(true);
        int actualVersionRequired = (int) field.get(ziparchiveentry);
        assertEquals(versionRequired, actualVersionRequired);
    }
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
public void testSetVersionRequired_tiiB0() throws ZipException {
    ZipArchiveEntry entry = new ZipArchiveEntry("testEntry.zip");
    entry.setVersionRequired(10);
    assertEquals(10, entry.versionRequired);
}
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testSetAlignment_ValidPowerOfTwo() {
        ziparchiveentry = new ZipArchiveEntry("testEntry");
        alignment = 16; // Valid power of two
        ziparchiveentry.setAlignment(alignment);
        assertEquals(alignment, ziparchiveentry.getAlignment());
    }
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testSetAlignment_InvalidPowerOfTwo_1() {
        ziparchiveentry = new ZipArchiveEntry("testEntry");
        alignment = 10; // Not a power of two
        IllegalArgumentException thrown = assertThrows(IllegalArgumentException.class, () -> {
            ziparchiveentry.setAlignment(alignment);
        });}
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testSetAlignment_InvalidPowerOfTwo_2() {
        ziparchiveentry = new ZipArchiveEntry("testEntry");
        alignment = 10; // Not a power of two
        assertEquals("Invalid value for alignment, must be power of two and no bigger than 65535 but is 10", thrown.getMessage());}
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testSetAlignment_ExceedsMaxValue_1() {
        ziparchiveentry = new ZipArchiveEntry("testEntry");
        alignment = 65536; // Exceeds maximum value
        IllegalArgumentException thrown = assertThrows(IllegalArgumentException.class, () -> {
            ziparchiveentry.setAlignment(alignment);
        });}
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testSetAlignment_ExceedsMaxValue_2() {
        ziparchiveentry = new ZipArchiveEntry("testEntry");
        alignment = 65536; // Exceeds maximum value
        assertEquals("Invalid value for alignment, must be power of two and no bigger than 65535 but is 65536", thrown.getMessage());}
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
public void testSetAlignment_ValidPowerOfTwo_VcsS0() {
    ZipArchiveEntry entry = new ZipArchiveEntry("testEntry");
    entry.setAlignment(16);
    assertEquals(16, entry.alignment);
}
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testSetTime_WithDosTime_1() throws Exception {
        ziparchiveentry = new ZipArchiveEntry("testEntry");
        long timeEpochMillis = 1234567890L;
        // Mocking the static method ZipUtil.isDosTime
        try (MockedStatic<ZipUtil> mockedZipUtil = Mockito.mockStatic(ZipUtil.class)) {
            mockedZipUtil.when(() -> ZipUtil.isDosTime(timeEpochMillis)).thenReturn(true);
            ziparchiveentry.setTime(timeEpochMillis);
            // Assertions
        }
            assertEquals(timeEpochMillis, ziparchiveentry.getTime());}
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testSetTime_WithDosTime_2() throws Exception {
        ziparchiveentry = new ZipArchiveEntry("testEntry");
        long timeEpochMillis = 1234567890L;
        // Mocking the static method ZipUtil.isDosTime
        try (MockedStatic<ZipUtil> mockedZipUtil = Mockito.mockStatic(ZipUtil.class)) {
            mockedZipUtil.when(() -> ZipUtil.isDosTime(timeEpochMillis)).thenReturn(true);
            ziparchiveentry.setTime(timeEpochMillis);
            // Assertions
        }
            assertFalse(ziparchiveentry.isLastModifiedDateSet());}
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testSetTime_WithNonDosTime() throws Exception {
        ziparchiveentry = new ZipArchiveEntry("testEntry");
        long timeEpochMillis = 9876543210L;
        // Mocking the static method ZipUtil.isDosTime
        try (MockedStatic<ZipUtil> mockedZipUtil = Mockito.mockStatic(ZipUtil.class)) {
            mockedZipUtil.when(() -> ZipUtil.isDosTime(timeEpochMillis)).thenReturn(false);
            ziparchiveentry.setTime(timeEpochMillis);
            // Assertions
            assertEquals(timeEpochMillis, ziparchiveentry.getLastModifiedTime().toMillis());
        }
    }
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testAddExtraField() throws Exception {
        ziparchiveentry = new ZipArchiveEntry("testEntry");
        ZipExtraField mockExtraField = Mockito.mock(ZipExtraField.class);
        ziparchiveentry.addExtraField(mockExtraField);
        // Assuming internalAddExtraField and setExtra are private methods,
        // we can verify the behavior indirectly by checking the state or behavior
        // of the ZipArchiveEntry if it had any observable effects.
        // Since we cannot directly verify private method calls, we can check if
        // the state of the ziparchiveentry is as expected after adding the extra field.
        // Here we would need to have a way to check if the extra field was added.
        // For demonstration, let's assume we have a method getExtraFields() that returns a list of extra fields.
        // List<ZipExtraField> extraFields = ziparchiveentry.getExtraFields();
        // assertTrue(extraFields.contains(mockExtraField));
        // Since we don't have such a method in the provided code, we can only assert that the method executes without exceptions.
        assertDoesNotThrow(() -> ziparchiveentry.addExtraField(mockExtraField));
    }
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
public void testSetTimeWithDosTime_aGmB0_1() throws ZipException {
    ZipArchiveEntry entry = new ZipArchiveEntry("testEntry.zip");
    long dosTime = 0x00000000; // Example DOS time
    entry.setTime(dosTime);
    assertEquals(dosTime, entry.getTime()); // Assuming getTime() returns the time set}
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
public void testSetTimeWithDosTime_aGmB0_2() throws ZipException {
    ZipArchiveEntry entry = new ZipArchiveEntry("testEntry.zip");
    long dosTime = 0x00000000; // Example DOS time
    entry.setTime(dosTime);
    assertFalse(entry.isLastModifiedDateSet()); // Assuming isLastModifiedDateSet() checks the flag}
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
public void testSetTimeWithNonDosTime_jaLG1() throws ZipException {
    ZipArchiveEntry entry = new ZipArchiveEntry("testEntry.zip");
    long nonDosTime = System.currentTimeMillis(); // Current time
    entry.setTime(nonDosTime);
    assertEquals(FileTime.fromMillis(nonDosTime), entry.getLastModifiedTime()); // Assuming getLastModifiedTime() returns FileTime
}
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
public void testAddExtraField_puMB0_1() throws ZipException {
    ZipArchiveEntry entry = new ZipArchiveEntry("testEntry.zip");
    ZipExtraField extraField = new ZipExtraField();
    entry.addExtraField(extraField);
    assertNotNull(entry.getExtraFields()); // Assuming getExtraFields() returns the list of extra fields}
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
public void testAddExtraField_puMB0_2() throws ZipException {
    ZipArchiveEntry entry = new ZipArchiveEntry("testEntry.zip");
    ZipExtraField extraField = new ZipExtraField();
    entry.addExtraField(extraField);
    assertTrue(entry.getExtraFields().contains(extraField)); // Check if the extra field is present}
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testSetMethod_ValidMethod() {
        ziparchiveentry = new ZipArchiveEntry("testEntry");
        int validMethod = 1; // Example of a valid method
        ziparchiveentry.setMethod(validMethod);
        assertEquals(method);
    }
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testSetMethod_NegativeMethod_1() {
        ziparchiveentry = new ZipArchiveEntry("testEntry");
        int negativeMethod = -1;
        IllegalArgumentException exception = assertThrows(IllegalArgumentException.class, () -> {
            ziparchiveentry.setMethod(negativeMethod);
        });}
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testSetMethod_NegativeMethod_2() {
        ziparchiveentry = new ZipArchiveEntry("testEntry");
        int negativeMethod = -1;
        assertEquals("ZIP compression method can not be negative: " + negativeMethod, exception.getMessage());}
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
public void testSetMethodValid_SDCj0() {
    ZipArchiveEntry entry = new ZipArchiveEntry("testEntry.zip");
    entry.setMethod(8);
    assertEquals(8, entry.method);
}
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testAddAsFirstExtraField_1() throws Exception {
        ziparchiveentry = new ZipArchiveEntry("testEntry");
        extraFields = new ZipExtraField[0];
        ReflectionTestUtils.setField(ziparchiveentry, "extraFields", extraFields);
        ZipExtraField mockExtraField = Mockito.mock(ZipExtraField.class);
        Mockito.when(mockExtraField.getHeaderId()).thenReturn("mockHeaderId");
        ziparchiveentry.addAsFirstExtraField(mockExtraField);
        assertEquals(1, ReflectionTestUtils.getField(ziparchiveentry, "extraFields").length);}
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testAddAsFirstExtraField_2() throws Exception {
        ziparchiveentry = new ZipArchiveEntry("testEntry");
        extraFields = new ZipExtraField[0];
        ReflectionTestUtils.setField(ziparchiveentry, "extraFields", extraFields);
        ZipExtraField mockExtraField = Mockito.mock(ZipExtraField.class);
        Mockito.when(mockExtraField.getHeaderId()).thenReturn("mockHeaderId");
        ziparchiveentry.addAsFirstExtraField(mockExtraField);
        assertEquals(mockExtraField, ReflectionTestUtils.getField(ziparchiveentry, "extraFields")[0]);}
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testAddAsFirstExtraFieldWithExistingHeaderId_1() throws Exception {
        ziparchiveentry = new ZipArchiveEntry("testEntry");
        extraFields = new ZipExtraField[0];
        ReflectionTestUtils.setField(ziparchiveentry, "extraFields", extraFields);
        ZipExtraField existingField = Mockito.mock(ZipExtraField.class);
        Mockito.when(existingField.getHeaderId()).thenReturn("mockHeaderId");
        ziparchiveentry.addAsFirstExtraField(existingField);
        ZipExtraField newField = Mockito.mock(ZipExtraField.class);
        Mockito.when(newField.getHeaderId()).thenReturn("mockHeaderId");
        ziparchiveentry.addAsFirstExtraField(newField);
        assertEquals(1, ReflectionTestUtils.getField(ziparchiveentry, "extraFields").length);}
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testAddAsFirstExtraFieldWithExistingHeaderId_2() throws Exception {
        ziparchiveentry = new ZipArchiveEntry("testEntry");
        extraFields = new ZipExtraField[0];
        ReflectionTestUtils.setField(ziparchiveentry, "extraFields", extraFields);
        ZipExtraField existingField = Mockito.mock(ZipExtraField.class);
        Mockito.when(existingField.getHeaderId()).thenReturn("mockHeaderId");
        ziparchiveentry.addAsFirstExtraField(existingField);
        ZipExtraField newField = Mockito.mock(ZipExtraField.class);
        Mockito.when(newField.getHeaderId()).thenReturn("mockHeaderId");
        ziparchiveentry.addAsFirstExtraField(newField);
        assertEquals(newField, ReflectionTestUtils.getField(ziparchiveentry, "extraFields")[0]);}
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testAddAsFirstExtraFieldWithUnparseableExtraFieldData() throws Exception {
        ziparchiveentry = new ZipArchiveEntry("testEntry");
        extraFields = new ZipExtraField[0];
        ReflectionTestUtils.setField(ziparchiveentry, "extraFields", extraFields);
        UnparseableExtraFieldData unparseableField = Mockito.mock(UnparseableExtraFieldData.class);
        ziparchiveentry.addAsFirstExtraField(unparseableField);
        assertEquals(unparseableField, ReflectionTestUtils.getField(ziparchiveentry, "unparseableExtra"));
    }
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testgetExtraFields_1() throws Exception {
        ziparchiveentry = Mockito.mock(ZipArchiveEntry.class);
        ZipExtraField[] mockExtraFields = new ZipExtraField[] {
            Mockito.mock(ZipExtraField.class),
            Mockito.mock(ZipExtraField.class)
        };
        Mockito.when(ziparchiveentry.getExtraFields()).thenReturn(mockExtraFields);
        ZipExtraField[] extraFields = ziparchiveentry.getExtraFields();
        assertNotNull(extraFields);}
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testgetExtraFields_2() throws Exception {
        ziparchiveentry = Mockito.mock(ZipArchiveEntry.class);
        ZipExtraField[] mockExtraFields = new ZipExtraField[] {
            Mockito.mock(ZipExtraField.class),
            Mockito.mock(ZipExtraField.class)
        };
        Mockito.when(ziparchiveentry.getExtraFields()).thenReturn(mockExtraFields);
        ZipExtraField[] extraFields = ziparchiveentry.getExtraFields();
        assertEquals(2, extraFields.length);}
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
public void testAddAsFirstExtraField_WithUnparseableExtraFieldData_fmio0_1() throws ZipException {
    ZipArchiveEntry entry = new ZipArchiveEntry("testEntry");
    UnparseableExtraFieldData unparseableField = new UnparseableExtraFieldData();
    entry.addAsFirstExtraField(unparseableField);
    assertNotNull(entry.unparseableExtra);}
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
public void testAddAsFirstExtraField_WithUnparseableExtraFieldData_fmio0_2() throws ZipException {
    ZipArchiveEntry entry = new ZipArchiveEntry("testEntry");
    UnparseableExtraFieldData unparseableField = new UnparseableExtraFieldData();
    entry.addAsFirstExtraField(unparseableField);
    assertEquals(unparseableField, entry.unparseableExtra);}
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
public void testAddAsFirstExtraField_WithExistingExtraField_HbeE1_1() throws ZipException {
    ZipArchiveEntry entry = new ZipArchiveEntry("testEntry");
    ZipExtraField existingField = new ZipExtraField();
    entry.addAsFirstExtraField(existingField);
    ZipExtraField newField = new ZipExtraField();
    entry.addAsFirstExtraField(newField);
    assertArrayEquals(new ZipExtraField[]{existingField}, entry.extraFields);}
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
public void testAddAsFirstExtraField_WithExistingExtraField_HbeE1_2() throws ZipException {
    ZipArchiveEntry entry = new ZipArchiveEntry("testEntry");
    ZipExtraField existingField = new ZipExtraField();
    entry.addAsFirstExtraField(existingField);
    ZipExtraField newField = new ZipExtraField();
    entry.addAsFirstExtraField(newField);
    assertArrayEquals(new ZipExtraField[]{newField, existingField}, entry.extraFields);}
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
public void testAddAsFirstExtraField_WithNullExtraField_MfBc2() throws ZipException {
    ZipArchiveEntry entry = new ZipArchiveEntry("testEntry");
    entry.addAsFirstExtraField(null);
    assertNull(entry.extraFields);
}
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
public void testAddAsFirstExtraField_WithMultipleExtraFields_EYeU3() throws ZipException {
    ZipArchiveEntry entry = new ZipArchiveEntry("testEntry");
    ZipExtraField field1 = new ZipExtraField();
    ZipExtraField field2 = new ZipExtraField();
    entry.addAsFirstExtraField(field1);
    entry.addAsFirstExtraField(field2);
    assertArrayEquals(new ZipExtraField[]{field2, field1}, entry.extraFields);
}
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
public void testAddAsFirstExtraField_WithDifferentHeaderId_Xesr4() throws ZipException {
    ZipArchiveEntry entry = new ZipArchiveEntry("testEntry");
    ZipExtraField field1 = new ZipExtraField();
    field1.setHeaderId("header1");
    ZipExtraField field2 = new ZipExtraField();
    field2.setHeaderId("header2");
    entry.addAsFirstExtraField(field1);
    entry.addAsFirstExtraField(field2);
    assertArrayEquals(new ZipExtraField[]{field2, field1}, entry.extraFields);
}
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
public void testGetExtraFields_XZEh0_1() throws ZipException {
    ZipArchiveEntry entry = new ZipArchiveEntry("testEntry");
    ZipExtraField[] extraFields = entry.getExtraFields();
    assertNotNull(extraFields);}
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
public void testGetExtraFields_XZEh0_2() throws ZipException {
    ZipArchiveEntry entry = new ZipArchiveEntry("testEntry");
    ZipExtraField[] extraFields = entry.getExtraFields();
    assertEquals(0, extraFields.length); // Assuming no extra fields are set initially}
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testgetGeneralPurposeBit_1() throws Exception {
        ziparchiveentry = new ZipArchiveEntry();
        GeneralPurposeBit result = ziparchiveentry.getGeneralPurposeBit();
        assertNotNull(result);}
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testgetGeneralPurposeBit_2() throws Exception {
        ziparchiveentry = new ZipArchiveEntry();
        GeneralPurposeBit result = ziparchiveentry.getGeneralPurposeBit();
        assertEquals(generalPurposeBit.hashCode(), result.hashCode());}
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
public void testGetGeneralPurposeBit_hgnW0() throws IOException {
    ZipArchiveEntry entry = new ZipArchiveEntry(new File("test.zip"), "testEntry");
    GeneralPurposeBit generalPurposeBit = entry.getGeneralPurposeBit();
    assertNotNull(generalPurposeBit);
}
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testGetDataOffset() throws Exception {
        ziparchiveentry = new ZipArchiveEntry("testEntry");
        long offset = ziparchiveentry.getDataOffset();
        assertEquals(OFFSET_UNKNOWN, offset, "The data offset should be OFFSET_UNKNOWN by default.");
    }
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
public void testGetDataOffset_KWPT0() throws ZipException {
    ZipArchiveEntry entry = new ZipArchiveEntry("testEntry");
    long expectedOffset = 0; // Assuming default value for dataOffset is 0
    assertEquals(expectedOffset, entry.getDataOffset());
}
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testGetSize() throws Exception {
        ziparchiveentry = new ZipArchiveEntry("testEntry");
        long expectedSize = SIZE_UNKNOWN;
        long actualSize = ziparchiveentry.getSize();
        assertEquals(expectedSize, actualSize, "The size should be SIZE_UNKNOWN by default.");
    }
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testGetPlatform() throws Exception {
        ziparchiveentry = new ZipArchiveEntry();
        int result = ziparchiveentry.getPlatform();
        assertEquals(PLATFORM_FAT, result);
    }
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
public void testGetSize_lHOU0() throws ZipException {
    ZipArchiveEntry entry = new ZipArchiveEntry("test.txt");
    long expectedSize = 0; // Assuming the default size is 0 for a new entry
    assertEquals(expectedSize, entry.getSize());
}
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
public void testGetPlatform_RTrR0() throws ZipException {
    ZipArchiveEntry entry = new ZipArchiveEntry("testEntry.zip");
    int expectedPlatform = 0; // Replace with the actual expected value
    assertEquals(expectedPlatform, entry.getPlatform());
}
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testsetInternalAttributes() throws Exception {
        ziparchiveentry = new ZipArchiveEntry();
        internalAttributes = 12345;
        ziparchiveentry.setInternalAttributes(internalAttributes);
        Field field = ZipArchiveEntry.class.getDeclaredField("internalAttributes");
        field.setAccessible(true);
        int actualAttributes = (int) field.get(ziparchiveentry);
        assertEquals(internalAttributes, actualAttributes);
    }
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
public void testSetInternalAttributes_yZkt0() throws ZipException {
    ZipArchiveEntry entry = new ZipArchiveEntry("testEntry");
    entry.setInternalAttributes(5);
    assertEquals(5, entry.internalAttributes);
}
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testsetStreamContiguous_1() throws Exception {
        ziparchiveentry = new ZipArchiveEntry();
        ziparchiveentry.setStreamContiguous(true);
        ziparchiveentry.setStreamContiguous(false);
        assertTrue(isStreamContiguous);}
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testsetStreamContiguous_2() throws Exception {
        ziparchiveentry = new ZipArchiveEntry();
        ziparchiveentry.setStreamContiguous(true);
        ziparchiveentry.setStreamContiguous(false);
        assertFalse(isStreamContiguous);}
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
public void testSetStreamContiguousTrue_fdtN0() {
    ZipArchiveEntry entry = new ZipArchiveEntry("testEntry");
    entry.setStreamContiguous(true);
    assertTrue(entry.isStreamContiguous);
}
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
public void testSetStreamContiguousFalse_bDec1() {
    ZipArchiveEntry entry = new ZipArchiveEntry("testEntry");
    entry.setStreamContiguous(false);
    assertFalse(entry.isStreamContiguous);
}
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testSetNameSource_1() throws Exception {
        ziparchiveentry = new ZipArchiveEntry("testEntry");
        ziparchiveentry.setNameSource(NameSource.NAME_WITH_EFS_FLAG);
        ziparchiveentry.setNameSource(NameSource.UNICODE_EXTRA_FIELD);
        assertEquals(NameSource.NAME_WITH_EFS_FLAG, ziparchiveentry.getNameSource());}
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testSetNameSource_2() throws Exception {
        ziparchiveentry = new ZipArchiveEntry("testEntry");
        ziparchiveentry.setNameSource(NameSource.NAME_WITH_EFS_FLAG);
        ziparchiveentry.setNameSource(NameSource.UNICODE_EXTRA_FIELD);
        assertEquals(NameSource.UNICODE_EXTRA_FIELD, ziparchiveentry.getNameSource());}
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
public void testSetNameSourceWithName_iFkn0() {
    ZipArchiveEntry entry = new ZipArchiveEntry("testEntry");
    entry.setNameSource(NameSource.NAME);
    assertEquals(NameSource.NAME, entry.getNameSource());
}
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
public void testSetNameSourceWithNameWithEfsFlag_DyjV1() {
    ZipArchiveEntry entry = new ZipArchiveEntry("testEntry");
    entry.setNameSource(NameSource.NAME_WITH_EFS_FLAG);
    assertEquals(NameSource.NAME_WITH_EFS_FLAG, entry.getNameSource());
}
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
public void testSetNameSourceWithUnicodeExtraField_JwuJ2() {
    ZipArchiveEntry entry = new ZipArchiveEntry("testEntry");
    entry.setNameSource(NameSource.UNICODE_EXTRA_FIELD);
    assertEquals(NameSource.UNICODE_EXTRA_FIELD, entry.getNameSource());
}
}