/**
 * Generated by Aster
 */
package org.apache.commons.codec.digest;

import java.util.concurrent.TimeUnit;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.Timeout;
import org.junit.jupiter.api.Timeout.ThreadMode;

import static org.junit.jupiter.api.Timeout.ThreadMode.SEPARATE_THREAD;

public class Aster_XXHash32_Coverage_Test_Passing {
    private byte[] createByteArray(int size, byte pattern) {
        byte[] result = new byte[size];
        for (int i = 0; i < size; i++) {
            result[i] = pattern;
        }
        return result;
    }
    private static final int BUF_SIZE = 16; // Assuming buffer size is 16 for simplicity
    private static final int PRIME1 = 0x9E3779B1;
    private static final int PRIME2 = 0x85EBCA77;
    private static final int ROTATE_BITS = 13;

    private static int rotateLeft(int value, int bits) {
        return (value << bits) | (value >>> (32 - bits));
    }

    @Test
    @Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testUpdateWithZero_hFqL0() {
        XXHash32 hasher = new XXHash32();
        hasher.update(0);
    }

    @Test
    @Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testUpdateWithPositiveByteValue_BifK1() {
        XXHash32 hasher = new XXHash32();
        hasher.update(100); // 100 in decimal is within byte range and positive
    }

    @Test
    @Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testUpdateWithNegativeByteValue_unKt2() {
        XXHash32 hasher = new XXHash32();
        hasher.update(255); // 255 in decimal will be treated as -1 in a byte (two's complement)
    }

    @Test
    @Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testUpdate_ProcessEntireBuffer_hXqn0() {
        XXHash32 hasher = new XXHash32();
        byte[] data = createByteArray(64, (byte) 1); // Ensure the buffer is fully processed
        hasher.update(data, 0, data.length);
    }

    @Test
    @Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testUpdate_ProcessMultipleChunks_AyIM1() {
        XXHash32 hasher = new XXHash32();
        byte[] data = createByteArray(128, (byte) 1); // Two full chunks
        hasher.update(data, 0, data.length);
    }

    @Test
    @Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testUpdate_ProcessSingleChunkWithCarry_ypcf2() {
        XXHash32 hasher = new XXHash32();
        byte[] data = createByteArray(32, (byte) 1); // Less than one chunk
        hasher.update(data, 0, data.length); // First call, buffer not full
        hasher.update(data, 0, data.length); // Second call, buffer processed
    }

    @Test
    @Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testUpdate_ProcessEdgeOfBuffer_gzQZ3() {
        XXHash32 hasher = new XXHash32();
        byte[] data = createByteArray(48, (byte) 1); // 1.5 chunks
        hasher.update(data, 0, data.length);
    }

    @Test
    @Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testUpdate_ProcessWithOffset_lOzJ4() {
        XXHash32 hasher = new XXHash32();
        byte[] data = createByteArray(96, (byte) 1); // Two chunks plus extra
        hasher.update(data, 8, 80); // Offset by 8, process remaining including partial chunk
    }

    @Test
    @Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testUpdate_ProcessExactFullBuffer_yONH5() {
        XXHash32 hasher = new XXHash32();
        byte[] data = createByteArray(64, (byte) 1); // Exactly one full buffer
        hasher.update(data, 0, data.length);
    }

    @Test
    @Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testUpdate_ProcessNoData_ELyC6() {
        XXHash32 hasher = new XXHash32();
        byte[] data = new byte[0];
        hasher.update(data, 0, data.length);
    }

    @Test
    @Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testUpdate_ProcessSmallData_WgiL7() {
        XXHash32 hasher = new XXHash32();
        byte[] data = createByteArray(16, (byte) 1); // Smaller than one chunk
        hasher.update(data, 0, data.length);
    }

    @Test
    @Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testUpdate_ProcessLargeData_AXRK8() {
        XXHash32 hasher = new XXHash32();
        byte[] data = createByteArray(256, (byte) 1); // Multiple full buffers
        hasher.update(data, 0, data.length);
    }

    @Test
    @Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testUpdate_ProcessBufferBoundary_LAMt9() {
        XXHash32 hasher = new XXHash32();
        byte[] data = createByteArray(128, (byte) 1); // Exactly two full buffers
        hasher.update(data, 0, data.length);
    }

    @Test
    @Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testUpdate_ProcessBufferBoundaryWithOffset_MeML10() {
        XXHash32 hasher = new XXHash32();
        byte[] data = createByteArray(136, (byte) 1); // A little more than two full buffers
        hasher.update(data, 8, 128); // Offset to start after some initial bytes
    }

    @Test
    @Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testUpdate_ProcessBufferBoundaryWithSmallOffset_MFmO11() {
        XXHash32 hasher = new XXHash32();
        byte[] data = createByteArray(72, (byte) 1); // A little more than one full buffer
        hasher.update(data, 8, 64); // Offset to start after some initial bytes
    }

    @Test
    @Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testUpdate_ProcessBufferBoundaryWithLargeData_wjIl12() {
        XXHash32 hasher = new XXHash32();
        byte[] data = createByteArray(520, (byte) 1); // Several full buffers
        hasher.update(data, 0, data.length);
    }

    @Test
    @Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testUpdate_ProcessBufferBoundaryWithEndOffset_iEtJ13() {
        XXHash32 hasher = new XXHash32();
        byte[] data = createByteArray(200, (byte) 1); // More than three full buffers
        hasher.update(data, 10, 180); // Offset to start after some initial bytes and end before the actual end
    }

    @Test
    @Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testUpdate_ProcessFullBuffer_ZTOy0() {
        XXHash32 hasher = new XXHash32(0);
        byte[] data = new byte[BUF_SIZE];
        for (int i = 0; i < BUF_SIZE; i++) {
            data[i] = (byte) i;
        }
        hasher.update(data, 0, data.length);
    }

    @Test
    @Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testUpdate_ProcessMultipleFullBuffers_tJoz1() {
        XXHash32 hasher = new XXHash32(0);
        byte[] data = new byte[BUF_SIZE * 3];
        for (int i = 0; i < data.length; i++) {
            data[i] = (byte) i;
        }
        hasher.update(data, 0, data.length);
    }

    @Test
    @Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testUpdate_ProcessWithInitialPartialBuffer_XBCI2() {
        XXHash32 hasher = new XXHash32(0);
        byte[] data = new byte[BUF_SIZE / 2];
        for (int i = 0; i < data.length; i++) {
            data[i] = (byte) i;
        }
        hasher.update(data, 0, data.length);
        byte[] data2 = new byte[BUF_SIZE];
        for (int i = 0; i < data2.length; i++) {
            data2[i] = (byte) (i + data.length);
        }
        hasher.update(data2, 0, data2.length);
    }

    @Test
    @Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testUpdate_EmptyInput_lvid3() {
        XXHash32 hasher = new XXHash32(0);
        byte[] data = new byte[0];
        hasher.update(data, 0, data.length);
    }

    @Test
    @Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testUpdate_NegativeLength_jPhi4() {
        XXHash32 hasher = new XXHash32(0);
        byte[] data = new byte[10];
        hasher.update(data, 0, -1);
    }

    @Test
    @Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testUpdate_OffsetHandling_MRLx5() {
        XXHash32 hasher = new XXHash32(0);
        byte[] data = new byte[BUF_SIZE * 2];
        for (int i = 0; i < data.length; i++) {
            data[i] = (byte) i;
        }
        hasher.update(data, BUF_SIZE / 2, BUF_SIZE);
    }

    @Test
    @Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testUpdate_OffsetAndLengthHandling_RFGf6() {
        XXHash32 hasher = new XXHash32(0);
        byte[] data = new byte[BUF_SIZE * 2];
        for (int i = 0; i < data.length; i++) {
            data[i] = (byte) i;
        }
        hasher.update(data, BUF_SIZE / 4, BUF_SIZE);
    }

    @Test
    @Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testUpdate_FullCoverageSingleCall_xNQx7() {
        XXHash32 hasher = new XXHash32(0);
        byte[] data = new byte[BUF_SIZE + BUF_SIZE / 2];
        for (int i = 0; i < data.length; i++) {
            data[i] = (byte) i;
        }
        hasher.update(data, 0, data.length);
    }

    @Test
    @Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testUpdate_FullCoverageMultipleCalls_KfVH8() {
        XXHash32 hasher = new XXHash32(0);
        byte[] data = new byte[BUF_SIZE / 2];
        byte[] data2 = new byte[BUF_SIZE];
        byte[] data3 = new byte[BUF_SIZE / 4];
        for (int i = 0; i < data.length; i++) {
            data[i] = (byte) i;
        }
        for (int i = 0; i < data2.length; i++) {
            data2[i] = (byte) i;
        }
        for (int i = 0; i < data3.length; i++) {
            data3[i] = (byte) i;
        }
        hasher.update(data, 0, data.length);
        hasher.update(data2, 0, data2.length);
        hasher.update(data3, 0, data3.length);
    }

    @Test
    @Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testUpdate_SmallUpdates_ecDe9() {
        XXHash32 hasher = new XXHash32(0);
        byte[] data = new byte[1];
        for (int i = 0; i < 32; i++) {
            data[0] = (byte) i;
            hasher.update(data, 0, data.length);
        }
    }

    @Test
    @Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testUpdate_RandomLengths_pGJR10() {
        XXHash32 hasher = new XXHash32(0);
        byte[] data = new byte[100];
        for (int i = 0; i < data.length; i++) {
            data[i] = (byte) (Math.random() * 256);
        }
        hasher.update(data, 0, 34);
        hasher.update(data, 34, 66);
    }

    @Test
    @Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testUpdate_ExactBufferLength_AsJn11() {
        XXHash32 hasher = new XXHash32(0);
        byte[] data = new byte[BUF_SIZE];
        for (int i = 0; i < data.length; i++) {
            data[i] = (byte) i;
        }
        hasher.update(data, 0, data.length);
    }

    @Test
    @Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testUpdate_MultipleExactBufferLengths_NnQq12() {
        XXHash32 hasher = new XXHash32(0);
        byte[] data = new byte[BUF_SIZE * 2];
        for (int i = 0; i < data.length; i++) {
            data[i] = (byte) i;
        }
        hasher.update(data, 0, data.length);
    }
}