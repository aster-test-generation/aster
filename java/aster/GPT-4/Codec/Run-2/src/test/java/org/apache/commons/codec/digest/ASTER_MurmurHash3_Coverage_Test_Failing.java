/**
 * Generated by Aster
 */
package org.apache.commons.codec.digest;

import java.util.concurrent.TimeUnit;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.Timeout;
import org.junit.jupiter.api.Timeout.ThreadMode;

import static org.junit.jupiter.api.Assertions.assertArrayEquals;
import static org.junit.jupiter.api.Timeout.ThreadMode.SEPARATE_THREAD;

public class Aster_MurmurHash3_Coverage_Test_Failing {
    @Test
    @Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testHash128x64_case1_yyTE0() {
        byte[] data = new byte[9];
        data[8] = 1; // to trigger k2 ^= data[index + 8] & 0xff;
        long[] expected = { /* expected result based on the seed and data */ };
        assertArrayEquals(expected, MurmurHash3.hash128x64(data, 0, 9, 0));
    }

    @Test
    @Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testHash128x64_case2_DHKN1() {
        byte[] data = new byte[10];
        data[9] = 1; // to trigger k2 ^= ((long) data[index + 9] & 0xff) << 8;
        long[] expected = { /* expected result based on the seed and data */ };
        assertArrayEquals(expected, MurmurHash3.hash128x64(data, 0, 10, 0));
    }

    @Test
    @Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testHash128x64_case3_xfPp2() {
        byte[] data = new byte[11];
        data[10] = 1; // to trigger k2 ^= ((long) data[index + 10] & 0xff) << 16;
        long[] expected = { /* expected result based on the seed and data */ };
        assertArrayEquals(expected, MurmurHash3.hash128x64(data, 0, 11, 0));
    }

    @Test
    @Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testHash128x64_case4_vndf3() {
        byte[] data = new byte[12];
        data[11] = 1; // to trigger k2 ^= ((long) data[index + 11] & 0xff) << 24;
        long[] expected = { /* expected result based on the seed and data */ };
        assertArrayEquals(expected, MurmurHash3.hash128x64(data, 0, 12, 0));
    }

    @Test
    @Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testHash128x64_case5_gNlF4() {
        byte[] data = new byte[13];
        data[12] = 1; // to trigger k2 ^= ((long) data[index + 12] & 0xff) << 32;
        long[] expected = { /* expected result based on the seed and data */ };
        assertArrayEquals(expected, MurmurHash3.hash128x64(data, 0, 13, 0));
    }

    @Test
    @Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testHash128x64_case6_igMC5() {
        byte[] data = new byte[14];
        data[13] = 1; // to trigger k2 ^= ((long) data[index + 13] & 0xff) << 40;
        long[] expected = { /* expected result based on the seed and data */ };
        assertArrayEquals(expected, MurmurHash3.hash128x64(data, 0, 14, 0));
    }

    @Test
    @Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testHash128x64_case7_XJBL6() {
        byte[] data = new byte[15];
        data[14] = 1; // to trigger k2 ^= ((long) data[index + 14] & 0xff) << 48;
        long[] expected = { /* expected result based on the seed and data */ };
        assertArrayEquals(expected, MurmurHash3.hash128x64(data, 0, 15, 0));
    }

    @Test
    @Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testHash128x64_case8_OHar7() {
        byte[] data = new byte[16];
        data[15] = 1; // to trigger k2 *= C2; k2 = Long.rotateLeft(k2, R3); k2 *= C1; h2 ^= k2;
        long[] expected = { /* expected result based on the seed and data */ };
        assertArrayEquals(expected, MurmurHash3.hash128x64(data, 0, 16, 0));
    }

    @Test
    @Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testHash128x64_case9_ylEw8() {
        byte[] data = new byte[17];
        data[16] = 1; // to trigger k1 ^= data[index] & 0xff;
        long[] expected = { /* expected result based on the seed and data */ };
        assertArrayEquals(expected, MurmurHash3.hash128x64(data, 0, 17, 0));
    }

    @Test
    @Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testHash128x64_case10_remG9() {
        byte[] data = new byte[18];
        data[17] = 1; // to trigger k1 ^= ((long) data[index + 1] & 0xff) << 8;
        long[] expected = { /* expected result based on the seed and data */ };
        assertArrayEquals(expected, MurmurHash3.hash128x64(data, 0, 18, 0));
    }

    @Test
    @Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testHash128x64_case11_otWG10() {
        byte[] data = new byte[19];
        data[18] = 1; // to trigger k1 ^= ((long) data[index + 2] & 0xff) << 16;
        long[] expected = { /* expected result based on the seed and data */ };
        assertArrayEquals(expected, MurmurHash3.hash128x64(data, 0, 19, 0));
    }

    @Test
    @Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testHash128x64_case12_KjIM11() {
        byte[] data = new byte[20];
        data[19] = 1; // to trigger k1 ^= ((long) data[index + 3] & 0xff) << 24;
        long[] expected = { /* expected result based on the seed and data */ };
        assertArrayEquals(expected, MurmurHash3.hash128x64(data, 0, 20, 0));
    }

    @Test
    @Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testHash128x64_case13_vuyU12() {
        byte[] data = new byte[21];
        data[20] = 1; // to trigger k1 ^= ((long) data[index + 4] & 0xff) << 32;
        long[] expected = { /* expected result based on the seed and data */ };
        assertArrayEquals(expected, MurmurHash3.hash128x64(data, 0, 21, 0));
    }

    @Test
    @Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testHash128x64_case14_bdJR13() {
        byte[] data = new byte[22];
        data[21] = 1; // to trigger k1 ^= ((long) data[index + 5] & 0xff) << 40;
        long[] expected = { /* expected result based on the seed and data */ };
        assertArrayEquals(expected, MurmurHash3.hash128x64(data, 0, 22, 0));
    }

    @Test
    @Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testHash128x64_case15_YDDO14() {
        byte[] data = new byte[23];
        data[22] = 1; // to trigger k1 ^= ((long) data[index + 6] & 0xff) << 48;
        long[] expected = { /* expected result based on the seed and data */ };
        assertArrayEquals(expected, MurmurHash3.hash128x64(data, 0, 23, 0));
    }

    @Test
    @Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testHash128x64_case16_zMmG15() {
        byte[] data = new byte[24];
        data[23] = 1; // to trigger k1 ^= ((long) data[index + 7] & 0xff) << 56;
        long[] expected = { /* expected result based on the seed and data */ };
        assertArrayEquals(expected, MurmurHash3.hash128x64(data, 0, 24, 0));
    }

    @Test
    @Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testHash128x64_case17_sekU16() {
        byte[] data = new byte[25];
        data[24] = 1; // to trigger k1 *= C1; k1 = Long.rotateLeft(k1, R1); k1 *= C2; h1 ^= k1;
        long[] expected = { /* expected result based on the seed and data */ };
        assertArrayEquals(expected, MurmurHash3.hash128x64(data, 0, 25, 0));
    }

    @Test
    @Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testHash128x64_case1_QRwG0() {
        byte[] data = new byte[9];
        data[8] = 1; // covers k2 ^= data[index + 8] & 0xff;
        long[] expected = { /* expected result based on the seed and data */ };
        assertArrayEquals(expected, MurmurHash3.hash128x64(data, 0, 9, 123));
    }

    @Test
    @Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testHash128x64_case2_Xcxs1() {
        byte[] data = new byte[10];
        data[9] = 1; // covers k2 ^= ((long) data[index + 9] & 0xff) << 8;
        long[] expected = { /* expected result based on the seed and data */ };
        assertArrayEquals(expected, MurmurHash3.hash128x64(data, 0, 10, 123));
    }

    @Test
    @Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testHash128x64_case3_GqEP2() {
        byte[] data = new byte[11];
        data[10] = 1; // covers k2 ^= ((long) data[index + 10] & 0xff) << 16;
        long[] expected = { /* expected result based on the seed and data */ };
        assertArrayEquals(expected, MurmurHash3.hash128x64(data, 0, 11, 123));
    }

    @Test
    @Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testHash128x64_case4_WGrq3() {
        byte[] data = new byte[12];
        data[11] = 1; // covers k2 ^= ((long) data[index + 11] & 0xff) << 24;
        long[] expected = { /* expected result based on the seed and data */ };
        assertArrayEquals(expected, MurmurHash3.hash128x64(data, 0, 12, 123));
    }

    @Test
    @Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testHash128x64_case5_ASIX4() {
        byte[] data = new byte[13];
        data[12] = 1; // covers k2 ^= ((long) data[index + 12] & 0xff) << 32;
        long[] expected = { /* expected result based on the seed and data */ };
        assertArrayEquals(expected, MurmurHash3.hash128x64(data, 0, 13, 123));
    }

    @Test
    @Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testHash128x64_case6_lWry5() {
        byte[] data = new byte[14];
        data[13] = 1; // covers k2 ^= ((long) data[index + 13] & 0xff) << 40;
        long[] expected = { /* expected result based on the seed and data */ };
        assertArrayEquals(expected, MurmurHash3.hash128x64(data, 0, 14, 123));
    }

    @Test
    @Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testHash128x64_case7_sPMu6() {
        byte[] data = new byte[15];
        data[14] = 1; // covers k2 ^= ((long) data[index + 14] & 0xff) << 48;
        long[] expected = { /* expected result based on the seed and data */ };
        assertArrayEquals(expected, MurmurHash3.hash128x64(data, 0, 15, 123));
    }

    @Test
    @Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testHash128x64_case8_ewwb7() {
        byte[] data = new byte[16];
        data[15] = 1; // covers k2 *= C2; k2 = Long.rotateLeft(k2, R3); k2 *= C1; h2 ^= k2;
        long[] expected = { /* expected result based on the seed and data */ };
        assertArrayEquals(expected, MurmurHash3.hash128x64(data, 0, 16, 123));
    }

    @Test
    @Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testHash128x64_case9_VGMV8() {
        byte[] data = new byte[17];
        data[16] = 1; // covers k1 ^= data[index] & 0xff;
        long[] expected = { /* expected result based on the seed and data */ };
        assertArrayEquals(expected, MurmurHash3.hash128x64(data, 0, 17, 123));
    }

    @Test
    @Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testHash128x64_case10_Kzvd9() {
        byte[] data = new byte[18];
        data[17] = 1; // covers k1 ^= ((long) data[index + 1] & 0xff) << 8;
        long[] expected = { /* expected result based on the seed and data */ };
        assertArrayEquals(expected, MurmurHash3.hash128x64(data, 0, 18, 123));
    }

    @Test
    @Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testHash128x64_case11_SPZm10() {
        byte[] data = new byte[19];
        data[18] = 1; // covers k1 ^= ((long) data[index + 2] & 0xff) << 16;
        long[] expected = { /* expected result based on the seed and data */ };
        assertArrayEquals(expected, MurmurHash3.hash128x64(data, 0, 19, 123));
    }

    @Test
    @Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testHash128x64_case12_gDUf11() {
        byte[] data = new byte[20];
        data[19] = 1; // covers k1 ^= ((long) data[index + 3] & 0xff) << 24;
        long[] expected = { /* expected result based on the seed and data */ };
        assertArrayEquals(expected, MurmurHash3.hash128x64(data, 0, 20, 123));
    }

    @Test
    @Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testHash128x64_case13_nIIH12() {
        byte[] data = new byte[21];
        data[20] = 1; // covers k1 ^= ((long) data[index + 4] & 0xff) << 32;
        long[] expected = { /* expected result based on the seed and data */ };
        assertArrayEquals(expected, MurmurHash3.hash128x64(data, 0, 21, 123));
    }

    @Test
    @Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testHash128x64_case14_VVjh13() {
        byte[] data = new byte[22];
        data[21] = 1; // covers k1 ^= ((long) data[index + 5] & 0xff) << 40;
        long[] expected = { /* expected result based on the seed and data */ };
        assertArrayEquals(expected, MurmurHash3.hash128x64(data, 0, 22, 123));
    }

    @Test
    @Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testHash128x64_case15_ymDN14() {
        byte[] data = new byte[23];
        data[22] = 1; // covers k1 ^= ((long) data[index + 6] & 0xff) << 48;
        long[] expected = { /* expected result based on the seed and data */ };
        assertArrayEquals(expected, MurmurHash3.hash128x64(data, 0, 23, 123));
    }

    @Test
    @Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testHash128x64_case16_bTwn15() {
        byte[] data = new byte[24];
        data[23] = 1; // covers k1 ^= ((long) data[index + 7] & 0xff) << 56;
        long[] expected = { /* expected result based on the seed and data */ };
        assertArrayEquals(expected, MurmurHash3.hash128x64(data, 0, 24, 123));
    }

    @Test
    @Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testHash128x64_case17_Vfwg16() {
        byte[] data = new byte[25];
        data[24] = 1; // covers k1 *= C1; k1 = Long.rotateLeft(k1, R1); k1 *= C2; h1 ^= k1;
        long[] expected = { /* expected result based on the seed and data */ };
        assertArrayEquals(expected, MurmurHash3.hash128x64(data, 0, 25, 123));
    }
}