/**
 * Generated by Aster
 */
package org.apache.commons.codec.digest;

import java.util.concurrent.TimeUnit;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.Timeout;
import org.junit.jupiter.api.Timeout.ThreadMode;

import static org.junit.jupiter.api.Assertions.*;
import static org.junit.jupiter.api.Timeout.ThreadMode.SEPARATE_THREAD;

public class Aster_Sha2Crypt_Coverage_Test_Passing {
    @Test
    @Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testSha256CryptWithNullSalt_FRWv0() {
        byte[] keyBytes = "password".getBytes();
        assertDoesNotThrow(() -> Sha2Crypt.sha256Crypt(keyBytes, null));
    }

    @Test
    @Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testSha256CryptWithInvalidSaltNoDollarSign_twDf1() {
        byte[] keyBytes = "password".getBytes();
        String salt = "invalidsalt";
        Exception exception = assertThrows(IllegalArgumentException.class, () -> Sha2Crypt.sha256Crypt(keyBytes, salt));
        assertTrue(exception.getMessage().contains("Invalid salt value"));
    }

    @Test
    @Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testSha256CryptWithValidSaltNoRounds_boYu2() {
        byte[] keyBytes = "password".getBytes();
        String salt = "$5$saltstring";
        assertDoesNotThrow(() -> Sha2Crypt.sha256Crypt(keyBytes, salt));
    }

    @Test
    @Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testSha256CryptWithRoundsSpecified_qPOi3() {
        byte[] keyBytes = "password".getBytes();
        String salt = "$5$rounds=5000$saltstring";
        assertDoesNotThrow(() -> Sha2Crypt.sha256Crypt(keyBytes, salt));
    }

    @Test
    @Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testSha256CryptWithRoundsBelowMinimum_zdbc4() {
        byte[] keyBytes = "password".getBytes();
        String salt = "$5$rounds=1000$saltstring"; // Assuming ROUNDS_MIN is higher than 1000
        assertDoesNotThrow(() -> Sha2Crypt.sha256Crypt(keyBytes, salt));
    }

    @Test
    @Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testSha256CryptWithRoundsAboveMaximum_qeWV5() {
        byte[] keyBytes = "password".getBytes();
        String salt = "$5$rounds=999999$saltstring"; // Assuming ROUNDS_MAX is lower than 999999
        assertDoesNotThrow(() -> Sha2Crypt.sha256Crypt(keyBytes, salt));
    }

    @Test
    @Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testSha256CryptWithLongKey_DnsS6() {
        byte[] keyBytes = new byte[1024]; // Large array to ensure multiple blocks are processed
        for (int i = 0; i < keyBytes.length; i++) {
            keyBytes[i] = (byte) (i % 256);
        }
        String salt = "$5$rounds=5000$saltstring";
        assertDoesNotThrow(() -> Sha2Crypt.sha256Crypt(keyBytes, salt));
    }

    @Test
    @Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testSha256CryptWithCustomRoundsAppendedToResult_awii7() {
        byte[] keyBytes = "password".getBytes();
        String salt = "$5$rounds=5000$saltstring";
        String result = Sha2Crypt.sha256Crypt(keyBytes, salt);
        assertTrue(result.contains("rounds=5000$"));
    }

    @Test
    @Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testSha256CryptWithDefaultRoundsNotAppendedToResult_CrkQ8() {
        byte[] keyBytes = "password".getBytes();
        String salt = "$5$saltstring";
        String result = Sha2Crypt.sha256Crypt(keyBytes, salt);
        assertFalse(result.contains("rounds="));
    }

    @Test
    @Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testSha256CryptWithInvalidSaltNoDollarSign_twDf1_1() {
        byte[] keyBytes = "password".getBytes();
        String salt = "invalidsalt";
        Exception exception = assertThrows(IllegalArgumentException.class, () -> Sha2Crypt.sha256Crypt(keyBytes, salt));
    }

    @Test
    @Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testSha256CryptWithKeyLengthExactMultipleOfBlocksize_tGAe9_FRtI0() {
        int blockSize = 64;
        byte[] keyBytes = new byte[blockSize * 2];
        String salt = "$5$rounds=5000$saltstring";
        assertDoesNotThrow(() -> Sha2Crypt.sha256Crypt(keyBytes, salt));
    }

    @Test
    @Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testSha256CryptWithSaltLengthExactMultipleOfBlocksize_kmcz10_jeno0() {
        byte[] keyBytes = "password".getBytes();
        StringBuilder saltBuilder = new StringBuilder("$5$rounds=5000$");
        int sha256BlockSize = 64;
        while (saltBuilder.length() < sha256BlockSize * 2 - 6) {
            saltBuilder.append("a");
        }
        String salt = saltBuilder.toString();
        assertDoesNotThrow(() -> Sha2Crypt.sha256Crypt(keyBytes, salt));
    }
}