/**
 * Generated by Aster
 */
package org.apache.commons.codec.binary;

import java.util.concurrent.TimeUnit;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.Timeout;
import org.junit.jupiter.api.Timeout.ThreadMode;

import static org.junit.jupiter.api.Assertions.*;
import static org.junit.jupiter.api.Timeout.ThreadMode.SEPARATE_THREAD;

public class Aster_Base64_Coverage_Test_Passing {
    private static final byte[] CHUNK_SEPARATOR = {'\r', '\n'};

    @Test
    @Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testEncodeBase64_ExceedsMaxResultSize_ThrowsIllegalArgumentException_mrde0() {
        byte[] binaryData = new byte[100]; // Example large binary data
        boolean isChunked = false;
        boolean urlSafe = false;
        int maxResultSize = 10; // Intentionally small max size to trigger the exception
        try {
            Base64.encodeBase64(binaryData, isChunked, urlSafe, maxResultSize);
            fail("Expected an IllegalArgumentException to be thrown");
        } catch (IllegalArgumentException e) {
            String expectedMessage = "Input array too big, the output array would be bigger";
            assert e.getMessage().contains(expectedMessage);
        }
    }

    @Test
    @Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testEncodeWithModulusZeroAndLineLengthZero_FyWS1_SZFN0() {
        Base64 base64 = new Base64(0);
        Base64.Context context = new Base64.Context();
        context.modulus = 0;
    }

    @Test
    @Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testEncodeCurrentLinePosReset_ApjF10_sLze0() {
        Base64 base64 = new Base64(4, new byte[]{10}, false);
        Base64.Context context = new Base64.Context();
        context.currentLinePos = 4;
        base64.encode(new byte[]{0, 0, 0}, 0, 3, context);
        assertEquals(0, context.currentLinePos);
    }

    @Test
    @Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testIsInAlphabet_PLiK0_DDiq0() {
        Base64 base64 = new Base64();
        byte validOctet = 'A'; // Typically, 'A' is part of the Base64 alphabet.
        assertTrue(base64.isInAlphabet(validOctet), "Octet should be in the alphabet");
    }

    @Test
    @Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testIsBase64_rGzx0_qvBb0_1() {
        final byte PAD_DEFAULT = '=';
        byte[] DECODE_TABLE = new byte[256];
        for (int i = 0; i < DECODE_TABLE.length; i++) {
            DECODE_TABLE[i] = -1; // initialize all as invalid
        }
        for (byte i = 'A'; i <= 'Z'; i++) {
            DECODE_TABLE[i] = i;
        }
        for (byte i = 'a'; i <= 'z'; i++) {
            DECODE_TABLE[i] = i;
        }
        for (byte i = '0'; i <= '9'; i++) {
            DECODE_TABLE[i] = i;
        }
        DECODE_TABLE['+'] = '+';
        DECODE_TABLE['/'] = '/';
        assertTrue(Base64.isBase64((byte) 'A'), "Character 'A' should be valid base64");
    }

    @Test
    @Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testIsBase64_rGzx0_qvBb0_2() {
        final byte PAD_DEFAULT = '=';
        byte[] DECODE_TABLE = new byte[256];
        for (int i = 0; i < DECODE_TABLE.length; i++) {
            DECODE_TABLE[i] = -1; // initialize all as invalid
        }
        for (byte i = 'A'; i <= 'Z'; i++) {
            DECODE_TABLE[i] = i;
        }
        for (byte i = 'a'; i <= 'z'; i++) {
            DECODE_TABLE[i] = i;
        }
        for (byte i = '0'; i <= '9'; i++) {
            DECODE_TABLE[i] = i;
        }
        DECODE_TABLE['+'] = '+';
        DECODE_TABLE['/'] = '/';
        assertTrue(Base64.isBase64((byte) 'm'), "Character 'm' should be valid base64");
    }

    @Test
    @Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testIsBase64_rGzx0_qvBb0_3() {
        final byte PAD_DEFAULT = '=';
        byte[] DECODE_TABLE = new byte[256];
        for (int i = 0; i < DECODE_TABLE.length; i++) {
            DECODE_TABLE[i] = -1; // initialize all as invalid
        }
        for (byte i = 'A'; i <= 'Z'; i++) {
            DECODE_TABLE[i] = i;
        }
        for (byte i = 'a'; i <= 'z'; i++) {
            DECODE_TABLE[i] = i;
        }
        for (byte i = '0'; i <= '9'; i++) {
            DECODE_TABLE[i] = i;
        }
        DECODE_TABLE['+'] = '+';
        DECODE_TABLE['/'] = '/';
        assertTrue(Base64.isBase64((byte) '9'), "Character '9' should be valid base64");
    }

    @Test
    @Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testIsBase64_rGzx0_qvBb0_4() {
        final byte PAD_DEFAULT = '=';
        byte[] DECODE_TABLE = new byte[256];
        for (int i = 0; i < DECODE_TABLE.length; i++) {
            DECODE_TABLE[i] = -1; // initialize all as invalid
        }
        for (byte i = 'A'; i <= 'Z'; i++) {
            DECODE_TABLE[i] = i;
        }
        for (byte i = 'a'; i <= 'z'; i++) {
            DECODE_TABLE[i] = i;
        }
        for (byte i = '0'; i <= '9'; i++) {
            DECODE_TABLE[i] = i;
        }
        DECODE_TABLE['+'] = '+';
        DECODE_TABLE['/'] = '/';
        assertTrue(Base64.isBase64((byte) '+'), "Character '+' should be valid base64");
    }

    @Test
    @Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testIsBase64_rGzx0_qvBb0_5() {
        final byte PAD_DEFAULT = '=';
        byte[] DECODE_TABLE = new byte[256];
        for (int i = 0; i < DECODE_TABLE.length; i++) {
            DECODE_TABLE[i] = -1; // initialize all as invalid
        }
        for (byte i = 'A'; i <= 'Z'; i++) {
            DECODE_TABLE[i] = i;
        }
        for (byte i = 'a'; i <= 'z'; i++) {
            DECODE_TABLE[i] = i;
        }
        for (byte i = '0'; i <= '9'; i++) {
            DECODE_TABLE[i] = i;
        }
        DECODE_TABLE['+'] = '+';
        DECODE_TABLE['/'] = '/';
        assertTrue(Base64.isBase64((byte) '/'), "Character '/' should be valid base64");
    }

    @Test
    @Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testIsBase64_rGzx0_qvBb0_6() {
        final byte PAD_DEFAULT = '=';
        byte[] DECODE_TABLE = new byte[256];
        for (int i = 0; i < DECODE_TABLE.length; i++) {
            DECODE_TABLE[i] = -1; // initialize all as invalid
        }
        for (byte i = 'A'; i <= 'Z'; i++) {
            DECODE_TABLE[i] = i;
        }
        for (byte i = 'a'; i <= 'z'; i++) {
            DECODE_TABLE[i] = i;
        }
        for (byte i = '0'; i <= '9'; i++) {
            DECODE_TABLE[i] = i;
        }
        DECODE_TABLE['+'] = '+';
        DECODE_TABLE['/'] = '/';
        assertTrue(Base64.isBase64(PAD_DEFAULT), "PAD_DEFAULT should be valid base64");
    }

    @Test
    @Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testIsBase64_rGzx0_qvBb0_7() {
        final byte PAD_DEFAULT = '=';
        byte[] DECODE_TABLE = new byte[256];
        for (int i = 0; i < DECODE_TABLE.length; i++) {
            DECODE_TABLE[i] = -1; // initialize all as invalid
        }
        for (byte i = 'A'; i <= 'Z'; i++) {
            DECODE_TABLE[i] = i;
        }
        for (byte i = 'a'; i <= 'z'; i++) {
            DECODE_TABLE[i] = i;
        }
        for (byte i = '0'; i <= '9'; i++) {
            DECODE_TABLE[i] = i;
        }
        DECODE_TABLE['+'] = '+';
        DECODE_TABLE['/'] = '/';
        assertFalse(Base64.isBase64((byte) '*'), "Character '*' should not be valid base64");
    }
}