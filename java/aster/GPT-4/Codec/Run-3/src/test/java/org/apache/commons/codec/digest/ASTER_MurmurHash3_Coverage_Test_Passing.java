/**
 * Generated by Aster
 */
package org.apache.commons.codec.digest;

import java.util.concurrent.TimeUnit;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.Timeout;
import org.junit.jupiter.api.Timeout.ThreadMode;

import static org.junit.jupiter.api.Assertions.*;
import static org.junit.jupiter.api.Timeout.ThreadMode.SEPARATE_THREAD;

public class Aster_MurmurHash3_Coverage_Test_Passing {
    @Test
    @Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testHash64With1Byte_XrUC0() {
        byte[] data = {0x01};
        int offset = 0;
        int length = 1;
        int seed = 123;
        long result = MurmurHash3.hash64(data, offset, length, seed);
        assertNotNull(result);
    }

    @Test
    @Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testHash64With2Bytes_zrTk1() {
        byte[] data = {0x01, 0x02};
        int offset = 0;
        int length = 2;
        int seed = 123;
        long result = MurmurHash3.hash64(data, offset, length, seed);
        assertNotNull(result);
    }

    @Test
    @Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testHash64With3Bytes_TAwP2() {
        byte[] data = {0x01, 0x02, 0x03};
        int offset = 0;
        int length = 3;
        int seed = 123;
        long result = MurmurHash3.hash64(data, offset, length, seed);
        assertNotNull(result);
    }

    @Test
    @Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testHash64With4Bytes_fByK3() {
        byte[] data = {0x01, 0x02, 0x03, 0x04};
        int offset = 0;
        int length = 4;
        int seed = 123;
        long result = MurmurHash3.hash64(data, offset, length, seed);
        assertNotNull(result);
    }

    @Test
    @Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testHash64With5Bytes_wRxw4() {
        byte[] data = {0x01, 0x02, 0x03, 0x04, 0x05};
        int offset = 0;
        int length = 5;
        int seed = 123;
        long result = MurmurHash3.hash64(data, offset, length, seed);
        assertNotNull(result);
    }

    @Test
    @Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testHash64With6Bytes_tOTu5() {
        byte[] data = {0x01, 0x02, 0x03, 0x04, 0x05, 0x06};
        int offset = 0;
        int length = 6;
        int seed = 123;
        long result = MurmurHash3.hash64(data, offset, length, seed);
        assertNotNull(result);
    }

    @Test
    @Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testHash64With7Bytes_QEGE6() {
        byte[] data = {0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07};
        int offset = 0;
        int length = 7;
        int seed = 123;
        long result = MurmurHash3.hash64(data, offset, length, seed);
        assertNotNull(result);
    }

    @Test
    @Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testHash32x86_SingleBlock_EPlQ1() {
        byte[] data = {1, 2, 3, 4};
        int seed = 123;
        int result = MurmurHash3.hash32x86(data, 0, 4, seed);
        assertNotEquals(seed, result); // Expect change due to hashing
    }

    @Test
    @Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testHash32x86_MultipleBlocks_nGpV2() {
        byte[] data = new byte[12];
        for (int i = 0; i < 12; i++) {
            data[i] = (byte) i;
        }
        int seed = 123;
        int result = MurmurHash3.hash32x86(data, 0, 12, seed);
        assertNotEquals(seed, result); // Expect change due to hashing multiple blocks
    }

    @Test
    @Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testHash32x86_OffsetSingleBlock_RWcp3() {
        byte[] data = {0, 0, 0, 0, 1, 2, 3, 4};
        int seed = 123;
        int result = MurmurHash3.hash32x86(data, 4, 4, seed);
        assertNotEquals(seed, result); // Expect change due to hashing with offset
    }

    @Test
    @Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testHash32x86_OffsetMultipleBlocks_ifkL4() {
        byte[] data = new byte[16];
        for (int i = 0; i < 16; i++) {
            data[i] = (byte) i;
        }
        int seed = 123;
        int result = MurmurHash3.hash32x86(data, 4, 12, seed);
        assertNotEquals(seed, result); // Expect change due to hashing multiple blocks with offset
    }

    @Test
    @Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testHash32x86_RemainingBytes1_AyPL5() {
        byte[] data = {1, 2, 3, 4, 5};
        int seed = 123;
        int result = MurmurHash3.hash32x86(data, 0, 5, seed);
        assertNotEquals(seed, result); // Expect change due to remaining 1 byte
    }

    @Test
    @Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testHash32x86_RemainingBytes2_qrYP6() {
        byte[] data = {1, 2, 3, 4, 5, 6};
        int seed = 123;
        int result = MurmurHash3.hash32x86(data, 0, 6, seed);
        assertNotEquals(seed, result); // Expect change due to remaining 2 bytes
    }

    @Test
    @Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testHash32x86_RemainingBytes3_GmBe7() {
        byte[] data = {1, 2, 3, 4, 5, 6, 7};
        int seed = 123;
        int result = MurmurHash3.hash32x86(data, 0, 7, seed);
        assertNotEquals(seed, result); // Expect change due to remaining 3 bytes
    }

    @Test
    @Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testHash32x86_AllBytesProcessed_Bdvb8() {
        byte[] data = {1, 2, 3, 4, 5, 6, 7, 8};
        int seed = 123;
        int result = MurmurHash3.hash32x86(data, 0, 8, seed);
        assertNotEquals(seed, result); // Expect change due to all bytes processed
    }

    @Test
    @Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testHash32x86_LargeData_StxR9() {
        byte[] data = new byte[1024];
        for (int i = 0; i < 1024; i++) {
            data[i] = (byte) (i % 256);
        }
        int seed = 123;
        int result = MurmurHash3.hash32x86(data, 0, 1024, seed);
        assertNotEquals(seed, result); // Expect change due to large data
    }

    @Test
    @Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testHash32x86_NegativeOffset_mqac10() {
        byte[] data = {1, 2, 3, 4, 5, 6, 7, 8};
        int seed = 123;
        try {
            MurmurHash3.hash32x86(data, -1, 8, seed);
            fail("Should throw an exception due to negative offset");
        } catch (ArrayIndexOutOfBoundsException e) {
        }
    }

    @Test
    @Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testHash32x86_ExcessiveLength_tLjW11() {
        byte[] data = {1, 2, 3, 4, 5, 6, 7, 8};
        int seed = 123;
        try {
            MurmurHash3.hash32x86(data, 0, 16, seed);
            fail("Should throw an exception due to excessive length");
        } catch (ArrayIndexOutOfBoundsException e) {
        }
    }

    @Test
    @Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testHash32WithNonNullData_kZly0() {
        String input = "Hello, World!";
        int result = MurmurHash3.hash32(input);
        assertNotNull(result); // Check if the result is not null, which implies the method was executed
    }

    @Test
    @Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testHash32WithEmptyString_erPu1() {
        String input = "";
        int result = MurmurHash3.hash32(input);
        assertNotNull(result); // Check if the result is not null, which implies the method was executed
    }

    @Test
    @Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testHash32WithDefaultSeed_dEAS0() {
        byte[] data = new byte[]{1, 2, 3, 4}; // Example data
        int length = data.length;
        int expectedHash = MurmurHash3.hash32(data, length, MurmurHash3.DEFAULT_SEED);
        int actualHash = MurmurHash3.hash32(data, length);
    }

    @Test
    @Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testHash32InitialSeed_CtNo0_tPlP0() {
        int seed = 123;
        byte[] data = new byte[0]; // empty data array
        int result = MurmurHash3.hash32(data, 0, seed);
        assertNotEquals(result, seed, "Result should not be the same as initial seed");
    }

    @Test
    @Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testHash32ReverseBytesData1_lpIG1_IBtv0() {
        byte[] data = new byte[]{0x01, 0x23, 0x45, 0x67, (byte) 0x89, (byte) 0xAB, (byte) 0xCD, (byte) 0xEF};
        int length = data.length;
        int seed = 0;
        int result = MurmurHash3.hash32(data, length, seed);
        assertNotEquals(0, result, "Result should not be zero when data1 is non-zero");
    }

    @Test
    @Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testHash32Mix32FirstPartData1_JOTW3_maMQ0() {
        byte[] data = new byte[]{(byte) 0xFF, (byte) 0xFF, (byte) 0xFF, (byte) 0xFF, 0, 0, 0, 0};
        int seed = 0;
        int result = MurmurHash3.hash32(data, data.length, seed);
        assertNotEquals(0, result, "Result should not be zero when high bits of data1 are set");
    }

    @Test
    @Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testHash32Mix32SecondPartData1_PqEA4_HrbV0() {
        byte[] data = new byte[8];
        data[0] = (byte) 0xFF;
        data[1] = (byte) 0xFF;
        data[2] = (byte) 0xFF;
        data[3] = (byte) 0xFF;
        int seed = 0;
        int result = MurmurHash3.hash32(data, 8);
    }

    @Test
    @Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testHash32Mix32FirstPartData2_UHaA5_XwRN0() {
        byte[] data = new byte[8];
        data[0] = (byte) 0xFF;
        data[1] = (byte) 0xFF;
        data[2] = (byte) 0xFF;
        data[3] = (byte) 0xFF;
        int seed = 0;
        int result = MurmurHash3.hash32(data, data.length, seed);
        assertNotEquals(0, result);
    }

    @Test
    @Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testHash32Mix32SecondPartData2_QaBC6_fCnz0() {
        byte[] data = new byte[8];
        data[4] = (byte) 0xff;
        data[5] = (byte) 0xff;
        data[6] = (byte) 0xff;
        data[7] = (byte) 0xff;
        int seed = 0;
        int result = MurmurHash3.hash32(data, data.length, seed);
        assertNotEquals(0, result, "Result should not be zero when low bits of data2 are set");
    }
}