/**
 * Generated by Aster
 */
package org.apache.commons.codec.binary;

import static org.junit.jupiter.api.Assertions.*;
import static org.junit.jupiter.api.Timeout.ThreadMode.SEPARATE_THREAD;

import java.math.BigInteger;
import java.util.concurrent.TimeUnit;
import org.apache.commons.codec.CodecPolicy;
import org.apache.commons.codec.DecoderException;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.Timeout;
import org.junit.jupiter.api.Timeout.ThreadMode;

public class Aster_Base64_Coverage_Test_Passing {
    private static final byte[] CHUNK_SEPARATOR = {'\r', '\n'};

    @Test
    @Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testIsArrayByteBase64_CoversReturnLine_JoVR0() {
        byte[] validBase64EncodedBytes = "TWFu".getBytes(); // "Man" in Base64
    }

    @Test
    @Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testEncodeBase64_Chunked_zYwr0_1() {
        byte[] binaryData = "Hello World".getBytes();
        boolean isChunked = true;
        boolean urlSafe = false;
        int maxResultSize = 100;
        byte[] encodedData = Base64.encodeBase64(binaryData, isChunked, urlSafe, maxResultSize);
        assertNotNull(encodedData);
    }

    @Test
    @Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testEncodeBase64_Chunked_zYwr0_2() {
        byte[] binaryData = "Hello World".getBytes();
        boolean isChunked = true;
        boolean urlSafe = false;
        int maxResultSize = 100;
        byte[] encodedData = Base64.encodeBase64(binaryData, isChunked, urlSafe, maxResultSize);
        assertTrue(encodedData.length > 0);
    }

    @Test
    @Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testEncodeBase64_NotChunked_kdkw1_1() {
        byte[] binaryData = "Hello World".getBytes();
        boolean isChunked = false;
        boolean urlSafe = false;
        int maxResultSize = 100;
        byte[] encodedData = Base64.encodeBase64(binaryData, isChunked, urlSafe, maxResultSize);
        assertNotNull(encodedData);
    }

    @Test
    @Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testEncodeBase64_NotChunked_kdkw1_2() {
        byte[] binaryData = "Hello World".getBytes();
        boolean isChunked = false;
        boolean urlSafe = false;
        int maxResultSize = 100;
        byte[] encodedData = Base64.encodeBase64(binaryData, isChunked, urlSafe, maxResultSize);
        assertTrue(encodedData.length > 0);
    }

    @Test
    @Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testGetDefaultBufferSize_PSTx0() {
        Base64 base64 = new Base64();
        int expectedBufferSize = 8192; // Assuming DEFAULT_BUFFER_SIZE is 8192
        assertEquals(expectedBufferSize, base64.getDefaultBufferSize(), "Buffer size should match the default value");
    }

    @Test
    @Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testEncodeWithEmptyArray_GOwW0_1() {
        Base64 base64 = new Base64();
        byte[] emptyArray = new byte[0];
        byte[] result = base64.encode(emptyArray);
        assertNotNull(result, "Result should not be null");
    }

    @Test
    @Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testEncodeWithEmptyArray_GOwW0_2() {
        Base64 base64 = new Base64();
        byte[] emptyArray = new byte[0];
        byte[] result = base64.encode(emptyArray);
        assertArrayEquals(emptyArray, result, "Encoded empty array should be equal to input empty array");
    }

    @Test
    @Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testEncodeWithNonEmptyArray_FJnD1_1() {
        Base64 base64 = new Base64();
        byte[] nonEmptyArray = new byte[]{'h', 'e', 'l', 'l', 'o'};
        byte[] result = base64.encode(nonEmptyArray);
        assertNotNull(result, "Result should not be null");
    }

    @Test
    @Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testEncodeWithNonEmptyArray_FJnD1_2() {
        Base64 base64 = new Base64();
        byte[] nonEmptyArray = new byte[]{'h', 'e', 'l', 'l', 'o'};
        byte[] result = base64.encode(nonEmptyArray);
        assertArrayEquals(new byte[]{'a', 'G', 'V', 's', 'b', 'G', '8', '='}, result, "Encoded array should match expected base64 encoded result");
    }

    @Test
    @Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testDecodeWithByteArray_NNOT0() throws DecoderException {
        Base64 base64 = new Base64();
        byte[] input = "SGVsbG8gV29ybGQ=".getBytes();
        byte[] expectedOutput = "Hello World".getBytes(); // Assuming decode method correctly decodes Base64 encoded string to byte array
        byte[] actualOutput = (byte[]) base64.decode(input);
        assertArrayEquals(expectedOutput, actualOutput);
    }

    @Test
    @Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testGetCodecPolicy_Strict_eFoC0() {
        byte[] lineSeparator = new byte[]{'\n'};
        Base64 base64 = new Base64(76, lineSeparator, true, CodecPolicy.STRICT);
        assertEquals(CodecPolicy.STRICT, base64.getCodecPolicy());
    }

    @Test
    @Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testGetCodecPolicy_Lenient_dBrt1() {
        byte[] lineSeparator = new byte[]{'\n'};
        Base64 base64 = new Base64(76, lineSeparator, true, CodecPolicy.LENIENT);
        assertEquals(CodecPolicy.LENIENT, base64.getCodecPolicy());
    }

    @Test
    @Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testDecodeWithEmptyArray_KxWA0() {
        Base64 base64 = new Base64();
        byte[] input = new byte[0];
        byte[] expected = new byte[0];
        byte[] result = base64.decode(input);
        assertArrayEquals(expected, result, "Decoding an empty array should return an empty array.");
    }

    @Test
    @Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testDecodeWithNonEmptyArray_mxor1() {
        Base64 base64 = new Base64();
        byte[] input = {'T', 'W', 'F', 'u'}; // Base64 encoded string for "Man"
        byte[] expected = {'M', 'a', 'n'};
        byte[] result = base64.decode(input);
        assertArrayEquals(expected, result, "Decoding a non-empty array should return the decoded array.");
    }

    @Test
    @Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testGetEncodedLength_CalculateNonChunkedSize_YNBO0() {
        byte[] input = new byte[3]; // Length not exactly divisible by unencodedBlockSize
        Base64 base64 = new Base64(0, new byte[]{}, false);
        long expectedLength = 4; // Assuming unencodedBlockSize = 3 and encodedBlockSize = 4
        long actualLength = base64.getEncodedLength(input);
        assertEquals(expectedLength, actualLength);
    }

    @Test
    @Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testGetEncodedLength_CastToLongToAvoidOverflow_Muin1() {
        byte[] input = new byte[Integer.MAX_VALUE - 2]; // Large size to potentially cause overflow
        Base64 base64 = new Base64(0, new byte[]{}, false);
        long expectedLength = ((long) Integer.MAX_VALUE - 2 + 2) / 3 * 4; // Assuming unencodedBlockSize = 3 and encodedBlockSize = 4
        long actualLength = base64.getEncodedLength(input);
        assertEquals(expectedLength, actualLength);
    }

    @Test
    @Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testGetEncodedLength_ComplexCalculation_iYAa2() {
        byte[] input = new byte[5]; // Length not exactly divisible by unencodedBlockSize
        Base64 base64 = new Base64(0, new byte[]{}, false);
        long expectedLength = ((5 + 2) / 3) * 4; // Assuming unencodedBlockSize = 3 and encodedBlockSize = 4
        long actualLength = base64.getEncodedLength(input);
        assertEquals(expectedLength, actualLength);
    }

    @Test
    @Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testGetEncodedLength_RoundUpToNearestMultiple_pyOn3() {
        byte[] input = new byte[5];
        Base64 base64 = new Base64(4, new byte[]{10}, false); // lineLength = 4, lineSeparator = {10}
        long expectedLength = ((5 + 2) / 3) * 4; // Initial length calculation
        expectedLength += (expectedLength + 4 - 1) / 4 * 1; // Adding chunk separators
        long actualLength = base64.getEncodedLength(input);
        assertEquals(expectedLength, actualLength);
    }

    @Test
    @Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testToIntegerBytesWithSmallNumber_UWHB1() {
        BigInteger bigInt = new BigInteger("1");
        byte[] expected = {1};
        assertArrayEquals(expected, Base64.toIntegerBytes(bigInt));
    }

    @Test
    @Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testToIntegerBytesWithBitLengthMultipleOfEight_sXdY2() {
        BigInteger bigInt = new BigInteger("256");
        byte[] expected = {1, 0};
        assertArrayEquals(expected, Base64.toIntegerBytes(bigInt));
    }

    @Test
    @Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testToIntegerBytesWithNoPaddingRequired_FVSz13() {
        BigInteger bigInt = new BigInteger("768");
        byte[] expected = {3, 0};
        assertArrayEquals(expected, Base64.toIntegerBytes(bigInt));
    }

    @Test
    public void testDecodeWithInvalidInputType_cMwU1_tTWN0() {
        Base64 base64 = new Base64();
        Object invalidInput = new Object(); // Not a byte[] or String
        try {
            base64.decode(invalidInput);
            fail("Expected a DecoderException to be thrown");
        } catch (DecoderException e) {
        }
    }

    @Test
    public void testEncodeBase64_ExceedsMaxResultSize_MocW2_rdec0() {
        byte[] binaryData = new byte[1024 * 1024]; // 1MB of data
        boolean isChunked = false;
        boolean urlSafe = false;
        int maxResultSize = 10; // deliberately small to trigger the exception
        try {
            Base64.encodeBase64(binaryData, isChunked, urlSafe, maxResultSize);
            fail("Expected an IllegalArgumentException to be thrown");
        } catch (IllegalArgumentException e) {
        }
    }

    @Test
    @Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testIsBase64_ValidBase64_GXQD1_IpSd0() {
        byte[] arrayOctet = "TWFu".getBytes(); // "Man" in Base64
        assertTrue(Base64.isBase64(arrayOctet));
    }

    @Test
    @Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testIsBase64_ValidBase64Octet_SLMj0_GLyh0() {
        byte validBase64Octet = 'A'; // Typically 'A' is part of Base64 encoding
        assertTrue(Base64.isBase64(validBase64Octet), "Expected true for a valid Base64 character");
    }

    @Test
    @Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testIsBase64_InvalidBase64_jHIH2_RpNi0() {
        byte[] arrayOctet = "TWFu$".getBytes(); // "Man" in Base64 with an invalid character '$'
        assertFalse(Base64.isBase64(arrayOctet));
    }

    @Test
    @Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testIsInAlphabet_ValidOctet_ByqY0_mrhy0() {
        byte[] validOctet = new byte[]{(byte) 'B', (byte) 'y', (byte) 'q', (byte) 'Y', (byte) '0'};
        Base64 base64 = new Base64();
        assertTrue(base64.containsAlphabetOrPad(validOctet), "Octet should be in the alphabet");
    }

    @Test
    @Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testIsInAlphabetWithEmptyArray_vzjy0_bmSH0() {
        Base64 base64 = new Base64();
        byte[] emptyArray = new byte[0];
        boolean result = base64.containsAlphabetOrPad(emptyArray);
        assertFalse(result, "Empty array should return true");
    }

    @Test
    @Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testIsStrictDecodingFalse_bZhi1_hijx0() {
        Base64 base64 = new Base64(0, new byte[]{}, false, CodecPolicy.LENIENT);
        assertFalse(base64.isStrictDecoding());
    }

    @Test
    @Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testIsBase64_WithWhitespace_hPId3_ZzsE0() {
        byte[] arrayOctet = "TWFu \n\t".getBytes(); // "Man" in Base64 followed by whitespace
        assertTrue(Base64.isBase64(arrayOctet), "Array containing valid Base64 characters and whitespace should return true");
    }

    @Test
    @Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testContainsAlphabetOrPadWithNullArray_cWKi0_Ydyk0() {
        Base64 base64 = new Base64();
        byte[] arrayOctet = null;
        boolean result = base64.containsAlphabetOrPad(arrayOctet);
        assertFalse(result, "Expected false when input array is null");
    }

    @Test
    @Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testEncodeBase64_Chunked_zYwr0() {
        byte[] binaryData = "Hello World".getBytes();
        boolean isChunked = true;
        boolean urlSafe = false;
        int maxResultSize = 100;
        byte[] encodedData = Base64.encodeBase64(binaryData, isChunked, urlSafe, maxResultSize);
        assertNotNull(encodedData);
        assertTrue(encodedData.length > 0);
    }

    @Test
    @Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testEncodeBase64_NotChunked_kdkw1() {
        byte[] binaryData = "Hello World".getBytes();
        boolean isChunked = false;
        boolean urlSafe = false;
        int maxResultSize = 100;
        byte[] encodedData = Base64.encodeBase64(binaryData, isChunked, urlSafe, maxResultSize);
        assertNotNull(encodedData);
        assertTrue(encodedData.length > 0);
    }

    @Test
    @Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testEncodeWithEmptyArray_GOwW0() {
        Base64 base64 = new Base64();
        byte[] emptyArray = new byte[0];
        byte[] result = base64.encode(emptyArray);
        assertNotNull(result, "Result should not be null");
        assertArrayEquals(emptyArray, result, "Encoded empty array should be equal to input empty array");
    }

    @Test
    @Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testEncodeWithNonEmptyArray_FJnD1() {
        Base64 base64 = new Base64();
        byte[] nonEmptyArray = new byte[]{'h', 'e', 'l', 'l', 'o'};
        byte[] result = base64.encode(nonEmptyArray);
        assertNotNull(result, "Result should not be null");
        assertArrayEquals(new byte[]{'a', 'G', 'V', 's', 'b', 'G', '8', '='}, result, "Encoded array should match expected base64 encoded result");
    }
}