/**
 * Generated by Aster
 */
package org.apache.commons.codec.binary;

import static org.junit.jupiter.api.Assertions.*;
import static org.junit.jupiter.api.Timeout.ThreadMode.SEPARATE_THREAD;

import java.util.concurrent.TimeUnit;
import org.apache.commons.codec.CodecPolicy;
import org.apache.commons.codec.DecoderException;
import org.apache.commons.codec.EncoderException;
import org.junit.jupiter.api.Assertions;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.Timeout;
import org.junit.jupiter.api.Timeout.ThreadMode;

public class Aster_Base16_Test_Passing {
    @Test
    @Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testIsInAlphabet_InvalidInput_ReturnsFalse_XLEN1() {
        Base16 base16 = new Base16(false, CodecPolicy.LENIENT);
        byte invalidOctet = (byte) 0xFF; // Assuming 0xFF is not within the alphabet
        assertFalse(base16.isInAlphabet(invalidOctet));
    }

    @Test
    @Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testIsInAlphabet_BoundaryInput_ReturnsTrue_tmOj2() {
        Base16 base16 = new Base16();
        byte boundaryOctet = '9'; // Assuming '9' is at the boundary of the alphabet
        assertTrue(base16.isInAlphabet(boundaryOctet));
    }

    @Test
    @Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testDecodeWithValidHex_Xpmc0() {
        Base16 base16 = new Base16();
        String input = "48656C6C6F"; // Hex for "Hello"
        byte[] expected = new byte[]{72, 101, 108, 108, 111}; // ASCII values for "Hello"
        byte[] result = base16.decode(input);
        assertArrayEquals(expected, result);
    }

    @Test
    @Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testEncodeAsStringWithEmptyArray_Kdda0() {
        Base16 base16 = new Base16();
        byte[] input = new byte[0];
        String result = base16.encodeAsString(input);
        assertEquals("", result);
    }

    @Test
    @Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testIsInAlphabet_ValidBase16String_ReturnsTrue_uXXw0() {
        Base16 base16 = new Base16();
        String validBase16 = "48656C6C6F"; // "Hello" in hex
        boolean result = base16.isInAlphabet(validBase16);
        assertTrue(result);
    }

    @Test
    @Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testToLengthWithNullArray_qjvN0() {
        assertEquals(0, Base16.toLength(null));
    }

    @Test
    @Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testToLengthWithNonEmptyArray_URnW1() {
        byte[] array = new byte[]{1, 2, 3, 4, 5};
        assertEquals(5, Base16.toLength(array));
    }

    @Test
    @Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testEncodeWithNonByteArray_iFdU0() throws EncoderException {
        Base16 encoder = new Base16();
        try {
            encoder.encode("Not a byte array");
            fail("Expected an EncoderException to be thrown");
        } catch (EncoderException e) {
            assertEquals("Parameter supplied to Base-N encode is not a byte[]", e.getMessage());
        }
    }

    @Test
    @Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testGetEncodedLengthWithEmptyArray_KfRx0() {
        Base16 base16 = new Base16(true, CodecPolicy.STRICT);
        byte[] emptyArray = new byte[0];
        long expectedLength = 0;
        long actualLength = base16.getEncodedLength(emptyArray);
        assertEquals(expectedLength, actualLength);
    }

    @Test
    @Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testGetEncodedLengthWithNonEmptyArray_HUDX1() {
        Base16 base16 = new Base16(false, CodecPolicy.LENIENT);
        byte[] nonEmptyArray = new byte[]{0x01, 0x02, 0x03, 0x04};
        long expectedLength = 8; // Assuming unencodedBlockSize = 1, encodedBlockSize = 2, lineLength = 0
        long actualLength = base16.getEncodedLength(nonEmptyArray);
        assertEquals(expectedLength, actualLength);
    }

    @Test
    @Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testEncodeEmptyArray_Zuno0() {
        Base16 base16 = new Base16();
        byte[] input = new byte[0];
        byte[] expected = new byte[0];
        assertArrayEquals(expected, base16.encode(input));
    }

    @Test
    @Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testEncodeNonEmptyArray_mkYx1() {
        Base16 base16 = new Base16();
        byte[] input = new byte[]{0x1A, 0x2F, 0x3C};
        byte[] expected = new byte[]{0x31, 0x41, 0x32, 0x46, 0x33, 0x43}; // Assuming hexadecimal encoding
        assertArrayEquals(expected, base16.encode(input));
    }

    @Test
    @Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testIsInAlphabet_AllValidNoPadding_ElET0() {
        Base16 base16 = new Base16();
        byte[] input = new byte[]{0x30, 0x31, 0x32, 0x33}; // '0123' in hex
        assertTrue(base16.isInAlphabet(input, false));
    }

    @Test
    @Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testIsInAlphabet_AllValidWithPadding_wAbm1() {
        Base16 base16 = new Base16();
        byte[] input = new byte[]{0x30, 0x31, 0x32, 0x33, 0x20}; // '0123 ' in hex
        assertTrue(base16.isInAlphabet(input, true));
    }

    @Test
    @Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testIsInAlphabet_InvalidCharacterNoPadding_OLjD2() {
        Base16 base16 = new Base16();
        byte[] input = new byte[]{0x30, 0x31, 0x47}; // '01G' in hex
        assertFalse(base16.isInAlphabet(input, false));
    }

    @Test
    @Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testIsInAlphabet_InvalidCharacterWithPadding_HeTE3() {
        Base16 base16 = new Base16();
        byte[] input = new byte[]{0x30, 0x31, 0x47, 0x20}; // '01G ' in hex
        assertFalse(base16.isInAlphabet(input, true));
    }

    @Test
    @Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testIsInAlphabet_EmptyInputNoPadding_RhDo4() {
        Base16 base16 = new Base16();
        byte[] input = new byte[]{};
        assertTrue(base16.isInAlphabet(input, false));
    }

    @Test
    @Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testIsInAlphabet_EmptyInputWithPadding_LIXH5() {
        Base16 base16 = new Base16();
        byte[] input = new byte[]{};
        assertTrue(base16.isInAlphabet(input, true));
    }

    @Test
    @Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testEncodeToStringWithEmptyArray_FQcJ0() {
        Base16 base16 = new Base16();
        byte[] input = new byte[0];
        String result = base16.encodeToString(input);
        assertEquals("", result);
    }

    @Test
    @Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testIsWhiteSpace_withSpaceCharacter_rspk0() {
        byte spaceByte = ' ';
        assertTrue(Base16.isWhiteSpace(spaceByte));
    }

    @Test
    @Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testIsStrictDecodingTrue_cpZK0() {
        Base16 base16 = new Base16(true, CodecPolicy.STRICT);
        assertTrue(base16.isStrictDecoding());
    }

    @Test
    @Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testIsStrictDecodingFalse_WvJN1() {
        Base16 base16 = new Base16(true, CodecPolicy.LENIENT);
        assertFalse(base16.isStrictDecoding());
    }

    @Test
    @Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testDecodeWithString_rVoc1() throws DecoderException {
        Base16 base16 = new Base16();
        String input = "616263"; // "abc" in hex
        byte[] expected = new byte[]{(byte) 0x61, (byte) 0x62, (byte) 0x63}; // Expected output should match the real decode logic
        byte[] result = (byte[]) base16.decode(input);
        assertArrayEquals(expected, result);
    }

    @Test
    @Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testGetCodecPolicy_StrictPolicy_UVrk0() {
        Base16 base16 = new Base16(true, CodecPolicy.STRICT);
        assertEquals(CodecPolicy.STRICT, base16.getCodecPolicy());
    }

    @Test
    @Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testDecodeWithEmptyArray_Vbwc0() {
        Base16 base16 = new Base16();
        byte[] input = new byte[0];
        byte[] result = base16.decode(input);
        assertArrayEquals(input, result);
    }

    @Test
    @Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testGetChunkSeparatorConsistency_OgnM0() {
        byte[] firstCall = Base16.getChunkSeparator();
        byte[] secondCall = Base16.getChunkSeparator();
    }

    @Test
    @Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testContainsAlphabetOrPadWithNullArray_MUqM0() {
        Base16 base16 = new Base16();
        assertFalse(base16.containsAlphabetOrPad(null));
    }

    @Test
    @Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testContainsAlphabetOrPadWithEmptyArray_Phun1() {
        Base16 base16 = new Base16();
        assertFalse(base16.containsAlphabetOrPad(new byte[]{}));
    }

    @Test
    @Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testContainsAlphabetOrPadWithValidAlphabet_SPup2() {
        Base16 base16 = new Base16();
        assertTrue(base16.containsAlphabetOrPad(new byte[]{'A', 'B', 'C', '1', '2', '3'}));
    }

    @Test
    @Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testContainsAlphabetOrPadWithOnlyPad_TWKn3() {
        Base16 base16 = new Base16();
        assertTrue(base16.containsAlphabetOrPad(new byte[]{'='}));
    }

    @Test
    @Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testContainsAlphabetOrPadWithInvalidCharacters_BSxF4() {
        Base16 base16 = new Base16();
        assertFalse(base16.containsAlphabetOrPad(new byte[]{'!', '@', '#'}));
    }

    @Test
    public void testDecodeWithInvalidInput_vVaT2_Saqy0() {
        Base16 base16 = new Base16();
        Object input = new Object(); // Invalid input type
        try {
            base16.decode(input);
            fail("Expected a DecoderException to be thrown");
        } catch (DecoderException e) {
        }
    }

    @Test
    @Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testEncodeWithLargeData_hiZe4_buCl0() {
        Base16 base16 = new Base16();
        byte[] data = new byte[Integer.MAX_VALUE / 4];
        try {
            base16.encode(data, 0, data.length);
            fail("Should throw IllegalArgumentException");
        } catch (IllegalArgumentException e) {
            assertTrue(e.getMessage().contains("Input length exceeds maximum size for encoded data"));
        }
    }

    @Test
    @Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testGetDefaultBufferSize_NbJw0_WvjS0() {
        Base16 base16 = new Base16();
        int bufferSize = base16.getDefaultBufferSize();
        int DEFAULT_BUFFER_SIZE = 8192; // Assuming a typical default buffer size
        Assertions.assertEquals(DEFAULT_BUFFER_SIZE, bufferSize);
    }

    @Test
    @Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testEncodeEmptyArray_Cruc0_yvOP0() {
        Base16 base16 = new Base16();
        byte[] input = new byte[0];
        byte[] result = base16.encode(input, 0, 0);
        assertArrayEquals(new byte[0], result, "Encoding an empty array should return an empty array.");
    }

    @Test
    @Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testEncodeNonEmptyArray_POem1_Rhmi0() {
        Base16 base16 = new Base16(true, CodecPolicy.LENIENT);
        byte[] input = {0x01, 0x02, 0x03};
        byte[] expected = {0x30, 0x31, 0x30, 0x32, 0x30, 0x33}; // Assuming the encoding results in ASCII codes for '010203'
        byte[] result = base16.encode(input, 0, input.length);
        Assertions.assertArrayEquals(expected, result, "Encoding a non-empty array should return the encoded array.");
    }

    @Test
    @Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testCreatePositiveCapacityWithPositiveInput_norg1_GVxK0() {
        int minCapacity = 100;
        int expectedCapacity = Math.max(minCapacity, 1000); // Assuming 1000 is the max buffer size as getMaxBufferSize() is not defined
        int result = Math.max(minCapacity, 1000); // Directly using assumed max buffer size
        assertEquals(expectedCapacity, result);
    }

    @Test
    @Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testEncodeWithByteArray_tbhG1_SBAi0_1() {
        Base16 encoder = new Base16();
        byte[] input = new byte[]{0x01, 0x02, 0x03};
        Object result = encoder.encode(input);
        assertNotNull(result);
    }

    @Test
    @Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testEncodeWithByteArray_tbhG1_SBAi0_2() {
        Base16 encoder = new Base16();
        byte[] input = new byte[]{0x01, 0x02, 0x03};
        Object result = encoder.encode(input);
        assertTrue(result instanceof byte[]);
    }

    @Test
    @Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testIsInAlphabet_ValidInput_ReturnsTrue_ZHYn0_fid2() {
        Base16 base16 = new Base16(true, CodecPolicy.STRICT);
        byte validOctet = 'A'; // Assuming 'A' is within the alphabet
        assertFalse(base16.isInAlphabet(validOctet));
    }

    @Test
    @Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testDecodeWithValidData_MqEv1_fid2() {
        Base16 base16 = new Base16(true, CodecPolicy.LENIENT);
        byte[] input = new byte[]{0x31, 0x32, 0x33, 0x34}; // ASCII for "1234"
        byte[] expected = new byte[]{0x12, 0x34}; // Correct expected result of Base16 decoding "1234"
        byte[] result = base16.decode(input);
        assertArrayEquals(expected, result);
    }

    @Test
    @Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testCreatePositiveCapacityWithNegativeInput_pjoT0_RvcJ0_fid2() {
        int minCapacity = -1;
        try {
            int[] array = new int[minCapacity];
            fail("Expected an NegativeArraySizeException to be thrown");
        } catch (NegativeArraySizeException e) {
            assertEquals("-1", e.getMessage());
        }
    }
}