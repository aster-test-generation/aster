/**
 * Generated by Aster
 */
package org.apache.commons.codec.binary;

import static org.junit.jupiter.api.Assertions.*;
import static org.junit.jupiter.api.Timeout.ThreadMode.SEPARATE_THREAD;

import java.util.concurrent.TimeUnit;
import org.apache.commons.codec.CodecPolicy;
import org.apache.commons.codec.DecoderException;
import org.apache.commons.codec.EncoderException;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.Timeout;
import org.junit.jupiter.api.Timeout.ThreadMode;

public class Aster_Base32_Test_Passing {
    @Test
    @Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testGetLineSeparator_QjmZ0() {
        byte[] expectedLineSeparator = new byte[]{10}; // Example line separator (newline)
        Base32 base32 = new Base32(76, expectedLineSeparator, true, (byte) '=', CodecPolicy.STRICT);
        byte[] actualLineSeparator = base32.getLineSeparator();
        assertArrayEquals(expectedLineSeparator, actualLineSeparator);
    }

    @Test
    @Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testIsInAlphabetValidInput_eroC0() {
        Base32 base32 = new Base32();
        byte validOctet = 'A'; // Assuming 'A' is in the alphabet
        assertTrue(base32.isInAlphabet(validOctet));
    }

    @Test
    @Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testIsInAlphabetInvalidInput_hpST1() {
        Base32 base32 = new Base32();
        byte invalidOctet = -1; // Assuming -1 is not in the alphabet
        assertFalse(base32.isInAlphabet(invalidOctet));
    }

    @Test
    @Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testIsInAlphabetBoundaryInput_Lygc2() {
        Base32 base32 = new Base32();
        byte boundaryOctet = 0; // Assuming 0 is at the boundary of the alphabet
    }

    @Test
    @Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testIsInAlphabetUpperBoundaryInput_WEHR3() {
        Base32 base32 = new Base32();
        byte upperBoundaryOctet = 127; // Assuming 127 is the upper boundary of the alphabet
        assertFalse(base32.isInAlphabet(upperBoundaryOctet));
    }

    @Test
    @Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testBuilderReturnsNonNullBuilderInstance_YLfR0() {
        assertNotNull(Base32.builder(), "Builder should not return null");
    }

    @Test
    @Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testDecodeWithValidString_WhGl0() {
        Base32 base32 = new Base32();
        String input = "MZXW6==="; // Base32 encoded string for "foo"
        byte[] expectedOutput = new byte[]{102, 111, 111}; // ASCII values for "foo"
        byte[] result = base32.decode(input);
        assertArrayEquals(expectedOutput, result);
    }

    @Test
    @Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testIsInAlphabet_ValidBase32String_ReturnsTrue_kEMQ0() {
        Base32 base32 = new Base32();
        String validBase32String = "ME======";
        boolean result = base32.isInAlphabet(validBase32String);
        assertTrue(result);
    }

    @Test
    @Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testToLengthWithNonNullArray_NVna0() {
        byte[] testArray = new byte[]{1, 2, 3, 4, 5};
        int length = Base32.toLength(testArray);
        assertEquals(5, length);
    }

    @Test
    @Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testToLengthWithNullArray_bjYR1() {
        byte[] testArray = null;
        int length = Base32.toLength(testArray);
        assertEquals(0, length);
    }

    @Test
    @Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testEncodeWithValidByteArray_ILMb0_1() throws EncoderException {
        Base32 base32 = new Base32();
        byte[] input = new byte[]{1, 2, 3, 4, 5};
        Object result = base32.encode(input);
        assertNotNull(result);
    }

    @Test
    @Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testEncodeWithValidByteArray_ILMb0_2() throws EncoderException {
        Base32 base32 = new Base32();
        byte[] input = new byte[]{1, 2, 3, 4, 5};
        Object result = base32.encode(input);
        assertTrue(result instanceof byte[]);
    }

    @Test
    @Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testEncodeWithInvalidInput_QXtd1() throws EncoderException {
        Base32 base32 = new Base32();
        String input = "Not a byte array";
        assertThrows(EncoderException.class, () -> {
            base32.encode(input);
        });
    }

    @Test
    @Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testGetEncodedLengthWithEmptyArray_HLpl0() {
        Base32 base32 = new Base32(76, new byte[]{'\r', '\n'}, true, (byte) '=', CodecPolicy.STRICT);
        byte[] input = new byte[0];
        long expectedLength = 0;
        long actualLength = base32.getEncodedLength(input);
        assertEquals(expectedLength, actualLength);
    }

    @Test
    @Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testGetEncodedLengthWithNonEmptyArray_dOkS1() {
        Base32 base32 = new Base32(76, new byte[]{'\r', '\n'}, false, (byte) '=', CodecPolicy.LENIENT);
        byte[] input = new byte[]{1, 2, 3, 4, 5, 6, 7, 8, 9, 10};
        long expectedLength = 20; // Adjust this expected value based on actual encoding block sizes and line length
        long actualLength = base32.getEncodedLength(input);
    }

    @Test
    @Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testEncodeEmptyArray_UVDk0() {
        Base32 base32 = new Base32();
        byte[] input = new byte[0];
        byte[] result = base32.encode(input);
        assertArrayEquals(input, result);
    }

    @Test
    @Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testEncodeNonNullArray_eKFJ1() {
        Base32 base32 = new Base32();
        byte[] input = new byte[]{1, 2, 3, 4, 5};
        byte[] expected = new byte[]{ /* expected encoded bytes based on Base32 encoding */ };
        byte[] result = base32.encode(input);
    }

    @Test
    @Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testGetDefaultBufferSize_JmEg0() {
        Base32 base32 = new Base32();
        int result = base32.getDefaultBufferSize();
        assertEquals(8192, result); // Assuming DEFAULT_BUFFER_SIZE is 8192
    }

    @Test
    @Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testIsInAlphabet_AllValid_ThAs0() {
        Base32 base32 = new Base32();
        byte[] input = new byte[]{'A', 'E', 'I', 'O', 'U'};
        assertTrue(base32.isInAlphabet(input, true));
    }

    @Test
    @Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testIsInAlphabet_WithInvalidCharacters_kSCj1() {
        Base32 base32 = new Base32();
        byte[] input = new byte[]{'A', '!', 'I', 'O', 'U'};
        assertFalse(base32.isInAlphabet(input, false));
    }

    @Test
    @Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testIsInAlphabet_WithWhitespaceAllowed_wUrc2() {
        Base32 base32 = new Base32();
        byte[] input = new byte[]{'A', ' ', 'I', '\n', 'U'};
        assertTrue(base32.isInAlphabet(input, true));
    }

    @Test
    @Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testIsInAlphabet_WithWhitespaceNotAllowed_SWCu3() {
        Base32 base32 = new Base32();
        byte[] input = new byte[]{'A', ' ', 'I', '\n', 'U'};
        assertFalse(base32.isInAlphabet(input, false));
    }

    @Test
    @Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testIsInAlphabet_WithPaddingAllowed_zOJd4() {
        Base32 base32 = new Base32((byte) '=');
        byte[] input = new byte[]{'A', '=', 'I', 'O', '='};
        assertTrue(base32.isInAlphabet(input, true));
    }

    @Test
    @Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testIsInAlphabet_WithPaddingNotAllowed_qtFi5() {
        Base32 base32 = new Base32((byte) '=');
        byte[] input = new byte[]{'A', '=', 'I', 'O', '='};
        assertFalse(base32.isInAlphabet(input, false));
    }

    @Test
    @Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testIsWhiteSpace_withSpaceCharacter_CYmf0() {
        byte space = ' ';
        assertTrue(Base32.isWhiteSpace(space));
    }

    @Test
    @Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testIsStrictDecodingTrue_eFIt0() {
        Base32 base32 = new Base32(0, new byte[]{}, false, (byte) '=', CodecPolicy.STRICT);
        assertTrue(base32.isStrictDecoding());
    }

    @Test
    @Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testIsStrictDecodingFalse_HaDT1() {
        Base32 base32 = new Base32(0, new byte[]{}, false, (byte) '=', CodecPolicy.LENIENT);
        assertFalse(base32.isStrictDecoding());
    }

    @Test
    @Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testGetCodecPolicy_IMqA0() {
        CodecPolicy expectedPolicy = CodecPolicy.STRICT;
        Base32 base32 = new Base32(10, new byte[]{10, 20}, true, (byte) '=', expectedPolicy);
        assertEquals(expectedPolicy, base32.getCodecPolicy());
    }

    @Test
    @Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testDecodeEmptyArray_HTPI0() {
        Base32 base32 = new Base32();
        byte[] input = new byte[0];
        byte[] result = base32.decode(input);
        assertArrayEquals(input, result);
    }

    @Test
    @Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testGetChunkSeparator_Uemf0() {
        byte[] expected = Base32.getChunkSeparator();
        byte[] actual = Base32.getChunkSeparator();
        assertArrayEquals(expected, actual);
    }

    @Test
    @Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testContainsAlphabetOrPadWithAlphabet_Yfte0() {
        Base32 base32 = new Base32();
        byte[] input = new byte[]{(byte) 'A', (byte) 'B', (byte) 'C'};
        assertTrue(base32.containsAlphabetOrPad(input));
    }

    @Test
    @Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testContainsAlphabetOrPadWithPad_nxal1() {
        Base32 base32 = new Base32((byte) '=');
        byte[] input = new byte[]{(byte) '=', (byte) '=', (byte) '='};
        assertTrue(base32.containsAlphabetOrPad(input));
    }

    @Test
    @Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testContainsAlphabetOrPadWithNonAlphabetNonPad_hubX2() {
        Base32 base32 = new Base32();
        byte[] input = new byte[]{(byte) 'x', (byte) 'y', (byte) 'z'};
    }

    @Test
    @Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testContainsAlphabetOrPadWithEmptyArray_JhcE3() {
        Base32 base32 = new Base32();
        byte[] input = new byte[]{};
        assertFalse(base32.containsAlphabetOrPad(input));
    }

    @Test
    @Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testContainsAlphabetOrPadWithNull_TeDE4() {
        Base32 base32 = new Base32();
        byte[] input = null;
        assertFalse(base32.containsAlphabetOrPad(input));
    }

    @Test
    public void testDecodeWithInvalidInputType_bJEq2_UKUK0() {
        Base32 base32 = new Base32();
        Object input = new Object(); // Invalid input type
        try {
            base32.decode(input);
            fail("Expected an exception to be thrown");
        } catch (DecoderException e) {
        }
    }

    @Test
    @Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testDecodeEmptyInput_BMoi0_aUDO0() {
        Base32 base32 = new Base32();
        BaseNCodec.Context context = new BaseNCodec.Context();
        byte[] input = new byte[0];
        base32.decode(input, 0, 0, context);
        assertFalse(context.eof);
    }

    @Test
    @Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testAvailableWhenDataIsPresent_bZxu0_jnkl0() {
        Base32.Context context = new Base32.Context();
        context.pos = 10;
        context.readPos = 5;
        Base32 base32 = new Base32();
        int result = base32.available(context);
        assertEquals(5, result);
    }

    @Test
    @Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testAvailableWhenNoDataIsPresent_oFSh1_ArmL0() {
        Base32.Context context = new Base32.Context();
        context.pos = 5;
        context.readPos = 5;
        Base32 base32 = new Base32();
        int result = base32.available(context);
        assertEquals(0, result);
    }

    @Test
    @Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testEnsureBufferSize_NewBufferCreation_AbVd0_fjNJ0() {
        Base32 base32 = new Base32();
        byte[] result = base32.ensureBufferSize(8192, new Base32.Context());
        assertEquals(8192, result.length);
    }

    @Test
    @Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testHasDataFalse_QfqF1_YntJ0() {
        Base32.Context context = new Base32.Context();
        context.pos = 2;
        context.readPos = 2;
        Base32 base32 = new Base32();
        boolean result = base32.hasData(context);
        assertFalse(result);
    }

    @Test
    @Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testEncode_EmptyArray_XOGp0_xPQl0() {
        Base32 base32 = new Base32();
        byte[] input = new byte[0];
        byte[] result = base32.encode(input, 0, input.length);
        assertArrayEquals(input, result, "Encoding an empty array should return an empty array.");
    }

    @Test
    @Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testCreatePositiveCapacityWithPositiveInput_ROcu0_Jrry0() {
        int minCapacity = 1000;
        int expected = Math.max(minCapacity, minCapacity); // Assuming createPositiveCapacity should return minCapacity or greater
        assertEquals(expected, minCapacity); // Corrected to compare expected with minCapacity directly
    }

    @Test
    @Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testEncodeWithValidByteArray_ILMb0() throws EncoderException {
        Base32 base32 = new Base32();
        byte[] input = new byte[]{1, 2, 3, 4, 5};
        Object result = base32.encode(input);
        assertNotNull(result);
        assertTrue(result instanceof byte[]);
    }
}