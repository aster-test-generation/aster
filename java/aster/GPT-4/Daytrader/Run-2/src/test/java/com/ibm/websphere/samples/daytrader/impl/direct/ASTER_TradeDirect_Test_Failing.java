/**
 * Generated by Aster
 */
package com.ibm.websphere.samples.daytrader.impl.direct;

import com.ibm.websphere.samples.daytrader.beans.MarketSummaryDataBean;
import com.ibm.websphere.samples.daytrader.entities.*;
import com.ibm.websphere.samples.daytrader.util.TradeConfig;
import java.math.BigDecimal;
import java.sql.*;
import java.util.Collection;
import java.util.concurrent.Future;
import java.util.concurrent.TimeUnit;
import javax.enterprise.concurrent.ManagedExecutorService;
import javax.jms.JMSException;
import javax.sql.DataSource;
import javax.transaction.UserTransaction;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.Timeout;
import org.junit.jupiter.api.Timeout.ThreadMode;
import org.junit.jupiter.api.extension.ExtendWith;
import org.mockito.InjectMocks;
import org.mockito.Mock;
import org.mockito.Mockito;
import org.mockito.MockitoAnnotations;
import org.mockito.junit.jupiter.MockitoExtension;
import org.mockito.junit.jupiter.MockitoSettings;
import org.mockito.quality.Strictness;

import static org.junit.jupiter.api.Assertions.*;
import static org.junit.jupiter.api.Timeout.ThreadMode.SEPARATE_THREAD;
import static org.mockito.Mockito.*;

@ExtendWith(MockitoExtension.class)
@MockitoSettings(strictness = Strictness.LENIENT)
public class Aster_TradeDirect_Test_Failing {
  private static final String getTSIAQuotesOrderByChangeSQL = "select * from quoteejb q order by q.change1";
  private static final String getOpenTSIASQL = "select SUM(open1)/count(*) as openTSIA from quoteejb q ";
  private boolean inSession = false;
  private static final String getQuoteSQL = "select * from quoteejb q where q.symbol=?";
  private static final String getTSIASQL = "select SUM(price)/count(*) as TSIA from quoteejb q ";
  private static final String logoutSQL = "update accountejb set logoutcount=logoutcount+1 " + "where profile_userid=?";
  @InjectMocks
  private TradeDirect tradeDirect;
  @Mock
  private Connection connection;
  @Mock
  private Statement statement;
  @Mock
  private MarketSummaryDataBean marketSummaryDataBeanMock;
  @Mock
  private PreparedStatement preparedStatement;
  @Mock
  private ResultSet resultSet;
  @Mock
  private OrderDataBean orderDataBean;
  @Mock
  private DataSource dataSource;
  @Mock
  private UserTransaction txn;
  private AccountDataBean accountData;
  private QuoteDataBean quoteData;
  private HoldingDataBean holdingData;
  private OrderDataBean orderData;
  private String orderType;
  private double quantity;
  @Mock
  private ManagedExecutorService mes;
  private static long nextMarketSummary = System.currentTimeMillis();
  private static final Integer marketSummaryLock = new Integer(0);
  private static MarketSummaryDataBean cachedMSDB = MarketSummaryDataBean.getRandomInstance();
  private static final String getAllQuotesSQL = "select * from quoteejb q";

  @Test
  @Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
  public void testGetMarketSummary_IntervalZero() throws Exception {
    // Assuming MarketSummaryDataBean.getRandomInstance() is a static method we need to mock
    Mockito.mockStatic(MarketSummaryDataBean.class);
    when(MarketSummaryDataBean.getRandomInstance()).thenReturn(marketSummaryDataBeanMock);
    // Setup
    when(TradeConfig.getMarketSummaryInterval()).thenReturn(0);
    when(tradeDirect.getMarketSummaryInternal()).thenReturn(marketSummaryDataBeanMock);
    // Execution
    MarketSummaryDataBean result = tradeDirect.getMarketSummary();
    // Verification
    verify(tradeDirect).getMarketSummaryInternal();
    assertEquals(marketSummaryDataBeanMock, result, "Expected market summary data bean is not returned.");
  }

  @Test
  @Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
  public void testGetMarketSummary_IntervalNegative() throws Exception {
    // Assuming MarketSummaryDataBean.getRandomInstance() is a static method we need to mock
    Mockito.mockStatic(MarketSummaryDataBean.class);
    when(MarketSummaryDataBean.getRandomInstance()).thenReturn(marketSummaryDataBeanMock);
    // Setup
    when(TradeConfig.getMarketSummaryInterval()).thenReturn(-1);
    // Execution
    MarketSummaryDataBean result = tradeDirect.getMarketSummary();
    // Verification
    assertEquals(marketSummaryDataBeanMock, result, "Expected cached market summary data bean is not returned.");
  }

  @Test
  @Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
  public void testGetMarketSummaryWithZeroInterval_QRDY0() throws Exception {
    TradeConfig.setMarketSummaryInterval(0);
    TradeDirect tradeDirect = new TradeDirect();
    MarketSummaryDataBean result = tradeDirect.getMarketSummary();
    assertNotNull(result);
  }

  @Test
  @Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
  public void testInvestmentReturn_QhOG0_fid1() {
    TradeDirect tradeDirect = new TradeDirect();
    double rnd1 = 0.5;
    double rnd2 = 0.3;
    double result = tradeDirect.investmentReturn(rnd1, rnd2);
    assertEquals(0.15, result, 0.01);
  }

  @Test
  @Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
  public void testGetAllQuotesReturnsNonEmptyCollection_LpCA0() throws Exception {
    TradeDirect tradeDirect = new TradeDirect();
    Collection<QuoteDataBean> result = tradeDirect.getAllQuotes();
  }

  @Test
  @Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
  public void testGetAllQuotesReturnsNonEmptyCollection_oEWO0() throws Exception {
    TradeDirect tradeDirect = new TradeDirect();
    Collection<QuoteDataBean> result = tradeDirect.getAllQuotes();
    assertFalse(result.isEmpty());
  }

  @Test
  @Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
  public void testGetAllQuotesWithNoQuotes_VHIq0_fid1() throws Exception {
    TradeDirect tradeDirect = new TradeDirect();
    Collection<QuoteDataBean> result = tradeDirect.getAllQuotes();
    assertTrue(result.isEmpty());
  }

  @Test
  @Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
  public void testCompleteOrderWithTwoPhaseTrue_QEBY0() {
    TradeDirect tradeDirect = new TradeDirect();
    Integer orderID = 1; // Assuming a valid order ID for testing
    boolean twoPhase = true;
    try {
      OrderDataBean result = tradeDirect.completeOrder(orderID, twoPhase);
      assertNotNull(result);
    } catch (Exception e) {
      fail("Exception should not be thrown");
    }
  }

  @Test
  @Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
  public void testCompleteOrderWithTwoPhaseFalse_jcCK1() {
    TradeDirect tradeDirect = new TradeDirect();
    Integer orderID = 1; // Assuming a valid order ID for testing
    boolean twoPhase = false;
    try {
      OrderDataBean result = tradeDirect.completeOrder(orderID, twoPhase);
      assertNotNull(result);
    } catch (Exception e) {
      fail("Exception should not be thrown");
    }
  }

  @Test
  @Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
  public void testCompleteOrderWithValidOrderID_wNJZ0() {
    TradeDirect tradeDirect = new TradeDirect();
    Integer orderID = 1; // Assuming 1 is a valid order ID
    boolean twoPhase = true;
    try {
      OrderDataBean result = tradeDirect.completeOrder(orderID, twoPhase);
      assertNotNull(result);
      assertEquals("closed", result.getOrderStatus());
    } catch (Exception e) {
      fail("Exception should not be thrown for valid order ID");
    }
  }

  @Test
  @Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
  public void testCompleteOrderWithInvalidOrderID_IpGP1() {
    TradeDirect tradeDirect = new TradeDirect();
    Integer orderID = -1; // Assuming -1 is an invalid order ID
    boolean twoPhase = false;
    try {
      OrderDataBean result = tradeDirect.completeOrder(orderID, twoPhase);
      assertNull(result);
    } catch (Exception e) {
      assertTrue(e.getMessage().contains("unable to find order"));
    }
  }

  @Test
  @Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
  public void testCompleteOrderWithAlreadyCompletedOrder_QFxC2() {
    TradeDirect tradeDirect = new TradeDirect();
    Integer orderID = 2; // Assuming 2 is an order ID that is already completed
    boolean twoPhase = true;
    try {
      tradeDirect.completeOrder(orderID, twoPhase);
      fail("Exception should be thrown for already completed order");
    } catch (Exception e) {
      assertTrue(e.getMessage().contains("attempt to complete Order that is already completed"));
    }
  }

  @Test
  @Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
  public void testCompleteOrderWithAlreadyCompletedOrder_TAZJ2() {
    TradeDirect tradeDirect = new TradeDirect();
    Integer orderID = 3; // Assuming this is an order ID for an already completed order
    boolean twoPhase = false; // Not using two-phase commit
    try {
      tradeDirect.completeOrder(orderID, twoPhase);
      fail("Exception should have been thrown for trying to complete an already completed order");
    } catch (Exception e) {
      assertEquals("TradeDirect:completeOrder -- attempt to complete Order that is already completed", e.getMessage());
    }
  }

  @Test
  @Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
  public void testCompleteOrderWithValidBuyOrder_ijih0() {
    TradeDirect tradeDirect = new TradeDirect();
    Integer orderID = 1; // Assuming this is a valid order ID for a buy order
    boolean twoPhase = true; // Using two-phase commit
    try {
      OrderDataBean result = tradeDirect.completeOrder(orderID, twoPhase);
      assertNotNull(result);
      assertEquals("closed", result.getOrderStatus());
      assertTrue(result.getQuantity() > 0);
      assertNotNull(result.getHolding());
    } catch (Exception e) {
      fail("Exception should not be thrown");
    }
  }

  @Test
  @Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
  public void testCompleteOrderWithValidSellOrder_FtIr1() {
    TradeDirect tradeDirect = new TradeDirect();
    Integer orderID = 2; // Assuming this is a valid order ID for a sell order
    boolean twoPhase = false; // Not using two-phase commit
    try {
      OrderDataBean result = tradeDirect.completeOrder(orderID, twoPhase);
      assertNotNull(result);
      assertEquals("closed", result.getOrderStatus());
      assertNull(result.getHolding()); // Holding should be null after selling
    } catch (Exception e) {
      fail("Exception should not be thrown");
    }
  }

  @Test
  @Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
  public void testCompleteOrderWithAlreadyCompletedOrder_ZJHr2() {
    TradeDirect tradeDirect = new TradeDirect();
    Integer orderID = 3; // Assuming this is an order ID for an already completed order
    boolean twoPhase = true; // Using two-phase commit
    try {
      tradeDirect.completeOrder(orderID, twoPhase);
      fail("Exception should have been thrown for trying to complete an already completed order");
    } catch (Exception e) {
      assertTrue(e.getMessage().contains("already completed"));
    }
  }

  @Test
  @Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
  public void testCompleteOrderBuy_MzAH0_1() throws Exception {
    TradeDirect tradeDirect = new TradeDirect();
    Integer orderID = 1; // Assuming orderID 1 is a buy order
    boolean twoPhase = false;
    OrderDataBean result = tradeDirect.completeOrder(orderID, twoPhase);
    assertNotNull(result);
  }

  @Test
  @Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
  public void testCompleteOrderBuy_MzAH0_2() throws Exception {
    TradeDirect tradeDirect = new TradeDirect();
    Integer orderID = 1; // Assuming orderID 1 is a buy order
    boolean twoPhase = false;
    OrderDataBean result = tradeDirect.completeOrder(orderID, twoPhase);
    assertEquals("closed", result.getOrderStatus());
  }

  @Test
  @Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
  public void testCompleteOrderSell_ZLpU1_1() throws Exception {
    TradeDirect tradeDirect = new TradeDirect();
    Integer orderID = 2; // Assuming orderID 2 is a sell order
    boolean twoPhase = true;
    OrderDataBean result = tradeDirect.completeOrder(orderID, twoPhase);
    assertNotNull(result);
  }

  @Test
  @Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
  public void testCompleteOrderSell_ZLpU1_2() throws Exception {
    TradeDirect tradeDirect = new TradeDirect();
    Integer orderID = 2; // Assuming orderID 2 is a sell order
    boolean twoPhase = true;
    OrderDataBean result = tradeDirect.completeOrder(orderID, twoPhase);
    assertEquals("closed", result.getOrderStatus());
  }

  @Test
  @Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
  public void testCompleteOrderWithValidOrderID_TBYO0() {
    TradeDirect tradeDirect = new TradeDirect();
    Integer orderID = 1; // Assuming 1 is a valid order ID
    boolean twoPhase = true; // Testing with two-phase commit enabled
    try {
      OrderDataBean result = tradeDirect.completeOrder(orderID, twoPhase);
      assertNotNull(result);
      assertEquals("closed", result.getOrderStatus()); // Assuming the order status should be 'closed' after completion
    } catch (Exception e) {
      fail("Exception should not be thrown for a valid order ID");
    }
  }

  @Test
  @Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
  public void testCompleteOrderWithInvalidOrderID_AyWy1() {
    TradeDirect tradeDirect = new TradeDirect();
    Integer orderID = -1; // Assuming -1 is an invalid order ID
    boolean twoPhase = false; // Testing without two-phase commit
    try {
      OrderDataBean result = tradeDirect.completeOrder(orderID, twoPhase);
      assertNull(result); // Expecting null result for invalid order ID
    } catch (Exception e) {
      assertTrue(e.getMessage().contains("unable to find order")); // Check if the right exception message is thrown
    }
  }

  @Test
  @Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
  public void testCompleteOrderWithExceptionDuringCompletion_QeTP2() {
    TradeDirect tradeDirect = new TradeDirect();
    Integer orderID = 2; // Assuming 2 is a valid order ID but will cause an exception
    boolean twoPhase = true; // Testing with two-phase commit enabled
    try {
      OrderDataBean result = tradeDirect.completeOrder(orderID, twoPhase);
      fail("Exception was expected to be thrown due to order completion issues");
    } catch (Exception e) {
      assertNotNull(e);
      assertTrue(e.getMessage().contains("error completing order")); // Check if the exception message indicates a completion error
    }
  }

  @Test
  @Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
  public void testCompleteOrderWithValidOrderID_Bcpy0() {
    TradeDirect tradeDirect = new TradeDirect();
    Integer orderID = 1; // Assuming 1 is a valid order ID that exists in the database
    boolean twoPhase = false; // Single phase commit
    try {
      OrderDataBean result = tradeDirect.completeOrder(orderID, twoPhase);
      assertNotNull(result);
      assertEquals("closed", result.getOrderStatus()); // Assuming the order gets closed successfully
    } catch (Exception e) {
      fail("Exception should not be thrown for valid order ID");
    }
  }

  @Test
  @Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
  public void testCompleteOrderWithInvalidOrderID_ZAQI1() {
    TradeDirect tradeDirect = new TradeDirect();
    Integer orderID = 9999; // Assuming 9999 is an invalid order ID that does not exist in the database
    boolean twoPhase = false; // Single phase commit
    try {
      OrderDataBean result = tradeDirect.completeOrder(orderID, twoPhase);
      assertNull(result); // Expecting null as the order does not exist
    } catch (Exception e) {
      assertTrue(e.getMessage().contains("unable to find order"));
    }
  }

  @Test
  @Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
  public void testCompleteOrderWithTwoPhaseCommit_jpkx2() {
    TradeDirect tradeDirect = new TradeDirect();
    Integer orderID = 1; // Assuming 1 is a valid order ID that exists in the database
    boolean twoPhase = true; // Two phase commit
    try {
      OrderDataBean result = tradeDirect.completeOrder(orderID, twoPhase);
      assertNotNull(result);
      assertEquals("closed", result.getOrderStatus()); // Assuming the order gets closed successfully
    } catch (Exception e) {
      fail("Exception should not be thrown for valid order ID with two phase commit");
    }
  }

  @Test
  @Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
  public void testCompleteOrderWithValidBuyOrder_QbCi0() {
    TradeDirect tradeDirect = new TradeDirect();
    Integer orderID = 1; // Assuming this is a valid order ID for a buy order
    boolean twoPhase = true; // Using two-phase commit
    try {
      OrderDataBean result = tradeDirect.completeOrder(orderID, twoPhase);
      assertNotNull(result);
      assertEquals("closed", result.getOrderStatus());
    } catch (Exception e) {
      fail("Exception should not be thrown for a valid buy order");
    }
  }

  @Test
  @Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
  public void testCompleteOrderWithValidSellOrder_lHuV1() {
    TradeDirect tradeDirect = new TradeDirect();
    Integer orderID = 2; // Assuming this is a valid order ID for a sell order
    boolean twoPhase = false; // Not using two-phase commit
    try {
      OrderDataBean result = tradeDirect.completeOrder(orderID, twoPhase);
      assertNotNull(result);
      assertEquals("closed", result.getOrderStatus());
    } catch (Exception e) {
      fail("Exception should not be thrown for a valid sell order");
    }
  }

  @Test
  @Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
  public void testCompleteOrderWithValidOrderID_enNw0() {
    TradeDirect tradeDirect = new TradeDirect();
    Integer orderID = 1; // Assuming 1 is a valid order ID for testing
    boolean twoPhase = false;
    try {
      OrderDataBean result = tradeDirect.completeOrder(orderID, twoPhase);
      assertNotNull(result);
      assertEquals("closed", result.getOrderStatus());
    } catch (Exception e) {
      fail("Exception should not be thrown for valid order ID");
    }
  }

  @Test
  @Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
  public void testCompleteOrderWithValidOrderIDAndTwoPhaseTrue_cWSj0() {
    TradeDirect tradeDirect = new TradeDirect();
    Integer validOrderID = 123; // Assuming 123 is a valid order ID for testing
    boolean twoPhase = true;
    try {
      OrderDataBean result = tradeDirect.completeOrder(validOrderID, twoPhase);
      assertNotNull(result);
    } catch (Exception e) {
      fail("Exception should not be thrown for valid inputs");
    }
  }

  @Test
  @Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
  public void testCompleteOrderWithInvalidOrderIDAndTwoPhaseFalse_SgQG1() {
    TradeDirect tradeDirect = new TradeDirect();
    Integer invalidOrderID = -1; // Assuming -1 is an invalid order ID for testing
    boolean twoPhase = false;
    try {
      OrderDataBean result = tradeDirect.completeOrder(invalidOrderID, twoPhase);
      assertNull(result);
    } catch (Exception e) {
      fail("Exception should not be thrown even for invalid order ID");
    }
  }

  @Test
  @Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
  public void testCompleteOrderWithNullOrderID_Zmyk2() {
    TradeDirect tradeDirect = new TradeDirect();
    Integer nullOrderID = null;
    boolean twoPhase = true;
    try {
      OrderDataBean result = tradeDirect.completeOrder(nullOrderID, twoPhase);
      assertNull(result);
    } catch (Exception e) {
      fail("Handling of null Order ID should not throw an exception");
    }
  }

  @Test
  @Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
  public void testGetOrdersWithValidUser_vQXq0() throws Exception {
    TradeDirect tradeDirect = new TradeDirect();
    String userID = "validUser123";
    Collection<OrderDataBean> result = tradeDirect.getOrders(userID);
  }

  @Test
  @Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
  public void testGetOrdersWithInvalidUser_ZpeR1() throws Exception {
    TradeDirect tradeDirect = new TradeDirect();
    String userID = "invalidUser123";
    Collection<OrderDataBean> result = tradeDirect.getOrders(userID);
  }

  @Test
  @Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
  public void testGetOrdersWithNullUser_buER2() throws Exception {
    TradeDirect tradeDirect = new TradeDirect();
    String userID = null;
    try {
      Collection<OrderDataBean> result = tradeDirect.getOrders(userID);
      fail("Expected an exception to be thrown when userID is null");
    } catch (Exception e) {
      assertEquals("Expected exception message when userID is null", "User ID cannot be null", e.getMessage());
    }
  }

  @Test
  @Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
  public void testGetQuote_4() throws Exception {
    when(dataSource.getConnection()).thenReturn(connection);
    when(connection.prepareStatement(any(String.class))).thenReturn(preparedStatement);
    when(preparedStatement.executeQuery()).thenReturn(resultSet);
    String symbol = "AAPL";
    when(resultSet.next()).thenReturn(true);
    when(resultSet.getString("symbol")).thenReturn(symbol);
    when(resultSet.getBigDecimal("price")).thenReturn(new BigDecimal("150.00"));
    when(resultSet.getBigDecimal("open")).thenReturn(new BigDecimal("145.00"));
    when(resultSet.getBigDecimal("high")).thenReturn(new BigDecimal("155.00"));
    when(resultSet.getBigDecimal("low")).thenReturn(new BigDecimal("140.00"));
    when(resultSet.getDouble("change")).thenReturn(5.0);
    when(resultSet.getDouble("volume")).thenReturn(100000.0);
    QuoteDataBean expectedQuote = new QuoteDataBean();
    expectedQuote.setSymbol(symbol);
    expectedQuote.setPrice(new BigDecimal("150.00"));
    expectedQuote.setOpen(new BigDecimal("145.00"));
    expectedQuote.setHigh(new BigDecimal("155.00"));
    expectedQuote.setLow(new BigDecimal("140.00"));
    expectedQuote.setChange(5.0);
    expectedQuote.setVolume(100000.0);
    QuoteDataBean actualQuote = tradeDirect.getQuote(symbol);
    assertEquals(expectedQuote.getOpen(), actualQuote.getOpen());
  }

  @Test
  @Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
  public void testGetQuote_7() throws Exception {
    when(dataSource.getConnection()).thenReturn(connection);
    when(connection.prepareStatement(any(String.class))).thenReturn(preparedStatement);
    when(preparedStatement.executeQuery()).thenReturn(resultSet);
    String symbol = "AAPL";
    when(resultSet.next()).thenReturn(true);
    when(resultSet.getString("symbol")).thenReturn(symbol);
    when(resultSet.getBigDecimal("price")).thenReturn(new BigDecimal("150.00"));
    when(resultSet.getBigDecimal("open")).thenReturn(new BigDecimal("145.00"));
    when(resultSet.getBigDecimal("high")).thenReturn(new BigDecimal("155.00"));
    when(resultSet.getBigDecimal("low")).thenReturn(new BigDecimal("140.00"));
    when(resultSet.getDouble("change")).thenReturn(5.0);
    when(resultSet.getDouble("volume")).thenReturn(100000.0);
    QuoteDataBean expectedQuote = new QuoteDataBean();
    expectedQuote.setSymbol(symbol);
    expectedQuote.setPrice(new BigDecimal("150.00"));
    expectedQuote.setOpen(new BigDecimal("145.00"));
    expectedQuote.setHigh(new BigDecimal("155.00"));
    expectedQuote.setLow(new BigDecimal("140.00"));
    expectedQuote.setChange(5.0);
    expectedQuote.setVolume(100000.0);
    QuoteDataBean actualQuote = tradeDirect.getQuote(symbol);
    assertEquals(expectedQuote.getChange(), actualQuote.getChange(), 0.001);
  }

  @Test
  @Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
  public void testGetQuote_JNub0() throws Exception {
    TradeDirect tradeDirect = new TradeDirect();
    String symbol = "AAPL";
    QuoteDataBean result = tradeDirect.getQuote(symbol);
  }

  @Test
  @Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
  public void testCreateQuote_1() throws Exception {
    when(connection.prepareStatement(any(String.class))).thenReturn(preparedStatement);
    // Arrange
    String symbol = "AAPL";
    String companyName = "Apple Inc.";
    BigDecimal price = new BigDecimal("150.00");
    QuoteDataBean expectedQuote = new QuoteDataBean(symbol, companyName, 0.0, price, price, price, price, 0.0);
    // Act
    QuoteDataBean resultQuote = tradeDirect.createQuote(symbol, companyName, price);
    // Assert
    verify(connection).prepareStatement(any(String.class));
    verify(preparedStatement).setString(1, symbol);
    verify(preparedStatement).setString(2, companyName);
    verify(preparedStatement).setDouble(3, 0.0);
    verify(preparedStatement).setBigDecimal(4, price);
    verify(preparedStatement).setBigDecimal(5, price);
    verify(preparedStatement).setBigDecimal(6, price);
    verify(preparedStatement).setBigDecimal(7, price);
    verify(preparedStatement).setDouble(8, 0.0);
    verify(preparedStatement).executeUpdate();
    verify(preparedStatement).close();
    verify(connection, atLeastOnce()).close();
    assertNotNull(resultQuote);
  }

  @Test
  @Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
  public void testCreateQuote_2() throws Exception {
    when(connection.prepareStatement(any(String.class))).thenReturn(preparedStatement);
    // Arrange
    String symbol = "AAPL";
    String companyName = "Apple Inc.";
    BigDecimal price = new BigDecimal("150.00");
    QuoteDataBean expectedQuote = new QuoteDataBean(symbol, companyName, 0.0, price, price, price, price, 0.0);
    // Act
    QuoteDataBean resultQuote = tradeDirect.createQuote(symbol, companyName, price);
    // Assert
    verify(connection).prepareStatement(any(String.class));
    verify(preparedStatement).setString(1, symbol);
    verify(preparedStatement).setString(2, companyName);
    verify(preparedStatement).setDouble(3, 0.0);
    verify(preparedStatement).setBigDecimal(4, price);
    verify(preparedStatement).setBigDecimal(5, price);
    verify(preparedStatement).setBigDecimal(6, price);
    verify(preparedStatement).setBigDecimal(7, price);
    verify(preparedStatement).setDouble(8, 0.0);
    verify(preparedStatement).executeUpdate();
    verify(preparedStatement).close();
    verify(connection, atLeastOnce()).close();
    assertEquals(expectedQuote.getSymbol(), resultQuote.getSymbol());
  }

  @Test
  @Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
  public void testCreateQuote_3() throws Exception {
    when(connection.prepareStatement(any(String.class))).thenReturn(preparedStatement);
    // Arrange
    String symbol = "AAPL";
    String companyName = "Apple Inc.";
    BigDecimal price = new BigDecimal("150.00");
    QuoteDataBean expectedQuote = new QuoteDataBean(symbol, companyName, 0.0, price, price, price, price, 0.0);
    // Act
    QuoteDataBean resultQuote = tradeDirect.createQuote(symbol, companyName, price);
    // Assert
    verify(connection).prepareStatement(any(String.class));
    verify(preparedStatement).setString(1, symbol);
    verify(preparedStatement).setString(2, companyName);
    verify(preparedStatement).setDouble(3, 0.0);
    verify(preparedStatement).setBigDecimal(4, price);
    verify(preparedStatement).setBigDecimal(5, price);
    verify(preparedStatement).setBigDecimal(6, price);
    verify(preparedStatement).setBigDecimal(7, price);
    verify(preparedStatement).setDouble(8, 0.0);
    verify(preparedStatement).executeUpdate();
    verify(preparedStatement).close();
    verify(connection, atLeastOnce()).close();
    assertEquals(expectedQuote.getCompanyName(), resultQuote.getCompanyName());
  }

  @Test
  @Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
  public void testCreateQuote_4() throws Exception {
    when(connection.prepareStatement(any(String.class))).thenReturn(preparedStatement);
    // Arrange
    String symbol = "AAPL";
    String companyName = "Apple Inc.";
    BigDecimal price = new BigDecimal("150.00");
    QuoteDataBean expectedQuote = new QuoteDataBean(symbol, companyName, 0.0, price, price, price, price, 0.0);
    // Act
    QuoteDataBean resultQuote = tradeDirect.createQuote(symbol, companyName, price);
    // Assert
    verify(connection).prepareStatement(any(String.class));
    verify(preparedStatement).setString(1, symbol);
    verify(preparedStatement).setString(2, companyName);
    verify(preparedStatement).setDouble(3, 0.0);
    verify(preparedStatement).setBigDecimal(4, price);
    verify(preparedStatement).setBigDecimal(5, price);
    verify(preparedStatement).setBigDecimal(6, price);
    verify(preparedStatement).setBigDecimal(7, price);
    verify(preparedStatement).setDouble(8, 0.0);
    verify(preparedStatement).executeUpdate();
    verify(preparedStatement).close();
    verify(connection, atLeastOnce()).close();
    assertEquals(0, expectedQuote.getVolume());
  }

  @Test
  @Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
  public void testCreateQuote_5() throws Exception {
    when(connection.prepareStatement(any(String.class))).thenReturn(preparedStatement);
    // Arrange
    String symbol = "AAPL";
    String companyName = "Apple Inc.";
    BigDecimal price = new BigDecimal("150.00");
    QuoteDataBean expectedQuote = new QuoteDataBean(symbol, companyName, 0.0, price, price, price, price, 0.0);
    // Act
    QuoteDataBean resultQuote = tradeDirect.createQuote(symbol, companyName, price);
    // Assert
    verify(connection).prepareStatement(any(String.class));
    verify(preparedStatement).setString(1, symbol);
    verify(preparedStatement).setString(2, companyName);
    verify(preparedStatement).setDouble(3, 0.0);
    verify(preparedStatement).setBigDecimal(4, price);
    verify(preparedStatement).setBigDecimal(5, price);
    verify(preparedStatement).setBigDecimal(6, price);
    verify(preparedStatement).setBigDecimal(7, price);
    verify(preparedStatement).setDouble(8, 0.0);
    verify(preparedStatement).executeUpdate();
    verify(preparedStatement).close();
    verify(connection, atLeastOnce()).close();
    assertEquals(0.0, resultQuote.getChange());
  }

  @Test
  @Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
  public void testCreateQuote_6() throws Exception {
    when(connection.prepareStatement(any(String.class))).thenReturn(preparedStatement);
    // Arrange
    String symbol = "AAPL";
    String companyName = "Apple Inc.";
    BigDecimal price = new BigDecimal("150.00");
    QuoteDataBean expectedQuote = new QuoteDataBean(symbol, companyName, 0.0, price, price, price, price, 0.0);
    // Act
    QuoteDataBean resultQuote = tradeDirect.createQuote(symbol, companyName, price);
    // Assert
    verify(connection).prepareStatement(any(String.class));
    verify(preparedStatement).setString(1, symbol);
    verify(preparedStatement).setString(2, companyName);
    verify(preparedStatement).setDouble(3, 0.0);
    verify(preparedStatement).setBigDecimal(4, price);
    verify(preparedStatement).setBigDecimal(5, price);
    verify(preparedStatement).setBigDecimal(6, price);
    verify(preparedStatement).setBigDecimal(7, price);
    verify(preparedStatement).setDouble(8, 0.0);
    verify(preparedStatement).executeUpdate();
    verify(preparedStatement).close();
    verify(connection, atLeastOnce()).close();
    assertEquals(price, resultQuote.getPrice());
  }

  @Test
  @Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
  public void testCreateQuote_7() throws Exception {
    when(connection.prepareStatement(any(String.class))).thenReturn(preparedStatement);
    // Arrange
    String symbol = "AAPL";
    String companyName = "Apple Inc.";
    BigDecimal price = new BigDecimal("150.00");
    QuoteDataBean expectedQuote = new QuoteDataBean(symbol, companyName, 0.0, price, price, price, price, 0.0);
    // Act
    QuoteDataBean resultQuote = tradeDirect.createQuote(symbol, companyName, price);
    // Assert
    verify(connection).prepareStatement(any(String.class));
    verify(preparedStatement).setString(1, symbol);
    verify(preparedStatement).setString(2, companyName);
    verify(preparedStatement).setDouble(3, 0.0);
    verify(preparedStatement).setBigDecimal(4, price);
    verify(preparedStatement).setBigDecimal(5, price);
    verify(preparedStatement).setBigDecimal(6, price);
    verify(preparedStatement).setBigDecimal(7, price);
    verify(preparedStatement).setDouble(8, 0.0);
    verify(preparedStatement).executeUpdate();
    verify(preparedStatement).close();
    verify(connection, atLeastOnce()).close();
    assertEquals(price, resultQuote.getOpen());
  }

  @Test
  @Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
  public void testCreateQuote_8() throws Exception {
    when(connection.prepareStatement(any(String.class))).thenReturn(preparedStatement);
    // Arrange
    String symbol = "AAPL";
    String companyName = "Apple Inc.";
    BigDecimal price = new BigDecimal("150.00");
    QuoteDataBean expectedQuote = new QuoteDataBean(symbol, companyName, 0.0, price, price, price, price, 0.0);
    // Act
    QuoteDataBean resultQuote = tradeDirect.createQuote(symbol, companyName, price);
    // Assert
    verify(connection).prepareStatement(any(String.class));
    verify(preparedStatement).setString(1, symbol);
    verify(preparedStatement).setString(2, companyName);
    verify(preparedStatement).setDouble(3, 0.0);
    verify(preparedStatement).setBigDecimal(4, price);
    verify(preparedStatement).setBigDecimal(5, price);
    verify(preparedStatement).setBigDecimal(6, price);
    verify(preparedStatement).setBigDecimal(7, price);
    verify(preparedStatement).setDouble(8, 0.0);
    verify(preparedStatement).executeUpdate();
    verify(preparedStatement).close();
    verify(connection, atLeastOnce()).close();
    assertEquals(price, resultQuote.getHigh());
  }

  @Test
  @Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
  public void testCreateQuote_9() throws Exception {
    when(connection.prepareStatement(any(String.class))).thenReturn(preparedStatement);
    // Arrange
    String symbol = "AAPL";
    String companyName = "Apple Inc.";
    BigDecimal price = new BigDecimal("150.00");
    QuoteDataBean expectedQuote = new QuoteDataBean(symbol, companyName, 0.0, price, price, price, price, 0.0);
    // Act
    QuoteDataBean resultQuote = tradeDirect.createQuote(symbol, companyName, price);
    // Assert
    verify(connection).prepareStatement(any(String.class));
    verify(preparedStatement).setString(1, symbol);
    verify(preparedStatement).setString(2, companyName);
    verify(preparedStatement).setDouble(3, 0.0);
    verify(preparedStatement).setBigDecimal(4, price);
    verify(preparedStatement).setBigDecimal(5, price);
    verify(preparedStatement).setBigDecimal(6, price);
    verify(preparedStatement).setBigDecimal(7, price);
    verify(preparedStatement).setDouble(8, 0.0);
    verify(preparedStatement).executeUpdate();
    verify(preparedStatement).close();
    verify(connection, atLeastOnce()).close();
    assertEquals(price, resultQuote.getLow());
  }

  @Test
  @Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
  public void testQueueOrderWithValidOrder_etic0() {
    TradeDirect tradeDirect = new TradeDirect();
    try {
      tradeDirect.queueOrder(123, true);
      assertTrue(true); // Assuming no exception is good execution
    } catch (Exception e) {
      fail("Exception should not be thrown");
    }
  }

  @Test
  @Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
  public void testQueueOrderWithTwoPhaseFalse_veSe2() {
    TradeDirect tradeDirect = new TradeDirect();
    try {
      tradeDirect.queueOrder(456, false);
      assertTrue(true); // Assuming no exception is good execution
    } catch (Exception e) {
      fail("Exception should not be thrown");
    }
  }

  @Test
  @Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
  public void testSellWithInvalidUserID_MKrH7() throws Exception {
    TradeDirect tradeDirect = new TradeDirect();
    Connection conn = null; // Mock or stub this
    String userID = "";
    Integer holdingID = 5;
    int orderProcessingMode = TradeConfig.SYNCH;
    OrderDataBean result = tradeDirect.sell(userID, holdingID, orderProcessingMode);
    assertEquals("cancelled", result.getOrderStatus());
  }

  @Test
  @Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
  public void testSellWithInvalidHoldingID_aLGR8() throws Exception {
    TradeDirect tradeDirect = new TradeDirect();
    Connection conn = null; // Mock or stub this
    String userID = "user6";
    Integer holdingID = null;
    int orderProcessingMode = TradeConfig.SYNCH;
    OrderDataBean result = tradeDirect.sell(userID, holdingID, orderProcessingMode);
    assertEquals("cancelled", result.getOrderStatus());
  }

  @Test
  @Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
  public void testSellWithGlobalTransactionRollback_EgRB9() throws Exception {
    TradeDirect tradeDirect = new TradeDirect();
    Connection conn = null; // Mock or stub this
    String userID = "user7";
    Integer holdingID = 7;
    int orderProcessingMode = TradeConfig.ASYNCH_2PHASE;
    OrderDataBean result = tradeDirect.sell(userID, holdingID, orderProcessingMode);
    assertEquals("cancelled", result.getOrderStatus());
  }

  @Test
  @Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
  public void testSellWithCommit_rgTX10() throws Exception {
    TradeDirect tradeDirect = new TradeDirect();
    Connection conn = null; // Mock or stub this
    String userID = "user8";
    Integer holdingID = 8;
    int orderProcessingMode = TradeConfig.SYNCH;
    OrderDataBean result = tradeDirect.sell(userID, holdingID, orderProcessingMode);
    assertNotNull(result);
    assertNotEquals("cancelled", result.getOrderStatus());
  }

  @Test
  @Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
  public void testSellWithExceptionInQueueOrder_NQiz11() throws Exception {
    TradeDirect tradeDirect = new TradeDirect();
    Connection conn = null; // Mock or stub this
    String userID = "user9";
    Integer holdingID = 9;
    int orderProcessingMode = TradeConfig.ASYNCH_2PHASE;
    OrderDataBean result = tradeDirect.sell(userID, holdingID, orderProcessingMode);
    assertEquals("cancelled", result.getOrderStatus());
  }

  @Test
  @Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
  public void testSellWithExceptionInCompleteOrderAsync_CpVp12() throws Exception {
    TradeDirect tradeDirect = new TradeDirect();
    Connection conn = null; // Mock or stub this
    String userID = "user10";
    Integer holdingID = 10;
    int orderProcessingMode = TradeConfig.ASYNCH;
    OrderDataBean result = tradeDirect.sell(userID, holdingID, orderProcessingMode);
    assertEquals("cancelled", result.getOrderStatus());
  }

  @Test
  @Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
  public void testSellWithNullAccountData_iGfR0() throws Exception {
    TradeDirect tradeDirect = new TradeDirect();
    Connection conn = mock(Connection.class);
    when(conn.prepareStatement(anyString())).thenReturn(mock(PreparedStatement.class));
    ResultSet rs = mock(ResultSet.class);
    when(rs.next()).thenReturn(false); // Simulate no account data found
    try {
      OrderDataBean result = tradeDirect.sell("user123", 1, TradeConfig.SYNCH);
      assertNotNull(result);
      assertEquals("cancelled", result.getOrderStatus());
    } catch (Exception e) {
      fail("Exception should not be thrown");
    }
  }

  @Test
  @Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
  public void testSellWithNullHoldingData_cqgS1() throws Exception {
    TradeDirect tradeDirect = new TradeDirect();
    Connection conn = mock(Connection.class);
    PreparedStatement stmt = mock(PreparedStatement.class);
    when(conn.prepareStatement(anyString())).thenReturn(stmt);
    ResultSet rs = mock(ResultSet.class);
    when(rs.next()).thenReturn(true).thenReturn(false); // Simulate account data found but no holding data
    when(rs.getInt("accountID")).thenReturn(1);
    try {
      OrderDataBean result = tradeDirect.sell("user123", 1, TradeConfig.SYNCH);
      assertNotNull(result);
      assertEquals("cancelled", result.getOrderStatus());
    } catch (Exception e) {
      fail("Exception should not be thrown");
    }
  }

  @Test
  @Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
  public void testSellWithNullQuoteData_kRti2() throws Exception {
    TradeDirect tradeDirect = new TradeDirect();
    Connection conn = mock(Connection.class);
    PreparedStatement stmt = mock(PreparedStatement.class);
    when(conn.prepareStatement(anyString())).thenReturn(stmt);
    ResultSet rs = mock(ResultSet.class);
    when(rs.next()).thenReturn(true).thenReturn(true).thenReturn(false); // Simulate account and holding data found but no quote data
    when(rs.getInt("accountID")).thenReturn(1);
    when(rs.getInt("holdingID")).thenReturn(1);
    try {
      OrderDataBean result = tradeDirect.sell("user123", 1, TradeConfig.SYNCH);
      assertNotNull(result);
      assertEquals("cancelled", result.getOrderStatus());
    } catch (Exception e) {
      fail("Exception should not be thrown");
    }
  }

  @Test
  @Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
  public void testSellSuccessfulTransaction_nFCg3() throws Exception {
    TradeDirect tradeDirect = new TradeDirect();
    Connection conn = mock(Connection.class);
    PreparedStatement stmt = mock(PreparedStatement.class);
    when(conn.prepareStatement(anyString())).thenReturn(stmt);
    ResultSet rs = mock(ResultSet.class);
    when(rs.next()).thenReturn(true).thenReturn(true).thenReturn(true);
    when(rs.getInt("accountID")).thenReturn(1);
    when(rs.getInt("holdingID")).thenReturn(1);
    when(rs.getString("quoteID")).thenReturn("Q1");
    when(rs.getDouble("quantity")).thenReturn(100.0);
    when(rs.getBigDecimal("price")).thenReturn(new BigDecimal("10.0"));
    when(rs.getBigDecimal("orderFee")).thenReturn(new BigDecimal("15.0"));
    try {
      OrderDataBean result = tradeDirect.sell("user123", 1, TradeConfig.SYNCH);
      assertNotNull(result);
      assertEquals("open", result.getOrderStatus());
    } catch (Exception e) {
      fail("Exception should not be thrown");
    }
  }

  @Test
  @Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
  public void testSellWithAsynchMode_IJJr5() throws Exception {
    TradeDirect tradeDirect = new TradeDirect();
    Connection conn = mock(Connection.class);
    PreparedStatement stmt = mock(PreparedStatement.class);
    when(conn.prepareStatement(anyString())).thenReturn(stmt);
    ResultSet rs = mock(ResultSet.class);
    when(rs.next()).thenReturn(true).thenReturn(true).thenReturn(true);
    when(rs.getInt("accountID")).thenReturn(1);
    when(rs.getInt("holdingID")).thenReturn(1);
    when(rs.getString("quoteID")).thenReturn("Q1");
    when(rs.getDouble("quantity")).thenReturn(100.0);
    when(rs.getBigDecimal("price")).thenReturn(new BigDecimal("10.0"));
    when(rs.getBigDecimal("orderFee")).thenReturn(new BigDecimal("15.0"));
    try {
      OrderDataBean result = tradeDirect.sell("user123", 1, TradeConfig.ASYNCH);
      assertNotNull(result);
      assertEquals("open", result.getOrderStatus());
    } catch (Exception e) {
      fail("Exception should not be thrown");
    }
  }

  @Test
  @Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
  public void testSellWithAsynch2PhaseMode_THby6() throws Exception {
    TradeDirect tradeDirect = new TradeDirect();
    Connection conn = mock(Connection.class);
    PreparedStatement stmt = mock(PreparedStatement.class);
    when(conn.prepareStatement(anyString())).thenReturn(stmt);
    ResultSet rs = mock(ResultSet.class);
    when(rs.next()).thenReturn(true).thenReturn(true).thenReturn(true);
    when(rs.getInt("accountID")).thenReturn(1);
    when(rs.getInt("holdingID")).thenReturn(1);
    when(rs.getString("quoteID")).thenReturn("Q1");
    when(rs.getDouble("quantity")).thenReturn(100.0);
    when(rs.getBigDecimal("price")).thenReturn(new BigDecimal("10.0"));
    when(rs.getBigDecimal("orderFee")).thenReturn(new BigDecimal("15.0"));
    try {
      OrderDataBean result = tradeDirect.sell("user123", 1, TradeConfig.ASYNCH_2PHASE);
      assertNotNull(result);
      assertEquals("open", result.getOrderStatus());
    } catch (Exception e) {
      fail("Exception should not be thrown");
    }
  }

  @Test
  @Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
  public void testSellWithJMSException_TCgo9() throws Exception {
    TradeDirect tradeDirect = new TradeDirect();
    Connection conn = mock(Connection.class);
    PreparedStatement stmt = mock(PreparedStatement.class);
    when(conn.prepareStatement(anyString())).thenReturn(stmt);
    ResultSet rs = mock(ResultSet.class);
    when(rs.next()).thenReturn(true).thenReturn(true).thenReturn(true);
    when(rs.getInt("accountID")).thenReturn(1);
    when(rs.getInt("holdingID")).thenReturn(1);
    when(rs.getString("quoteID")).thenReturn("Q1");
    when(rs.getDouble("quantity")).thenReturn(100.0);
    when(rs.getBigDecimal("price")).thenReturn(new BigDecimal("10.0"));
    when(rs.getBigDecimal("orderFee")).thenReturn(new BigDecimal("15.0"));
    doThrow(new JMSException("Simulated JMS exception")).when(tradeDirect).queueOrder(anyInt(), anyBoolean());
    try {
      OrderDataBean result = tradeDirect.sell("user123", 1, TradeConfig.ASYNCH_2PHASE);
      fail("JMSException should have been thrown");
    } catch (JMSException je) {
      assertNotNull(je);
    } catch (Exception e) {
      fail("Unexpected exception type thrown");
    }
  }

  @Test
  @Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
  public void testSellWithSQLExceptionDuringOrderCreation_SELb10() throws Exception {
    TradeDirect tradeDirect = new TradeDirect();
    Connection conn = mock(Connection.class);
    PreparedStatement stmt = mock(PreparedStatement.class);
    when(conn.prepareStatement(anyString())).thenReturn(stmt);
    ResultSet rs = mock(ResultSet.class);
    when(rs.next()).thenReturn(true).thenReturn(true).thenReturn(true);
    when(rs.getInt("accountID")).thenReturn(1);
    when(rs.getInt("holdingID")).thenReturn(1);
    when(rs.getString("quoteID")).thenReturn("Q1");
    when(rs.getDouble("quantity")).thenReturn(100.0);
    when(rs.getBigDecimal("price")).thenReturn(new BigDecimal("10.0"));
    when(rs.getBigDecimal("orderFee")).thenReturn(new BigDecimal("15.0"));
    doThrow(new SQLException("Simulated SQL exception")).when(stmt).executeUpdate();
    try {
      OrderDataBean result = tradeDirect.sell("user123", 1, TradeConfig.SYNCH);
      fail("SQLException should have been thrown");
    } catch (SQLException se) {
      assertNotNull(se);
    } catch (Exception e) {
      fail("Unexpected exception type thrown");
    }
  }

  @Test
  @Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
  public void testCompleteOrderAsyncWithSessionInactive_ooMT0() throws Exception {
    TradeDirect tradeDirect = new TradeDirect();
    Integer orderID = 1;
    boolean twoPhase = true;
    Future<OrderDataBean> result = tradeDirect.completeOrderAsync(orderID, twoPhase);
    assertNull(result);
  }

  @Test
  @Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
  public void testUpdateQuotePriceVolumeInt_NormalConditions_POgZ0() {
    TradeDirect tradeDirect = new TradeDirect();
    BigDecimal changeFactor = new BigDecimal("1.05");
    double sharesTraded = 1500.0;
    boolean publishQuotePriceChange = true;
    try {
      QuoteDataBean result = tradeDirect.updateQuotePriceVolumeInt("AAPL", changeFactor, sharesTraded, publishQuotePriceChange);
      assertNotNull(result);
      assertTrue(result.getPrice().compareTo(new BigDecimal("0")) > 0);
    } catch (Exception e) {
      fail("Exception should not be thrown under normal conditions");
    }
  }

  @Test
  @Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
  public void testUpdateQuotePriceVolumeInt_PennyStock_OgTc1() {
    TradeDirect tradeDirect = new TradeDirect();
    BigDecimal changeFactor = new BigDecimal("1.00"); // This should be overridden
    double sharesTraded = 2000.0;
    boolean publishQuotePriceChange = false;
    try {
      QuoteDataBean result = tradeDirect.updateQuotePriceVolumeInt("XYZ", changeFactor, sharesTraded, publishQuotePriceChange);
      assertNotNull(result);
      assertEquals(TradeConfig.PENNY_STOCK_RECOVERY_MIRACLE_MULTIPLIER, result.getPrice().divide(result.getOpen()).setScale(2, BigDecimal.ROUND_HALF_UP));
    } catch (Exception e) {
      fail("Exception should not be thrown for penny stocks");
    }
  }

  @Test
  @Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
  public void testUpdateQuotePriceVolumeInt_MaximumStockPrice_jXDb2() {
    TradeDirect tradeDirect = new TradeDirect();
    BigDecimal changeFactor = new BigDecimal("2.00"); // This should be overridden
    double sharesTraded = 3000.0;
    boolean publishQuotePriceChange = true;
    try {
      QuoteDataBean result = tradeDirect.updateQuotePriceVolumeInt("HIGH", changeFactor, sharesTraded, publishQuotePriceChange);
      assertNotNull(result);
      assertEquals(TradeConfig.MAXIMUM_STOCK_SPLIT_MULTIPLIER, result.getPrice().divide(result.getOpen()).setScale(2, BigDecimal.ROUND_HALF_UP));
    } catch (Exception e) {
      fail("Exception should not be thrown for maximum stock price condition");
    }
  }

  @Test
  @Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
  public void testUpdateQuotePriceVolumeInt_NoPriceUpdateConfig_ypde3() {
    TradeConfig.setUpdateQuotePrices(false);
    TradeDirect tradeDirect = new TradeDirect();
    BigDecimal changeFactor = new BigDecimal("1.10");
    double sharesTraded = 1000.0;
    boolean publishQuotePriceChange = true;
    try {
      QuoteDataBean result = tradeDirect.updateQuotePriceVolumeInt("AAPL", changeFactor, sharesTraded, publishQuotePriceChange);
      assertNotNull(result);
      assertEquals(BigDecimal.ZERO, result.getPrice());
    } catch (Exception e) {
      fail("Exception should not be thrown even if price update is disabled");
    } finally {
      TradeConfig.setUpdateQuotePrices(true); // Reset for other tests
    }
  }

  @Test
  @Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
  public void testUpdateQuotePriceVolumeInt_WithPublish_Gbdn0() throws Exception {
    TradeDirect tradeDirect = new TradeDirect();
    String symbol = "AAPL";
    BigDecimal changeFactor = new BigDecimal("1.05");
    double sharesTraded = 1000;
    boolean publishQuotePriceChange = true;
    QuoteDataBean result = tradeDirect.updateQuotePriceVolumeInt(symbol, changeFactor, sharesTraded, publishQuotePriceChange);
    assertNotNull(result);
    assertEquals(new BigDecimal("1.05"), changeFactor);
    assertTrue(result.getVolume() >= 1000);
  }

  @Test
  @Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
  public void testUpdateQuotePriceVolumeInt_WithoutPublish_zYZC1() throws Exception {
    TradeDirect tradeDirect = new TradeDirect();
    String symbol = "GOOGL";
    BigDecimal changeFactor = new BigDecimal("0.95");
    double sharesTraded = 500;
    boolean publishQuotePriceChange = false;
    QuoteDataBean result = tradeDirect.updateQuotePriceVolumeInt(symbol, changeFactor, sharesTraded, publishQuotePriceChange);
    assertNotNull(result);
    assertEquals(new BigDecimal("0.95"), changeFactor);
    assertTrue(result.getVolume() >= 500);
  }

  @Test
  @Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
  public void testUpdateQuotePriceVolumeInt_PennyStock_vRJm2() throws Exception {
    TradeDirect tradeDirect = new TradeDirect();
    String symbol = "XYZ";
    BigDecimal changeFactor = TradeConfig.PENNY_STOCK_RECOVERY_MIRACLE_MULTIPLIER;
    double sharesTraded = 200;
    boolean publishQuotePriceChange = true;
    QuoteDataBean result = tradeDirect.updateQuotePriceVolumeInt(symbol, changeFactor, sharesTraded, publishQuotePriceChange);
    assertNotNull(result);
    assertEquals(TradeConfig.PENNY_STOCK_RECOVERY_MIRACLE_MULTIPLIER, changeFactor);
    assertTrue(result.getVolume() >= 200);
  }

  @Test
  @Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
  public void testUpdateQuotePriceVolumeInt_MaximumStockPrice_UBfr3() throws Exception {
    TradeDirect tradeDirect = new TradeDirect();
    String symbol = "HIGH";
    BigDecimal changeFactor = TradeConfig.MAXIMUM_STOCK_SPLIT_MULTIPLIER;
    double sharesTraded = 300;
    boolean publishQuotePriceChange = true;
    QuoteDataBean result = tradeDirect.updateQuotePriceVolumeInt(symbol, changeFactor, sharesTraded, publishQuotePriceChange);
    assertNotNull(result);
    assertEquals(TradeConfig.MAXIMUM_STOCK_SPLIT_MULTIPLIER, changeFactor);
    assertTrue(result.getVolume() >= 300);
  }

  @Test
  @Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
  public void testUpdateQuotePriceVolumeInt_NoPriceUpdateConfig_TjPj4() throws Exception {
    TradeDirect tradeDirect = new TradeDirect();
    String symbol = "MSFT";
    BigDecimal changeFactor = new BigDecimal("1.00");
    double sharesTraded = 150;
    boolean publishQuotePriceChange = true;
    TradeConfig.setUpdateQuotePrices(false);
    QuoteDataBean result = tradeDirect.updateQuotePriceVolumeInt(symbol, changeFactor, sharesTraded, publishQuotePriceChange);
    assertNotNull(result);
    assertEquals(BigDecimal.ZERO, result.getPrice());
    assertEquals(0, result.getVolume(), 0.0);
  }

  @Test
  @Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
  public void testUpdateQuotePriceVolumeInt_NormalConditions_wDwi0() {
    TradeDirect tradeDirect = new TradeDirect();
    String symbol = "AAPL";
    BigDecimal changeFactor = new BigDecimal("1.05");
    double sharesTraded = 1000;
    boolean publishQuotePriceChange = true;
    try {
      QuoteDataBean result = tradeDirect.updateQuotePriceVolumeInt(symbol, changeFactor, sharesTraded, publishQuotePriceChange);
      assertNotNull(result);
      assertTrue(result.getPrice().compareTo(new BigDecimal("0")) > 0);
    } catch (Exception e) {
      fail("Exception should not be thrown under normal conditions");
    }
  }

  @Test
  @Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
  public void testUpdateQuotePriceVolumeInt_PennyStock_EiWJ1() {
    TradeDirect tradeDirect = new TradeDirect();
    String symbol = "PENNY";
    BigDecimal changeFactor = new BigDecimal("1.00"); // This should get overridden
    double sharesTraded = 500;
    boolean publishQuotePriceChange = false;
    try {
      QuoteDataBean result = tradeDirect.updateQuotePriceVolumeInt(symbol, changeFactor, sharesTraded, publishQuotePriceChange);
      assertNotNull(result);
      assertEquals(TradeConfig.PENNY_STOCK_RECOVERY_MIRACLE_MULTIPLIER, result.getPrice().divide(result.getOpen()).setScale(2, BigDecimal.ROUND_HALF_UP));
    } catch (Exception e) {
      fail("Exception should not be thrown for penny stocks");
    }
  }

  @Test
  @Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
  public void testUpdateQuotePriceVolumeInt_MaximumPriceExceeded_LTWI2() {
    TradeDirect tradeDirect = new TradeDirect();
    String symbol = "MAXP";
    BigDecimal changeFactor = new BigDecimal("2.00"); // This should get overridden
    double sharesTraded = 2000;
    boolean publishQuotePriceChange = true;
    try {
      QuoteDataBean result = tradeDirect.updateQuotePriceVolumeInt(symbol, changeFactor, sharesTraded, publishQuotePriceChange);
      assertNotNull(result);
      assertEquals(TradeConfig.MAXIMUM_STOCK_SPLIT_MULTIPLIER, result.getPrice().divide(result.getOpen()).setScale(2, BigDecimal.ROUND_HALF_UP));
    } catch (Exception e) {
      fail("Exception should not be thrown when maximum price is exceeded");
    }
  }

  @Test
  @Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
  public void testUpdateQuotePriceVolumeInt_NoPriceUpdateConfig_xEpS3() {
    TradeConfig.setUpdateQuotePrices(false);
    TradeDirect tradeDirect = new TradeDirect();
    String symbol = "NOUPD";
    BigDecimal changeFactor = new BigDecimal("1.10");
    double sharesTraded = 300;
    boolean publishQuotePriceChange = true;
    try {
      QuoteDataBean result = tradeDirect.updateQuotePriceVolumeInt(symbol, changeFactor, sharesTraded, publishQuotePriceChange);
      assertNotNull(result);
      assertEquals(BigDecimal.ZERO, result.getPrice());
    } catch (Exception e) {
      fail("Exception should not be thrown even if price update is disabled");
    } finally {
      TradeConfig.setUpdateQuotePrices(true); // Reset for other tests
    }
  }

  @Test
  @Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
  public void testRegister() throws Exception {
    when(connection.prepareStatement(any(String.class))).thenReturn(preparedStatement);
    when(dataSource.getConnection()).thenReturn(connection);
    // Arrange
    String userID = "user123";
    String password = "pass123";
    String fullname = "John Doe";
    String address = "1234 Street";
    String email = "john@example.com";
    String creditcard = "1234567890123456";
    BigDecimal openBalance = new BigDecimal("1000.00");
    Integer accountID = 1;
    Timestamp creationDate = new Timestamp(System.currentTimeMillis());
    BigDecimal balance = openBalance;
    Timestamp lastLogin = creationDate;
    int loginCount = 0;
    int logoutCount = 0;
    when(preparedStatement.executeUpdate()).thenReturn(1);
    when(KeySequenceDirect.getNextID(connection, "account", false, false)).thenReturn(accountID);
    // Act
    AccountDataBean result = tradeDirect.register(userID, password, fullname, address, email, creditcard, openBalance);
    // Assert
    assertNotNull(result);
    assertEquals(accountID, result.getAccountID());
    assertEquals(loginCount, result.getLoginCount());
    assertEquals(logoutCount, result.getLogoutCount());
    assertEquals(lastLogin, result.getLastLogin());
    assertEquals(creationDate, result.getCreationDate());
    assertEquals(balance, result.getBalance());
    assertEquals(openBalance, result.getOpenBalance());
    assertEquals(userID, result.getProfileID());
    verify(preparedStatement, times(2)).executeUpdate(); // Verify that executeUpdate was called twice
    verify(preparedStatement, times(1)).setInt(1, accountID.intValue());
    verify(preparedStatement, times(1)).setTimestamp(2, creationDate);
    verify(preparedStatement, times(1)).setBigDecimal(3, openBalance);
    verify(preparedStatement, times(1)).setBigDecimal(4, balance);
    verify(preparedStatement, times(1)).setTimestamp(5, lastLogin);
    verify(preparedStatement, times(1)).setInt(6, loginCount);
    verify(preparedStatement, times(1)).setInt(7, logoutCount);
    verify(preparedStatement, times(1)).setString(8, userID);
  }

  @Test
  @Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
  public void testRegisterNewUser_Zyba0() throws Exception {
    TradeDirect tradeDirect = new TradeDirect();
    String userID = "testUser";
    String password = "testPass";
    String fullname = "Test User";
    String address = "123 Test St";
    String email = "test@example.com";
    String creditcard = "1234567890123456";
    BigDecimal openBalance = new BigDecimal("1000.00");
    AccountDataBean result = tradeDirect.register(userID, password, fullname, address, email, creditcard, openBalance);
    assertNotNull(result);
    assertEquals(userID, result.getProfileID());
    assertEquals(openBalance, result.getOpenBalance());
    assertEquals(openBalance, result.getBalance());
    assertEquals(0, result.getLoginCount());
    assertEquals(0, result.getLogoutCount());
  }

  @Test
  @Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
  public void testGetHoldings() throws Exception {
    when(dataSource.getConnection()).thenReturn(connection);
    when(connection.prepareStatement(any(String.class))).thenReturn(preparedStatement);
    when(preparedStatement.executeQuery()).thenReturn(resultSet);
    // Setup the ResultSet to simulate the database response
    when(resultSet.next()).thenReturn(true, true, false); // Simulate two data rows and then end of data
    when(resultSet.getString("holdingID")).thenReturn("H100", "H101");
    when(resultSet.getDouble("quantity")).thenReturn(150.0, 200.0);
    when(resultSet.getDouble("purchasePrice")).thenReturn(50.0, 75.0);
    when(resultSet.getString("purchaseDate")).thenReturn("2021-01-01", "2021-02-01");
    // Call the method under test
    Collection<HoldingDataBean> holdings = tradeDirect.getHoldings("user123");
    // Verify the interactions with the mock objects
    verify(connection).prepareStatement(any(String.class));
    verify(preparedStatement).setString(1, "user123");
    verify(preparedStatement).executeQuery();
    verify(resultSet, times(2)).next(); // Ensure resultSet.next() was called twice
    // Assertions to check the correct behavior
    assertNotNull(holdings);
    assertEquals(2, holdings.size()); // Expecting two holdings returned
    // Check details of the first holding
    HoldingDataBean firstHolding = holdings.iterator().next();
    assertEquals("H100", firstHolding.getHoldingID());
    assertEquals(150.0, firstHolding.getQuantity());
    assertEquals(50.0, firstHolding.getPurchasePrice());
    assertEquals("2021-01-01", firstHolding.getPurchaseDate());
  }

  @Test
  @Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
  public void testGetHoldingsWithValidUser_nfpR0() throws Exception {
    TradeDirect tradeDirect = new TradeDirect();
    String userID = "validUser123";
    Collection<HoldingDataBean> result = tradeDirect.getHoldings(userID);
  }

  @Test
  @Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
  public void testGetHoldingsWithInvalidUser_BVvm1() throws Exception {
    TradeDirect tradeDirect = new TradeDirect();
    String userID = "invalidUser456";
    Collection<HoldingDataBean> result = tradeDirect.getHoldings(userID);
  }

  @Test
  @Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
  public void testLoginIncorrectPassword() throws Exception {
    when(dataSource.getConnection()).thenReturn(connection);
    when(connection.prepareStatement(any(String.class))).thenReturn(preparedStatement);
    when(preparedStatement.executeQuery()).thenReturn(resultSet);
    // Arrange
    String userID = "user123";
    String wrongPassword = "wrongPass";
    String correctPassword = "correctPass";
    when(resultSet.next()).thenReturn(true);
    when(resultSet.getString("passwd")).thenReturn(correctPassword);
    // Act & Assert
    Exception exception = assertThrows(Exception.class, () -> {
      tradeDirect.login(userID, wrongPassword);
    });
    // Assert
    assertTrue(exception.getMessage().contains("Incorrect password"));
    verify(preparedStatement, times(1)).setString(1, userID);
    verify(preparedStatement, never()).setTimestamp(anyInt(), any(Timestamp.class));
    verify(preparedStatement, never()).setString(2, userID);
    verify(preparedStatement, never()).executeUpdate();
  }

  @Test
  @Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
  public void testLoginSuccess_dCJP0() throws Exception {
    TradeDirect tradeDirect = new TradeDirect();
    String userID = "validUser";
    String password = "correctPassword";
    AccountDataBean expectedAccountDataBean = AccountDataBean.getRandomInstance();
    AccountDataBean result = tradeDirect.login(userID, password);
    assertNotNull(result);
    assertEquals(expectedAccountDataBean.getAccountID(), result.getAccountID());
  }

  @Test
  @Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
  public void testLoginFailureIncorrectPassword_jkKb1() {
    TradeDirect tradeDirect = new TradeDirect();
    String userID = "validUser";
    String password = "wrongPassword";
    try {
      tradeDirect.login(userID, password);
      fail("Expected an Exception to be thrown");
    } catch (Exception e) {
      assertEquals("TradeDirect:Login failure for user: validUser\n\tIncorrect password-->validUser:wrongPassword", e.getMessage());
    }
  }

  @Test
  @Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
  public void testLoginFailureUserNotFound_HqHa2() {
    TradeDirect tradeDirect = new TradeDirect();
    String userID = "nonExistentUser";
    String password = "anyPassword";
    try {
      tradeDirect.login(userID, password);
      fail("Expected a FinderException to be thrown");
    } catch (javax.ejb.FinderException e) {
      assertEquals("Cannot find account fornonExistentUser", e.getMessage());
    } catch (Exception e) {
      fail("Unexpected exception type");
    }
  }

  @Test
  @Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
  public void testLoginSQLExceptionHandling_MeKB3() {
    TradeDirect tradeDirect = new TradeDirect();
    String userID = "userCausingSQLIssue";
    String password = "password";
    try {
      tradeDirect.login(userID, password);
      fail("Expected an Exception due to SQL issues");
    } catch (Exception e) {
      assertTrue(e.getMessage().contains("error logging in user"));
    }
  }

  @Test
  @Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
  public void testGetConnPublic() throws Exception {
    MockitoAnnotations.initMocks(this);
    when(tradeDirect.getConnPublic()).thenReturn(connection);
    Connection result = tradeDirect.getConnPublic();
    assertNotNull(result, "The connection should not be null");
    assertEquals(connection, result, "The returned connection is not as expected");
  }

  @Test
  @Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
  public void testGetConnPublic_UiUY0() throws Exception {
    TradeDirect tradeDirect = new TradeDirect();
    Connection result = tradeDirect.getConnPublic();
    assertNotNull(result);
  }

  @Test
  @Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
  public void testUpdateQuotePriceVolume() throws Exception {
    when(dataSource.getConnection()).thenReturn(connection);
    when(connection.prepareStatement(any(String.class))).thenReturn(preparedStatement);
    when(preparedStatement.executeQuery()).thenReturn(resultSet);
    // Arrange
    String symbol = "AAPL";
    BigDecimal changeFactor = new BigDecimal("1.05");
    double sharesTraded = 1000.0;
    QuoteDataBean expectedQuote = new QuoteDataBean();
    when(resultSet.next()).thenReturn(true);
    when(resultSet.getString("symbol")).thenReturn(symbol);
    when(resultSet.getBigDecimal("price")).thenReturn(new BigDecimal("150"));
    when(resultSet.getDouble("volume")).thenReturn(5000.0);
    // Act
    QuoteDataBean resultQuote = tradeDirect.updateQuotePriceVolume(symbol, changeFactor, sharesTraded);
    // Assert
    assertNotNull(resultQuote);
    assertEquals(symbol, resultQuote.getSymbol());
    assertEquals(new BigDecimal("150").multiply(changeFactor), resultQuote.getPrice());
    assertEquals(5000.0 + sharesTraded, resultQuote.getVolume());
  }

  @Test
  @Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
  public void testUpdateQuotePriceVolume_oLMe0() throws Exception {
    TradeDirect tradeDirect = new TradeDirect();
    String symbol = "AAPL";
    BigDecimal changeFactor = new BigDecimal("1.05");
    double sharesTraded = 1500.0;
    QuoteDataBean result = tradeDirect.updateQuotePriceVolume(symbol, changeFactor, sharesTraded);
    assertNotNull(result);
    assertEquals(symbol, result.getSymbol());
    assertTrue(result.getPrice().compareTo(result.getOpen().multiply(changeFactor)) == 0);
  }

  @Test
  @Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
  public void testUpdateAccountProfile() throws Exception {
    when(dataSource.getConnection()).thenReturn(connection);
    when(connection.prepareStatement(any(String.class))).thenReturn(preparedStatement);
    when(preparedStatement.executeQuery()).thenReturn(resultSet);
    // Given
    AccountProfileDataBean profileData = new AccountProfileDataBean("user123", "password", "John Doe", "123 Elm St", "john@example.com", "1234-5678-9012-3456");
    when(resultSet.next()).thenReturn(true); // Simulate found data
    when(resultSet.getString("userID")).thenReturn(profileData.getUserID());
    when(resultSet.getString("password")).thenReturn(profileData.getPassword());
    when(resultSet.getString("fullName")).thenReturn(profileData.getFullName());
    when(resultSet.getString("address")).thenReturn(profileData.getAddress());
    when(resultSet.getString("email")).thenReturn(profileData.getEmail());
    when(resultSet.getString("creditCard")).thenReturn(profileData.getCreditCard());
    // When
    AccountProfileDataBean updatedProfile = tradeDirect.updateAccountProfile(profileData);
    // Then
    assertNotNull(updatedProfile);
    assertEquals(profileData.getUserID(), updatedProfile.getUserID());
    assertEquals(profileData.getPassword(), updatedProfile.getPassword());
    assertEquals(profileData.getFullName(), updatedProfile.getFullName());
    assertEquals(profileData.getAddress(), updatedProfile.getAddress());
    assertEquals(profileData.getEmail(), updatedProfile.getEmail());
    assertEquals(profileData.getCreditCard(), updatedProfile.getCreditCard());
    verify(connection).prepareStatement(any(String.class));
    verify(preparedStatement).executeQuery();
    verify(resultSet, atLeastOnce()).getString(anyString());
  }

  @Test
  @Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
  public void testUpdateAccountProfile_YINv0() throws Exception {
    TradeDirect tradeDirect = new TradeDirect();
    AccountProfileDataBean profileData = new AccountProfileDataBean("user123", "password123", "John Doe", "1234 Elm St", "john.doe@example.com", "1234-5678-9012-3456");
    AccountProfileDataBean updatedProfile = tradeDirect.updateAccountProfile(profileData);
    assertNotNull(updatedProfile);
    assertEquals("user123", updatedProfile.getUserID());
    assertEquals("password123", updatedProfile.getPassword());
    assertEquals("John Doe", updatedProfile.getFullName());
    assertEquals("1234 Elm St", updatedProfile.getAddress());
    assertEquals("john.doe@example.com", updatedProfile.getEmail());
    assertEquals("1234-5678-9012-3456", updatedProfile.getCreditCard());
  }

  @Test
  @Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
  public void testGetAccountData_ValidUserID_ReturnsAccountData_ZSiI0() throws Exception {
    TradeDirect tradeDirect = new TradeDirect();
    String userID = "validUserID"; // Assuming 'validUserID' is a valid user ID for the test
    AccountDataBean result = tradeDirect.getAccountData(userID);
    assertNotNull(result);
    assertEquals(userID, result.getProfileID());
  }

  @Test
  @Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
  public void testGetAccountProfileData() throws Exception {
    when(connection.prepareStatement(any(String.class))).thenReturn(preparedStatement);
    when(preparedStatement.executeQuery()).thenReturn(resultSet);
    // Arrange
    String userID = "user123";
    AccountProfileDataBean expectedProfile = new AccountProfileDataBean();
    when(resultSet.next()).thenReturn(true);
    when(resultSet.getString("profile_userid")).thenReturn(expectedProfile.getUserID());
    when(resultSet.getString("email")).thenReturn(expectedProfile.getEmail());
    when(resultSet.getString("address")).thenReturn(expectedProfile.getAddress());
    when(resultSet.getString("full_name")).thenReturn(expectedProfile.getFullName());
    when(resultSet.getString("password")).thenReturn(expectedProfile.getPassword());
    when(resultSet.getString("credit_card")).thenReturn(expectedProfile.getCreditCard());
    // Act
    AccountProfileDataBean actualProfile = tradeDirect.getAccountProfileData(userID);
    // Assert
    assertNotNull(actualProfile);
    assertEquals(expectedProfile.getUserID(), actualProfile.getUserID());
    assertEquals(expectedProfile.getEmail(), actualProfile.getEmail());
    assertEquals(expectedProfile.getAddress(), actualProfile.getAddress());
    assertEquals(expectedProfile.getFullName(), actualProfile.getFullName());
    assertEquals(expectedProfile.getPassword(), actualProfile.getPassword());
    assertEquals(expectedProfile.getCreditCard(), actualProfile.getCreditCard());
    verify(connection).prepareStatement(any(String.class));
    verify(preparedStatement).executeQuery();
    verify(resultSet, times(1)).next();
  }

  @Test
  @Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
  public void testGetAccountProfileData_ValidUserID_ReturnsProfileData_ecOO0() throws Exception {
    TradeDirect tradeDirect = new TradeDirect();
    String userID = "validUserID123";
    AccountProfileDataBean expectedProfileData = AccountProfileDataBean.getRandomInstance();
    AccountProfileDataBean actualProfileData = tradeDirect.getAccountProfileData(userID);
    assertNotNull(actualProfileData);
    assertEquals(expectedProfileData.getUserID(), actualProfileData.getUserID());
  }

  @Test
  @Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
  public void testBuyWithValidData_zmfm0() throws Exception {
    TradeDirect trade = new TradeDirect();
    String userID = "user123";
    String symbol = "AAPL";
    double quantity = 100;
    int orderProcessingMode = TradeConfig.SYNCH;
    OrderDataBean result = trade.buy(userID, symbol, quantity, orderProcessingMode);
    assertNotNull(result);
    assertEquals("buy", result.getOrderType());
  }

  @Test
  @Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
  public void testBuyWithZeroQuantity_xKHZ3() throws Exception {
    TradeDirect trade = new TradeDirect();
    String userID = "user123";
    String symbol = "AAPL";
    double quantity = 0;
    int orderProcessingMode = TradeConfig.SYNCH;
    OrderDataBean result = trade.buy(userID, symbol, quantity, orderProcessingMode);
    assertEquals(0, result.getQuantity(), 0.0);
  }

  @Test
  @Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
  public void testBuyAsynchronousMode_NWEe5() throws Exception {
    TradeDirect trade = new TradeDirect();
    String userID = "user123";
    String symbol = "AAPL";
    double quantity = 50;
    int orderProcessingMode = TradeConfig.ASYNCH;
    OrderDataBean result = trade.buy(userID, symbol, quantity, orderProcessingMode);
    assertNotNull(result);
    assertTrue(result.getOrderStatus().equalsIgnoreCase("open") || result.getOrderStatus().equalsIgnoreCase("completed"));
  }

  @Test
  @Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
  public void testBuyAsynchronous2PhaseMode_gVsG6() throws Exception {
    TradeDirect trade = new TradeDirect();
    String userID = "user123";
    String symbol = "AAPL";
    double quantity = 50;
    int orderProcessingMode = TradeConfig.ASYNCH_2PHASE;
    OrderDataBean result = trade.buy(userID, symbol, quantity, orderProcessingMode);
    assertNotNull(result);
    assertTrue(result.getOrderStatus().equalsIgnoreCase("open"));
  }

  @Test
  @Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
  public void testBuyWithHighQuantity_zIYr7() throws Exception {
    TradeDirect trade = new TradeDirect();
    String userID = "user123";
    String symbol = "AAPL";
    double quantity = 10000;
    int orderProcessingMode = TradeConfig.SYNCH;
    OrderDataBean result = trade.buy(userID, symbol, quantity, orderProcessingMode);
    assertNotNull(result);
    assertEquals(10000, result.getQuantity(), 0.0);
  }

  @Test
  @Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
  public void testBuyWithMinimalOrderFee_YJMO8() throws Exception {
    TradeDirect trade = new TradeDirect();
    String userID = "user123";
    String symbol = "AAPL";
    double quantity = 1;
    int orderProcessingMode = TradeConfig.SYNCH;
    OrderDataBean result = trade.buy(userID, symbol, quantity, orderProcessingMode);
    assertNotNull(result);
    assertTrue(result.getOrderFee().compareTo(new BigDecimal("0")) > 0);
  }

  @Test
  @Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
  public void testBuyCheckOrderCompletionDate_jOOK9() throws Exception {
    TradeDirect trade = new TradeDirect();
    String userID = "user123";
    String symbol = "AAPL";
    double quantity = 100;
    int orderProcessingMode = TradeConfig.SYNCH;
    OrderDataBean result = trade.buy(userID, symbol, quantity, orderProcessingMode);
    assertNotNull(result);
    assertNotNull(result.getCompletionDate());
  }

  @Test
  @Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
  public void testGetClosedOrdersWithValidUser_pzke0() throws Exception {
    TradeDirect tradeDirect = new TradeDirect();
    String userID = "validUser123";
    Collection<OrderDataBean> result = tradeDirect.getClosedOrders(userID);
    assertNotNull(result);
    assertFalse(result.isEmpty());
    for (OrderDataBean order : result) {
      assertEquals("completed", order.getOrderStatus());
    }
  }

  @Test
  @Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
  public void testGetClosedOrdersWithNoOrders_JMFp1() throws Exception {
    TradeDirect tradeDirect = new TradeDirect();
    String userID = "userWithNoOrders";
    Collection<OrderDataBean> result = tradeDirect.getClosedOrders(userID);
    assertNotNull(result);
    assertTrue(result.isEmpty());
  }

  @Test
  @Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
  public void testGetMarketSummaryInternal() throws Exception {
    when(dataSource.getConnection()).thenReturn(connection);
    when(connection.prepareStatement(any(String.class), anyInt(), anyInt())).thenReturn(preparedStatement);
    when(connection.prepareStatement(any(String.class))).thenReturn(preparedStatement);
    when(preparedStatement.executeQuery()).thenReturn(resultSet);
    // Setup result set to simulate database behavior
    when(resultSet.next()).thenReturn(true, true, true, true, true, true, false); // 5 results for losers, 1 for TSIA, and end
    when(resultSet.getBigDecimal("TSIA")).thenReturn(new BigDecimal("1000"));
    when(resultSet.getBigDecimal("openTSIA")).thenReturn(new BigDecimal("950"));
    when(resultSet.getDouble("totalVolume")).thenReturn(5000.0);
    // Simulate QuoteDataBean creation from ResultSet
    when(resultSet.getString("symbol")).thenReturn("AAPL", "GOOG", "MSFT", "AMZN", "FB");
    when(resultSet.getBigDecimal("price")).thenReturn(new BigDecimal("300"), new BigDecimal("1200"), new BigDecimal("200"), new BigDecimal("3200"), new BigDecimal("150"));
    when(resultSet.getDouble("change1")).thenReturn(10.0, -20.0, 15.0, -5.0, 25.0);
    when(resultSet.getDouble("open1")).thenReturn(290.0, 1220.0, 195.0, 3210.0, 140.0);
    when(resultSet.getDouble("volume")).thenReturn(100.0, 200.0, 150.0, 300.0, 250.0);
    // Execute the method to test
    MarketSummaryDataBean result = tradeDirect.getMarketSummaryInternal();
    // Verify the results
    assertNotNull(result);
    assertEquals(new BigDecimal("1000"), result.getTSIA());
    assertEquals(new BigDecimal("950"), result.getOpenTSIA());
    assertEquals(5000.0, result.getVolume());
    assertEquals(5, result.getTopLosers().size());
    assertEquals(5, result.getTopGainers().size());
    // Verify interactions
    verify(connection, times(4)).prepareStatement(anyString(), anyInt(), anyInt()); // For different SQL queries
    verify(preparedStatement, times(4)).executeQuery(); // Each SQL query executed once
    verify(resultSet, times(6)).next(); // Iterate over result set
  }

  @Test
  @Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
  public void testGetMarketSummaryInternal_NormalFlow_oTeH0() throws Exception {
    TradeDirect tradeDirect = new TradeDirect();
    MarketSummaryDataBean result = tradeDirect.getMarketSummaryInternal();
    assertNotNull(result);
    assertTrue(result.getTopGainers().size() > 0);
    assertTrue(result.getTopLosers().size() > 0);
    assertNotNull(result.getTSIA());
    assertNotNull(result.getOpenTSIA());
    assertTrue(result.getVolume() > 0);
  }

  @Test
  @Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
  public void testGetMarketSummaryInternal_NoTopGainers_QqGB1() throws Exception {
    TradeDirect tradeDirect = new TradeDirect();
    MarketSummaryDataBean result = tradeDirect.getMarketSummaryInternal();
    assertNotNull(result);
    assertTrue(result.getTopGainers().isEmpty());
    assertFalse(result.getTopLosers().isEmpty());
  }

  @Test
  @Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
  public void testGetMarketSummaryInternal_NoTopLosers_FsKS2() throws Exception {
    TradeDirect tradeDirect = new TradeDirect();
    MarketSummaryDataBean result = tradeDirect.getMarketSummaryInternal();
    assertNotNull(result);
    assertFalse(result.getTopGainers().isEmpty());
    assertTrue(result.getTopLosers().isEmpty());
  }

  @Test
  @Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
  public void testGetMarketSummaryInternal_EmptyResultSet_jCDu3() throws Exception {
    TradeDirect tradeDirect = new TradeDirect();
    MarketSummaryDataBean result = tradeDirect.getMarketSummaryInternal();
    assertNotNull(result);
    assertTrue(result.getTopGainers().isEmpty());
    assertTrue(result.getTopLosers().isEmpty());
    assertEquals(BigDecimal.ZERO, result.getTSIA());
    assertEquals(BigDecimal.ZERO, result.getOpenTSIA());
    assertEquals(0.0, result.getVolume(), 0.0);
  }

  @Test
  @Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
  public void testGetMarketSummaryInternal_SQLException_mYHR4() throws Exception {
    TradeDirect tradeDirect = new TradeDirect();
    try {
      tradeDirect.getMarketSummaryInternal();
      fail("Expected an SQLException to be thrown");
    } catch (SQLException e) {
      assertNotNull(e.getMessage());
    }
  }

  @Test
  @Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
  public void testGetMarketSummaryInternal_InvalidSQL_sMSI6() throws Exception {
    TradeDirect tradeDirect = new TradeDirect();
    try {
      tradeDirect.getMarketSummaryInternal();
      fail("Expected an SQL syntax error");
    } catch (SQLException e) {
      assertTrue(e.getMessage().contains("syntax error"));
    }
  }

  @Test
  @Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
  public void testGetMarketSummaryInternal_ResultSetClosedException_UdDe7() throws Exception {
    TradeDirect tradeDirect = new TradeDirect();
    try {
      tradeDirect.getMarketSummaryInternal();
      fail("Expected a ResultSet closed exception");
    } catch (SQLException e) {
      assertTrue(e.getMessage().contains("ResultSet closed"));
    }
  }

  @Test
  @Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
  public void testGetMarketSummaryInternal_StatementClosedException_Qtwq8() throws Exception {
    TradeDirect tradeDirect = new TradeDirect();
    try {
      tradeDirect.getMarketSummaryInternal();
      fail("Expected a Statement closed exception");
    } catch (SQLException e) {
      assertTrue(e.getMessage().contains("Statement closed"));
    }
  }

  @Test
  @Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
  public void testGetMarketSummaryInternal_CommitFailure_aHYs9() throws Exception {
    TradeDirect tradeDirect = new TradeDirect();
    try {
      tradeDirect.getMarketSummaryInternal();
      fail("Expected a commit failure");
    } catch (Exception e) {
      assertTrue(e instanceof SQLException || e instanceof RuntimeException);
      assertTrue(e.getMessage().contains("commit failure"));
    }
  }
}