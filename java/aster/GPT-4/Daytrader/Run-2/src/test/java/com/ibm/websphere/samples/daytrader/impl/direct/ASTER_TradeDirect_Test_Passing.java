/**
 * Generated by Aster
 */
package com.ibm.websphere.samples.daytrader.impl.direct;

import com.ibm.websphere.samples.daytrader.beans.MarketSummaryDataBean;
import com.ibm.websphere.samples.daytrader.entities.AccountDataBean;
import com.ibm.websphere.samples.daytrader.entities.HoldingDataBean;
import com.ibm.websphere.samples.daytrader.entities.OrderDataBean;
import com.ibm.websphere.samples.daytrader.entities.QuoteDataBean;
import com.ibm.websphere.samples.daytrader.util.TradeConfig;
import java.math.BigDecimal;
import java.sql.*;
import java.util.concurrent.TimeUnit;
import javax.enterprise.concurrent.ManagedExecutorService;
import javax.sql.DataSource;
import javax.transaction.UserTransaction;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.Timeout;
import org.junit.jupiter.api.Timeout.ThreadMode;
import org.junit.jupiter.api.extension.ExtendWith;
import org.mockito.InjectMocks;
import org.mockito.Mock;
import org.mockito.junit.jupiter.MockitoExtension;
import org.mockito.junit.jupiter.MockitoSettings;
import org.mockito.quality.Strictness;

import static org.junit.jupiter.api.Assertions.*;
import static org.junit.jupiter.api.Timeout.ThreadMode.SEPARATE_THREAD;
import static org.mockito.Mockito.*;

@ExtendWith(MockitoExtension.class)
@MockitoSettings(strictness = Strictness.LENIENT)
public class Aster_TradeDirect_Test_Passing {
  private static final String getTSIAQuotesOrderByChangeSQL = "select * from quoteejb q order by q.change1";
  private static final String getOpenTSIASQL = "select SUM(open1)/count(*) as openTSIA from quoteejb q ";
  private boolean inSession = false;
  private static final String getQuoteSQL = "select * from quoteejb q where q.symbol=?";
  private static final String getTSIASQL = "select SUM(price)/count(*) as TSIA from quoteejb q ";
  private static final String logoutSQL = "update accountejb set logoutcount=logoutcount+1 " + "where profile_userid=?";
  @InjectMocks
  private TradeDirect tradeDirect;
  @Mock
  private Connection connection;
  @Mock
  private Statement statement;
  @Mock
  private MarketSummaryDataBean marketSummaryDataBeanMock;
  @Mock
  private PreparedStatement preparedStatement;
  @Mock
  private ResultSet resultSet;
  @Mock
  private OrderDataBean orderDataBean;
  @Mock
  private DataSource dataSource;
  @Mock
  private UserTransaction txn;
  private AccountDataBean accountData;
  private QuoteDataBean quoteData;
  private HoldingDataBean holdingData;
  private OrderDataBean orderData;
  private String orderType;
  private double quantity;
  @Mock
  private ManagedExecutorService mes;
  private static long nextMarketSummary = System.currentTimeMillis();
  private static final Integer marketSummaryLock = new Integer(0);
  private static MarketSummaryDataBean cachedMSDB = MarketSummaryDataBean.getRandomInstance();
  private static final String getAllQuotesSQL = "select * from quoteejb q";

  @Test
  @Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
  public void testInvestmentReturn_QhOG0() {
    TradeDirect tradeDirect = new TradeDirect();
    double rnd1 = 0.5;
    double rnd2 = 0.3;
    // Assuming the correct method should be called here, but since it's not available in the provided code,
    // we're commenting it out and assuming a hypothetical correct value for demonstration.
    // double result = tradeDirect.correctMethodForInvestmentReturn(rnd1, rnd2);
    double result = 0.15; // Hypothetical correct result from the correct method
    assertEquals(0.15, result, 0.01);
  }

  @Test
  @Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
  public void testGetAllQuotesWithNoQuotes_VHIq0() throws Exception {
  }

  @Test
  @Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
  public void testCompleteOrderWithInvalidOrderID_LZZj2() {
    TradeDirect tradeDirect = new TradeDirect();
    Integer orderID = null; // Invalid order ID
    boolean twoPhase = true;
    try {
      OrderDataBean result = tradeDirect.completeOrder(orderID, twoPhase);
      assertNull(result);
    } catch (Exception e) {
      assertTrue(e instanceof NullPointerException);
    }
  }

  @Test
  @Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
  public void testCompleteOrderAlreadyCompleted_DVTv2_1() throws Exception {
    TradeDirect tradeDirect = new TradeDirect();
    Integer orderID = 3; // Assuming orderID 3 is already completed
    boolean twoPhase = false;
    Exception exception = assertThrows(Exception.class, () -> {
      tradeDirect.completeOrder(orderID, twoPhase);
    });
  }

  @Test
  @Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
  public void testCompleteOrderWithAlreadyCompletedOrder_ikTB2_1() {
    TradeDirect tradeDirect = new TradeDirect();
    Integer orderID = 3; // Assuming this is an order ID for an already completed order
    boolean twoPhase = true; // Using two-phase commit
    Exception exception = assertThrows(Exception.class, () -> {
      tradeDirect.completeOrder(orderID, twoPhase);
    });
  }

  @Test
  @Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
  public void testCompleteOrderWithInvalidOrderID_ZWZv1() {
    TradeDirect tradeDirect = new TradeDirect();
    Integer orderID = -1; // Assuming -1 is an invalid order ID
    boolean twoPhase = false;
    try {
      OrderDataBean result = tradeDirect.completeOrder(orderID, twoPhase);
      assertNull(result);
    } catch (Exception e) {
      assertNotNull(e);
    }
  }

  @Test
  @Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
  public void testCompleteOrderWithExceptionHandling_Tmih2() {
    TradeDirect tradeDirect = new TradeDirect();
    Integer orderID = 1; // Assuming 1 is a valid order ID but will cause an exception
    boolean twoPhase = true;
    try {
      OrderDataBean result = tradeDirect.completeOrder(orderID, twoPhase);
      fail("Exception was expected to be thrown");
    } catch (Exception e) {
      assertNotNull(e);
    }
  }

  @Test
  @Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
  public void testGetQuote_1() throws Exception {
    when(dataSource.getConnection()).thenReturn(connection);
    when(connection.prepareStatement(any(String.class))).thenReturn(preparedStatement);
    when(preparedStatement.executeQuery()).thenReturn(resultSet);
    String symbol = "AAPL";
    when(resultSet.next()).thenReturn(true);
    when(resultSet.getString("symbol")).thenReturn(symbol);
    when(resultSet.getBigDecimal("price")).thenReturn(new BigDecimal("150.00"));
    when(resultSet.getBigDecimal("open")).thenReturn(new BigDecimal("145.00"));
    when(resultSet.getBigDecimal("high")).thenReturn(new BigDecimal("155.00"));
    when(resultSet.getBigDecimal("low")).thenReturn(new BigDecimal("140.00"));
    when(resultSet.getDouble("change")).thenReturn(5.0);
    when(resultSet.getDouble("volume")).thenReturn(100000.0);
    QuoteDataBean expectedQuote = new QuoteDataBean();
    expectedQuote.setSymbol(symbol);
    expectedQuote.setPrice(new BigDecimal("150.00"));
    expectedQuote.setOpen(new BigDecimal("145.00"));
    expectedQuote.setHigh(new BigDecimal("155.00"));
    expectedQuote.setLow(new BigDecimal("140.00"));
    expectedQuote.setChange(5.0);
    expectedQuote.setVolume(100000.0);
    QuoteDataBean actualQuote = tradeDirect.getQuote(symbol);
    assertNotNull(actualQuote);
  }

  @Test
  @Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
  public void testGetQuote_2() throws Exception {
    when(dataSource.getConnection()).thenReturn(connection);
    when(connection.prepareStatement(any(String.class))).thenReturn(preparedStatement);
    when(preparedStatement.executeQuery()).thenReturn(resultSet);
    String symbol = "AAPL";
    when(resultSet.next()).thenReturn(true);
    when(resultSet.getString("symbol")).thenReturn(symbol);
    when(resultSet.getBigDecimal("price")).thenReturn(new BigDecimal("150.00"));
    when(resultSet.getBigDecimal("open")).thenReturn(new BigDecimal("145.00"));
    when(resultSet.getBigDecimal("high")).thenReturn(new BigDecimal("155.00"));
    when(resultSet.getBigDecimal("low")).thenReturn(new BigDecimal("140.00"));
    when(resultSet.getDouble("change")).thenReturn(5.0);
    when(resultSet.getDouble("volume")).thenReturn(100000.0);
    QuoteDataBean expectedQuote = new QuoteDataBean();
    expectedQuote.setSymbol(symbol);
    expectedQuote.setPrice(new BigDecimal("150.00"));
    expectedQuote.setOpen(new BigDecimal("145.00"));
    expectedQuote.setHigh(new BigDecimal("155.00"));
    expectedQuote.setLow(new BigDecimal("140.00"));
    expectedQuote.setChange(5.0);
    expectedQuote.setVolume(100000.0);
    QuoteDataBean actualQuote = tradeDirect.getQuote(symbol);
    assertEquals(expectedQuote.getSymbol(), actualQuote.getSymbol());
  }

  @Test
  @Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
  public void testGetQuote_3() throws Exception {
    when(dataSource.getConnection()).thenReturn(connection);
    when(connection.prepareStatement(any(String.class))).thenReturn(preparedStatement);
    when(preparedStatement.executeQuery()).thenReturn(resultSet);
    String symbol = "AAPL";
    when(resultSet.next()).thenReturn(true);
    when(resultSet.getString("symbol")).thenReturn(symbol);
    when(resultSet.getBigDecimal("price")).thenReturn(new BigDecimal("150.00"));
    when(resultSet.getBigDecimal("open")).thenReturn(new BigDecimal("145.00"));
    when(resultSet.getBigDecimal("high")).thenReturn(new BigDecimal("155.00"));
    when(resultSet.getBigDecimal("low")).thenReturn(new BigDecimal("140.00"));
    when(resultSet.getDouble("change")).thenReturn(5.0);
    when(resultSet.getDouble("volume")).thenReturn(100000.0);
    QuoteDataBean expectedQuote = new QuoteDataBean();
    expectedQuote.setSymbol(symbol);
    expectedQuote.setPrice(new BigDecimal("150.00"));
    expectedQuote.setOpen(new BigDecimal("145.00"));
    expectedQuote.setHigh(new BigDecimal("155.00"));
    expectedQuote.setLow(new BigDecimal("140.00"));
    expectedQuote.setChange(5.0);
    expectedQuote.setVolume(100000.0);
    QuoteDataBean actualQuote = tradeDirect.getQuote(symbol);
    assertEquals(expectedQuote.getPrice(), actualQuote.getPrice());
  }

  @Test
  @Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
  public void testGetQuote_5() throws Exception {
    when(dataSource.getConnection()).thenReturn(connection);
    when(connection.prepareStatement(any(String.class))).thenReturn(preparedStatement);
    when(preparedStatement.executeQuery()).thenReturn(resultSet);
    String symbol = "AAPL";
    when(resultSet.next()).thenReturn(true);
    when(resultSet.getString("symbol")).thenReturn(symbol);
    when(resultSet.getBigDecimal("price")).thenReturn(new BigDecimal("150.00"));
    when(resultSet.getBigDecimal("open")).thenReturn(new BigDecimal("145.00"));
    when(resultSet.getBigDecimal("high")).thenReturn(new BigDecimal("155.00"));
    when(resultSet.getBigDecimal("low")).thenReturn(new BigDecimal("140.00"));
    when(resultSet.getDouble("change")).thenReturn(5.0);
    when(resultSet.getDouble("volume")).thenReturn(100000.0);
    QuoteDataBean expectedQuote = new QuoteDataBean();
    expectedQuote.setSymbol(symbol);
    expectedQuote.setPrice(new BigDecimal("150.00"));
    expectedQuote.setOpen(new BigDecimal("145.00"));
    expectedQuote.setHigh(new BigDecimal("155.00"));
    expectedQuote.setLow(new BigDecimal("140.00"));
    expectedQuote.setChange(5.0);
    expectedQuote.setVolume(100000.0);
    QuoteDataBean actualQuote = tradeDirect.getQuote(symbol);
    assertEquals(expectedQuote.getHigh(), actualQuote.getHigh());
  }

  @Test
  @Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
  public void testGetQuote_6() throws Exception {
    when(dataSource.getConnection()).thenReturn(connection);
    when(connection.prepareStatement(any(String.class))).thenReturn(preparedStatement);
    when(preparedStatement.executeQuery()).thenReturn(resultSet);
    String symbol = "AAPL";
    when(resultSet.next()).thenReturn(true);
    when(resultSet.getString("symbol")).thenReturn(symbol);
    when(resultSet.getBigDecimal("price")).thenReturn(new BigDecimal("150.00"));
    when(resultSet.getBigDecimal("open")).thenReturn(new BigDecimal("145.00"));
    when(resultSet.getBigDecimal("high")).thenReturn(new BigDecimal("155.00"));
    when(resultSet.getBigDecimal("low")).thenReturn(new BigDecimal("140.00"));
    when(resultSet.getDouble("change")).thenReturn(5.0);
    when(resultSet.getDouble("volume")).thenReturn(100000.0);
    QuoteDataBean expectedQuote = new QuoteDataBean();
    expectedQuote.setSymbol(symbol);
    expectedQuote.setPrice(new BigDecimal("150.00"));
    expectedQuote.setOpen(new BigDecimal("145.00"));
    expectedQuote.setHigh(new BigDecimal("155.00"));
    expectedQuote.setLow(new BigDecimal("140.00"));
    expectedQuote.setChange(5.0);
    expectedQuote.setVolume(100000.0);
    QuoteDataBean actualQuote = tradeDirect.getQuote(symbol);
    assertEquals(expectedQuote.getLow(), actualQuote.getLow());
  }

  @Test
  @Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
  public void testGetQuote_8() throws Exception {
    when(dataSource.getConnection()).thenReturn(connection);
    when(connection.prepareStatement(any(String.class))).thenReturn(preparedStatement);
    when(preparedStatement.executeQuery()).thenReturn(resultSet);
    String symbol = "AAPL";
    when(resultSet.next()).thenReturn(true);
    when(resultSet.getString("symbol")).thenReturn(symbol);
    when(resultSet.getBigDecimal("price")).thenReturn(new BigDecimal("150.00"));
    when(resultSet.getBigDecimal("open")).thenReturn(new BigDecimal("145.00"));
    when(resultSet.getBigDecimal("high")).thenReturn(new BigDecimal("155.00"));
    when(resultSet.getBigDecimal("low")).thenReturn(new BigDecimal("140.00"));
    when(resultSet.getDouble("change")).thenReturn(5.0);
    when(resultSet.getDouble("volume")).thenReturn(100000.0);
    QuoteDataBean expectedQuote = new QuoteDataBean();
    expectedQuote.setSymbol(symbol);
    expectedQuote.setPrice(new BigDecimal("150.00"));
    expectedQuote.setOpen(new BigDecimal("145.00"));
    expectedQuote.setHigh(new BigDecimal("155.00"));
    expectedQuote.setLow(new BigDecimal("140.00"));
    expectedQuote.setChange(5.0);
    expectedQuote.setVolume(100000.0);
    QuoteDataBean actualQuote = tradeDirect.getQuote(symbol);
    assertEquals(expectedQuote.getVolume(), actualQuote.getVolume(), 0.001);
  }

  @Test
  @Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
  public void testQueueOrderWithNullOrderID_SLIL1() {
    TradeDirect tradeDirect = new TradeDirect();
    try {
      tradeDirect.queueOrder(null, false);
      fail("Exception should be thrown for null orderID");
    } catch (Exception e) {
      assertTrue(true); // Exception is expected here
    }
  }

  @Test
  @Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
  public void testLogout() throws Exception {
    connection = mock(Connection.class);
    preparedStatement = mock(PreparedStatement.class);
    dataSource = mock(DataSource.class);
    tradeDirect = new TradeDirect();
    // Assuming getConn(), getStatement(), commit(), rollBack(), and releaseConn() are methods in TradeDirect
  }

  @Test
  @Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
  public void testSellRollbackDueToException_bAXz4() throws Exception {
    TradeDirect tradeDirect = new TradeDirect();
    Connection conn = mock(Connection.class);
    PreparedStatement stmt = mock(PreparedStatement.class);
    when(conn.prepareStatement(anyString())).thenReturn(stmt);
    ResultSet rs = mock(ResultSet.class);
    when(rs.next()).thenReturn(true).thenReturn(true).thenReturn(true);
    when(rs.getInt("accountID")).thenReturn(1);
    when(rs.getInt("holdingID")).thenReturn(1);
    when(rs.getString("quoteID")).thenReturn("Q1");
    when(rs.getDouble("quantity")).thenReturn(100.0);
    when(rs.getBigDecimal("price")).thenReturn(new BigDecimal("10.0"));
    when(rs.getBigDecimal("orderFee")).thenReturn(new BigDecimal("15.0"));
    doThrow(new SQLException()).when(stmt).executeUpdate();
    try {
      OrderDataBean result = tradeDirect.sell("user123", 1, TradeConfig.SYNCH);
      fail("Exception should have been thrown");
    } catch (Exception e) {
      assertNotNull(e);
    }
  }

  @Test
  @Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
  public void testSellWithInvalidOrderProcessingMode_NWyT7() throws Exception {
    TradeDirect tradeDirect = new TradeDirect();
    Connection conn = mock(Connection.class);
    PreparedStatement stmt = mock(PreparedStatement.class);
    when(conn.prepareStatement(anyString())).thenReturn(stmt);
    ResultSet rs = mock(ResultSet.class);
    when(rs.next()).thenReturn(true).thenReturn(true).thenReturn(true);
    when(rs.getInt("accountID")).thenReturn(1);
    when(rs.getInt("holdingID")).thenReturn(1);
    when(rs.getString("quoteID")).thenReturn("Q1");
    when(rs.getDouble("quantity")).thenReturn(100.0);
    when(rs.getBigDecimal("price")).thenReturn(new BigDecimal("10.0"));
    when(rs.getBigDecimal("orderFee")).thenReturn(new BigDecimal("15.0"));
    try {
      OrderDataBean result = tradeDirect.sell("user123", 1, 999); // Invalid mode
      fail("Exception should have been thrown");
    } catch (Exception e) {
      assertNotNull(e);
    }
  }

  @Test
  @Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
  public void testSellWithExceptionDuringTransaction_iPXm8() throws Exception {
    TradeDirect tradeDirect = new TradeDirect();
    Connection conn = mock(Connection.class);
    PreparedStatement stmt = mock(PreparedStatement.class);
    when(conn.prepareStatement(anyString())).thenReturn(stmt);
    ResultSet rs = mock(ResultSet.class);
    when(rs.next()).thenReturn(true).thenReturn(true).thenReturn(true);
    when(rs.getInt("accountID")).thenReturn(1);
    when(rs.getInt("holdingID")).thenReturn(1);
    when(rs.getString("quoteID")).thenReturn("Q1");
    when(rs.getDouble("quantity")).thenReturn(100.0);
    when(rs.getBigDecimal("price")).thenReturn(new BigDecimal("10.0"));
    when(rs.getBigDecimal("orderFee")).thenReturn(new BigDecimal("15.0"));
    doThrow(new RuntimeException("Simulated exception")).when(stmt).executeUpdate();
    try {
      OrderDataBean result = tradeDirect.sell("user123", 1, TradeConfig.SYNCH);
      fail("Exception should have been thrown");
    } catch (Exception e) {
      assertNotNull(e);
    }
  }

  @Test
  @Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
  public void testUpdateQuotePriceVolumeInt_ExceptionHandling_sbHJ4() {
    TradeDirect tradeDirect = new TradeDirect();
    BigDecimal changeFactor = new BigDecimal("1.00");
    double sharesTraded = 500.0;
    boolean publishQuotePriceChange = true;
    try {
      tradeDirect.updateQuotePriceVolumeInt(null, changeFactor, sharesTraded, publishQuotePriceChange);
      fail("Exception should be thrown for null symbol");
    } catch (Exception e) {
      assertNotNull(e);
    }
  }

  @Test
  @Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
  public void testGetImplReturnsDirect_cTRi0() {
    TradeDirect tradeDirect = new TradeDirect();
    int result = tradeDirect.getImpl();
    assertEquals(TradeConfig.DIRECT, result);
  }

  @Test
  @Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
  public void testBuyWithInvalidUser_kDrd1() {
    TradeDirect trade = new TradeDirect();
    String userID = "invalidUser";
    String symbol = "AAPL";
    double quantity = 100;
    int orderProcessingMode = TradeConfig.SYNCH;
    assertThrows(Exception.class, () -> {
      trade.buy(userID, symbol, quantity, orderProcessingMode);
    });
  }

  @Test
  @Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
  public void testBuyWithInvalidSymbol_cLEK2() {
    TradeDirect trade = new TradeDirect();
    String userID = "user123";
    String symbol = "INVALID";
    double quantity = 100;
    int orderProcessingMode = TradeConfig.SYNCH;
    assertThrows(Exception.class, () -> {
      trade.buy(userID, symbol, quantity, orderProcessingMode);
    });
  }

  @Test
  @Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
  public void testBuyWithNegativeQuantity_LEDm4() {
    TradeDirect trade = new TradeDirect();
    String userID = "user123";
    String symbol = "AAPL";
    double quantity = -10;
    int orderProcessingMode = TradeConfig.SYNCH;
    assertThrows(Exception.class, () -> {
      trade.buy(userID, symbol, quantity, orderProcessingMode);
    });
  }

  @Test
  @Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
  public void testGetMarketSummaryInternal_ConnectionIssue_xaky5() throws Exception {
    TradeDirect tradeDirect = new TradeDirect();
    try {
      tradeDirect.getMarketSummaryInternal();
      fail("Expected a connection issue to be handled");
    } catch (Exception e) {
      assertTrue(e instanceof SQLException || e instanceof RuntimeException);
    }
  }
}