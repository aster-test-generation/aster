/**
 * Generated by Aster
 */
package org.apache.commons.cli;
import java.util.ArrayList;
import java.util.Properties;
import static org.junit.jupiter.api.Assertions.*;
import java.util.ArrayList;
import java.util.Properties;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.Timeout;
import org.junit.jupiter.api.Timeout.ThreadMode;
import java.util.concurrent.TimeUnit;
import static org.mockito.Mockito.*;
import static org.junit.jupiter.api.Timeout.ThreadMode.SEPARATE_THREAD;
public class Aster_DefaultParser_Coverage_Test_Passing {
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testParse_withOptionTokens_kFTe0() throws ParseException {
        Options mockOptions = mock(Options.class);
        when(mockOptions.getRequiredOptions()).thenReturn(new ArrayList<>());
        when(mockOptions.getOptionGroups()).thenReturn(new ArrayList<>());
        when(mockOptions.hasLongOption(anyString())).thenReturn(true);
        when(mockOptions.hasShortOption(anyString())).thenReturn(true);
        String[] arguments = {"--longOption", "-s"};
        Properties properties = new Properties();
        DefaultParser parser = new DefaultParser();
        CommandLine result = parser.parse(mockOptions, arguments, properties, false);
        verify(mockOptions).hasLongOption("longOption");
        verify(mockOptions).hasShortOption("s");
    }
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testParse_CoversIsOption_NZGs0_1() throws ParseException {
        Options options = new Options();
        options.addOption("a", "alpha", false, "Alpha option");
        options.addOption("b", "beta", true, "Beta option with argument");
        String[] arguments = new String[]{"-a", "--beta=value"};
        Properties properties = new Properties();
        DefaultParser parser = new DefaultParser();
        CommandLine result = parser.parse(options, arguments, properties, false);
        assertTrue(result.hasOption("a"));}
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testParse_CoversIsOption_NZGs0_2() throws ParseException {
        Options options = new Options();
        options.addOption("a", "alpha", false, "Alpha option");
        options.addOption("b", "beta", true, "Beta option with argument");
        String[] arguments = new String[]{"-a", "--beta=value"};
        Properties properties = new Properties();
        DefaultParser parser = new DefaultParser();
        CommandLine result = parser.parse(options, arguments, properties, false);
        assertTrue(result.hasOption("beta"));}
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testParse_CoversIsOption_NZGs0_3() throws ParseException {
        Options options = new Options();
        options.addOption("a", "alpha", false, "Alpha option");
        options.addOption("b", "beta", true, "Beta option with argument");
        String[] arguments = new String[]{"-a", "--beta=value"};
        Properties properties = new Properties();
        DefaultParser parser = new DefaultParser();
        CommandLine result = parser.parse(options, arguments, properties, false);
        assertEquals("value", result.getOptionValue("beta"));}
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testOptionValueNotYesTrueOr1_pXhN3() throws ParseException {
        Options options = mock(Options.class);
        Option opt = mock(Option.class);
        when(options.getOption("option")).thenReturn(opt);
        when(opt.hasArg()).thenReturn(false);
        Properties properties = new Properties();
        properties.setProperty("option", "no");
        DefaultParser parser = new DefaultParser();
        parser.parse(options, new String[]{}, properties, false);
        verify(opt, never()).processValue(anyString());
    }
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testContinueOnInvalidBooleanValue_LqbL4() throws ParseException {
        Options options = mock(Options.class);
        Option opt = mock(Option.class);
        when(options.getOption("option")).thenReturn(opt);
        when(opt.hasArg()).thenReturn(false);
        Properties properties = new Properties();
        properties.setProperty("option", "no");
        DefaultParser parser = new DefaultParser();
        CommandLine result = parser.parse(options, new String[]{}, properties, false);
        verify(opt, never()).processValue(anyString());
        verify(result, never()).addOption(opt);
    }
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testOptionWithEqualSignAcceptsArg_IfDl2() throws ParseException {
        Options options = new Options();
        Option opt = new Option("f", "file", true, "file to process");
        options.addOption(opt);
        DefaultParser parser = new DefaultParser();
        String[] arguments = {"--file=value"};
        CommandLine cmd = parser.parse(options, arguments, new Properties(), false);
        assertEquals("value", cmd.getOptionValue("file"));
    }
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testOptionWithEqualSignDoesNotAcceptArg_xkqm3() throws ParseException {
        Options options = new Options();
        options.addOption("a", "option", false, "option does not accept an argument");
        DefaultParser parser = new DefaultParser();
        String[] arguments = {"--option=value"};
        try {
            CommandLine cmd = parser.parse(options, arguments, new Properties(), false);
            fail("Expected ParseException because option does not accept an argument");
        } catch (ParseException e) {
        }
    }
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testHandleOptionSelectsFirstMatchingOption_QgMi4() throws ParseException {
        Options options = new Options();
        options.addOption("opt1", "option1", true, "first option");
        options.addOption("opt2", "option2", true, "second option");
        DefaultParser parser = new DefaultParser();
        String[] arguments = {"--option1=value"};
        CommandLine cmd = parser.parse(options, arguments, new Properties(), false);
        assertEquals("value", cmd.getOptionValue("option1"));
    }
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testHandleUnknownTokenWithNoMatchingOption_QPCf5() throws ParseException {
        Options options = new Options();
        DefaultParser parser = new DefaultParser();
        String[] arguments = {"--nonexistent"};
        try {
            CommandLine cmd = parser.parse(options, arguments, new Properties(), false);
            fail("Expected ParseException because of unknown option");
        } catch (ParseException e) {
        }
    }
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testParse_ShortToken_CGKw1() throws ParseException {
        DefaultParser parser = new DefaultParser();
        Options options = new Options();
        String[] arguments = {"-"};
        Properties properties = new Properties();
        CommandLine result = parser.parse(options, arguments, properties, false);
        assertNotNull(result);
    }
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testParse_LongOptionWithEqualSign_vsFb2() throws ParseException {
        DefaultParser parser = new DefaultParser();
        Options options = new Options();
        options.addOption("opt", "option", true, "An option");
        String[] arguments = {"--option=value"};
        Properties properties = new Properties();
        CommandLine result = parser.parse(options, arguments, properties, false);
        assertNotNull(result);
    }
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testParse_LongOptionWithPrefixNotStartingWithDoubleDash_pyzZ4() throws ParseException {
        DefaultParser parser = new DefaultParser();
        Options options = new Options();
        options.addOption("o", "option", true, "An option");
        String[] arguments = {"-option=value"};
        Properties properties = new Properties();
        CommandLine result = parser.parse(options, arguments, properties, false);
        assertNotNull(result);
    }
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testParse_EmptyToken_ShouldNotBeShortOption_UChx1() throws ParseException {
        DefaultParser parser = new DefaultParser();
        Options options = mock(Options.class);
        String[] arguments = {"-"};
        Properties properties = new Properties();
        parser.parse(options, arguments, properties, false);
        verify(options, never()).hasShortOption(anyString());
    }
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testAmbiguousOptionException_wFOI1_fid1() throws org.apache.commons.cli.ParseException {
        Options options = new Options();
        options.addOption("opt1", "option1", false, "first option");
        options.addOption("opt2", "option2", false, "second option");
        DefaultParser parser = new DefaultParser();
        String[] arguments = {"--opt"};
        try {
            CommandLine cmd = parser.parse(options, arguments, new Properties(), false);
            fail("Expected an AmbiguousOptionException to be thrown");
        } catch (AmbiguousOptionException e) {
            assertEquals("Ambiguous option: '--opt'  (could be: 'option1', 'option2')", e.getMessage());
        } catch (ParseException e) {
            fail("Expected an AmbiguousOptionException, but another ParseException was thrown");
        }
    }
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testParse_CoversIsOption_NZGs0() throws ParseException {
        Options options = new Options();
        options.addOption("a", "alpha", false, "Alpha option");
        options.addOption("b", "beta", true, "Beta option with argument");
        String[] arguments = new String[]{"-a", "--beta=value"};
        Properties properties = new Properties();
        DefaultParser parser = new DefaultParser();
        CommandLine result = parser.parse(options, arguments, properties, false);
        assertTrue(result.hasOption("a"));
        assertTrue(result.hasOption("beta"));
        assertEquals("value", result.getOptionValue("beta"));
    }
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testParse_ShortToken_Dqcl1() throws ParseException {
        DefaultParser parser = new DefaultParser();
        Options options = new Options();
        String[] arguments = {"-"}; // Test input with short token
        CommandLine result = parser.parse(options, arguments, new Properties(), false);
        assertNotNull(result);
        assertTrue(result.getArgList().contains("-")); // Expect the short token to be treated as an argument
    }
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testParse_LongOptionMatch_kMHv2() throws ParseException {
        DefaultParser parser = new DefaultParser(true);
        Options options = new Options();
        options.addOption("opt", "option", false, "Test option");
        String[] arguments = {"--option"}; // Test input with matching long option
        CommandLine result = parser.parse(options, arguments, new Properties(), false);
        assertNotNull(result);
        assertTrue(result.hasOption("option")); // Expect the option to be recognized
    }
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testParse_LongOptionWithEquals_uItu3() throws ParseException {
        DefaultParser parser = new DefaultParser(true);
        Options options = new Options();
        options.addOption("opt", "option", true, "Test option");
        String[] arguments = {"--option=value"}; // Test input with long option and value
        CommandLine result = parser.parse(options, arguments, new Properties(), false);
        assertNotNull(result);
        assertEquals("value", result.getOptionValue("option")); // Expect the option value to be parsed
    }
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testParse_LongOptionPrefixWithoutDoubleDash_nZqb5() throws ParseException {
        DefaultParser parser = new DefaultParser();
        Options options = new Options();
        options.addOption("o", "option", false, "Test option");
        String[] arguments = {"-o"}; // Test input with long option prefix without double dash
        CommandLine result = parser.parse(options, arguments, new Properties(), false);
        assertNotNull(result);
        assertTrue(result.hasOption("o")); // Expect the option to be recognized
    }
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testParse_ShortToken_isCW1() throws ParseException {
        DefaultParser parser = new DefaultParser();
        Options options = mock(Options.class);
        String[] arguments = {"-"}; // Test input with short token
        Properties properties = new Properties();
        CommandLine result = parser.parse(options, arguments, properties, false);
        assertNotNull(result);
    }
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testParse_OptionAcceptsArg_oukS4() throws ParseException {
        Options options = mock(Options.class);
        when(options.hasShortOption("o")).thenReturn(true);
        Option opt = new Option("o", "option", true, "Option with arg");
        when(options.getOption("o")).thenReturn(opt);
        String[] arguments = {"-o", "value"};
        Properties properties = new Properties();
        DefaultParser parser = new DefaultParser();
        parser.parse(options, arguments, properties, false);
    }
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testParse_ShortOptionWithEqualAndValue_sRnB6() throws ParseException {
        Options options = mock(Options.class);
        when(options.hasShortOption("s")).thenReturn(true);
        Option opt = new Option("s", "short", true, "Short option with value");
        when(options.getOption("s")).thenReturn(opt);
        String[] arguments = {"-s=value"};
        Properties properties = new Properties();
        DefaultParser parser = new DefaultParser();
        parser.parse(options, arguments, properties, false);
    }
}