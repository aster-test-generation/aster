/**
 * Generated by Aster
 */
package org.eclipse.cargotracker.domain.model.cargo;

import java.lang.reflect.Field;
import java.time.LocalDateTime;
import java.util.concurrent.TimeUnit;
import org.eclipse.cargotracker.domain.model.handling.HandlingEvent;
import org.eclipse.cargotracker.domain.model.handling.HandlingHistory;
import org.eclipse.cargotracker.domain.model.voyage.Voyage;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.Timeout;
import org.junit.jupiter.api.Timeout.ThreadMode;
import org.junit.jupiter.api.extension.ExtendWith;
import org.mockito.InjectMocks;
import org.mockito.Mock;
import org.mockito.junit.jupiter.MockitoExtension;
import org.mockito.junit.jupiter.MockitoSettings;
import org.mockito.quality.Strictness;

import static org.junit.jupiter.api.Assertions.*;
import static org.junit.jupiter.api.Timeout.ThreadMode.SEPARATE_THREAD;
import static org.mockito.Mockito.mock;

@ExtendWith(MockitoExtension.class)
@MockitoSettings(strictness = Strictness.LENIENT)
public class Aster_Delivery_Test_Passing {
  @Mock
  private RouteSpecification routeSpecification;
  @Mock
  private Itinerary itinerary;
  @Mock
  private HandlingHistory handlingHistory;
  @Mock
  private HandlingEvent lastEvent;
  @InjectMocks
  private Delivery delivery;
  @Mock
  private HandlingActivity nextExpectedActivity;
  @Mock
  private Voyage currentVoyage;
  @Mock
  private LocalDateTime eta;
  @Mock
  private LocalDateTime calculatedAt;
  private TransportStatus transportStatus = TransportStatus.IN_PORT;
  private boolean misdirected = false;
  private RoutingStatus routingStatus = RoutingStatus.NOT_ROUTED;
  private HandlingEvent handlingEvent;
  private Voyage voyage;

  @Test
  @Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
  public void testSetMisdirectedTrue() {
    delivery = new Delivery();
    // Set misdirected to true
    delivery.setMisdirected(true);
  }

  @Test
  @Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
  public void testEquals_SameFields_ReturnsTrue() throws Exception {
    handlingEvent = mock(HandlingEvent.class);
    itinerary = mock(Itinerary.class);
    routeSpecification = mock(RouteSpecification.class);
    delivery = new Delivery(handlingEvent, itinerary, routeSpecification);
    HandlingEvent sameHandlingEvent = handlingEvent;
    Itinerary sameItinerary = itinerary;
    RouteSpecification sameRouteSpecification = routeSpecification;
    Delivery sameDelivery = new Delivery(sameHandlingEvent, sameItinerary, sameRouteSpecification);
    assertTrue(delivery.equals(sameDelivery));
  }

  @Test
  @Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
  public void testEqualsWithSameObject_TcFo0() {
    Delivery delivery = new Delivery();
    assertTrue(delivery.equals(delivery));
  }

  @Test
  @Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
  public void testEqualsWithNull_fiWs1() {
    Delivery delivery = new Delivery();
    assertFalse(delivery.equals(null));
  }

  @Test
  @Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
  public void testEqualsWithDifferentClass_fmHg2() {
    Delivery delivery = new Delivery();
    Object other = new Object();
    assertFalse(delivery.equals(other));
  }

  @Test
  @Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
  public void testEqualsWithDifferentValues_troM3() {
    HandlingEvent event1 = new HandlingEvent();
    Itinerary itinerary1 = new Itinerary();
    RouteSpecification routeSpec1 = new RouteSpecification();
    Delivery delivery1 = new Delivery(event1, itinerary1, routeSpec1);
    HandlingEvent event2 = new HandlingEvent();
    Itinerary itinerary2 = new Itinerary();
    RouteSpecification routeSpec2 = new RouteSpecification();
    Delivery delivery2 = new Delivery(event2, itinerary2, routeSpec2);
    assertFalse(delivery1.equals(delivery2));
  }

  @Test
  @Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
  public void testSetLastEvent() throws Exception {
    delivery = new Delivery();
    // Act: Call setLastEvent on the delivery object with the mocked lastEvent
    delivery.setLastEvent(lastEvent);
    // Assert: Verify if the setLastEvent method sets the lastEvent correctly
    assert delivery.getClass().getDeclaredField("lastEvent").get(delivery) == lastEvent;
  }

  @Test
  @Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
  public void testSetCalculatedAt() throws Exception {
    delivery = new Delivery();
    calculatedAt = LocalDateTime.now();
    // Set the calculatedAt time
    delivery.setCalculatedAt(calculatedAt);
    // Use reflection to access the private field
    LocalDateTime fieldCalculatedAt = (LocalDateTime) java.lang.reflect.Field.class
            .cast(Delivery.class.getDeclaredField("calculatedAt"))
            .get(delivery);
    // Assert that the set value is correctly stored in the private field
    assertEquals(calculatedAt, fieldCalculatedAt, "The calculatedAt should be set correctly in the Delivery object.");
  }

  @Test
  @Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
  public void testSetRoutingStatus() throws Exception {
    delivery = new Delivery();
    // Set the routing status to ROUTED
    delivery.setRoutingStatus(RoutingStatus.ROUTED);
    // Use reflection to access the private field
    java.lang.reflect.Field field = delivery.getClass().getDeclaredField("routingStatus");
    field.setAccessible(true);
    RoutingStatus status = (RoutingStatus) field.get(delivery);
    // Assert that the routing status was set correctly
    assertEquals(RoutingStatus.ROUTED, status, "The routing status should be set to ROUTED.");
  }

  @Test
  @Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
  public void testGetEstimatedTimeOfArrival() throws Exception {
    // Mock dependencies
    lastEvent = mock(HandlingEvent.class);
    itinerary = mock(Itinerary.class);
    routeSpecification = mock(RouteSpecification.class);
    // Setup LocalDateTime for ETA
    eta = LocalDateTime.of(2023, 10, 5, 14, 30);
    // Create instance of Delivery with mocked dependencies
    delivery = new Delivery(lastEvent, itinerary, routeSpecification);
    // Set private field 'eta' using reflection
    java.lang.reflect.Field etaField = Delivery.class.getDeclaredField("eta");
    etaField.setAccessible(true);
    etaField.set(delivery, eta);
    // Execute
    LocalDateTime result = delivery.getEstimatedTimeOfArrival();
    // Verify
    assertEquals(eta, result, "The estimated time of arrival should match the expected value.");
  }

  @Test
  @Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
  public void testGetCalculatedAt() throws Exception {
    calculatedAt = LocalDateTime.now();
    HandlingEvent lastEvent = mock(HandlingEvent.class);
    Itinerary itinerary = mock(Itinerary.class);
    RouteSpecification routeSpecification = mock(RouteSpecification.class);
    delivery = new Delivery(lastEvent, itinerary, routeSpecification);
    // Assuming there's a setter or method to set calculatedAt in Delivery (not shown in original class)
    delivery.setCalculatedAt(calculatedAt); // This method should exist in Delivery class to make this work
    LocalDateTime result = delivery.getCalculatedAt();
    assertEquals(calculatedAt, result, "The calculatedAt should match the value set in setup");
  }

  @Test
  @Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
  public void testGetCalculatedAt_nuLv0() {
    LocalDateTime expectedTime = LocalDateTime.now();
    HandlingEvent lastEvent = new HandlingEvent();
    Itinerary itinerary = new Itinerary();
    RouteSpecification routeSpecification = new RouteSpecification();
    Delivery delivery = new Delivery(lastEvent, itinerary, routeSpecification);
    LocalDateTime actualTime = delivery.getCalculatedAt();
    assertEquals(expectedTime, actualTime);
  }

  @Test
  @Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
  public void testGetTransportStatus_LFdl0() {
    HandlingEvent lastEvent = new HandlingEvent();
    Itinerary itinerary = new Itinerary();
    RouteSpecification routeSpecification = new RouteSpecification();
    Delivery delivery = new Delivery(lastEvent, itinerary, routeSpecification);
    TransportStatus expected = TransportStatus.IN_PORT; // Assuming IN_PORT is a valid enum constant
    TransportStatus actual = delivery.getTransportStatus();
    assertEquals(expected, actual);
  }
}