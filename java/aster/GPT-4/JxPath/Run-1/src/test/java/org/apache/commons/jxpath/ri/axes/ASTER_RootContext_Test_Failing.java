/**
 * Generated by Aster
 */
package org.apache.commons.jxpath.ri.axes;
import org.apache.commons.jxpath.NodeSet;
import org.apache.commons.jxpath.ri.EvalContext;
import org.apache.commons.jxpath.ri.JXPathContextReferenceImpl;
import org.apache.commons.jxpath.ri.QName;
import org.apache.commons.jxpath.ri.model.NodePointer;
import org.apache.commons.jxpath.ri.model.dom.DOMNodePointer;
import org.apache.commons.jxpath.ri.model.VariablePointer;
import static org.junit.jupiter.api.Assertions.*;
import java.util.Locale;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.Timeout;
import org.junit.jupiter.api.Timeout.ThreadMode;
import java.util.concurrent.TimeUnit;
import static org.junit.jupiter.api.Timeout.ThreadMode.SEPARATE_THREAD;
import org.junit.jupiter.api.extension.ExtendWith;
import org.mockito.junit.jupiter.MockitoSettings;
import org.mockito.quality.Strictness;
import org.mockito.InjectMocks;
import org.mockito.InjectMocks;
import org.mockito.Mock;
import org.mockito.junit.jupiter.MockitoExtension;
import static org.mockito.Mockito.*;
import java.lang.reflect.Field;   
@ExtendWith(MockitoExtension.class)
@MockitoSettings(strictness = Strictness.LENIENT)
public class Aster_RootContext_Test_Failing {
@Mock
    private JXPathContextReferenceImpl jxpathContext;
@Mock
    private DOMNodePointer pointer;
@InjectMocks
    private RootContext rootContext;
@Mock
    private DOMNodePointer domNodePointer;
@Mock
    private EvalContext expectedEvalContext;
@Mock
    private NodePointer mockNodePointer;
@Mock
    private NodeSet mockNodeSet;
@Mock
    private JXPathContextReferenceImpl mockJXPathContextReferenceImpl;
@Mock
    private DOMNodePointer mockDOMNodePointer;
@Mock
    private VariablePointer variablePointer;
@Mock
    private EvalContext evalContext;
private static final int MAX_REGISTER = 4;
private Object[] registers = new Object[MAX_REGISTER];
    private int availableRegister = 0;
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testToString() throws Exception {
        when(pointer.asPath()).thenReturn("mockedPath");
        rootContext = new RootContext(null, null); // Assuming the constructor can handle nulls
        String expected = rootContext.getClass().getName() + "@" + Integer.toHexString(rootContext.hashCode()) + ":mockedPath";
        assertEquals(expected, rootContext.toString());
    }
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testGetValue_2() throws Exception {
        // Setup the RootContext with mocked JXPathContextReferenceImpl and DOMNodePointer
        rootContext = new RootContext(jxpathContext, domNodePointer);
        // Assuming there's a way to set the pointer, since it's private and no setter is shown
        // This might require adjusting the actual RootContext class to allow injection of NodePointer
        when(domNodePointer.getValue()).thenReturn(pointer);
        // Act
        Object result = rootContext.getValue();
        // Assert
        assertSame(pointer, result, "The result should be the same as the mocked NodePointer.");}
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testGetVariableContext_3() throws Exception {
        when(jxpathContext.getVariablePointer(any(QName.class))).thenReturn(variablePointer);
        rootContext = new RootContext(jxpathContext, domNodePointer);
        QName variableName = new QName("testVariable");
        InitialContext expectedContext = new InitialContext(new RootContext(jxpathContext, variablePointer));
        EvalContext resultContext = rootContext.getVariableContext(variableName);
        assertEquals(expectedContext, resultContext, "The expected context does not match the result context");}
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testSetRegisteredValue_StoresValuesCorrectly_2() {
        JXPathContextReferenceImpl mockJXPathContextRef = mock(JXPathContextReferenceImpl.class);
        DOMNodePointer mockDOMNodePointer = mock(DOMNodePointer.class);
        rootContext = new RootContext(mockJXPathContextRef, mockDOMNodePointer);
        // Test adding values within the limit
        assertEquals(1, rootContext.setRegisteredValue("Value 2"), "Second value should be stored at index 1");}
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testSetRegisteredValue_StoresValuesCorrectly_3() {
        JXPathContextReferenceImpl mockJXPathContextRef = mock(JXPathContextReferenceImpl.class);
        DOMNodePointer mockDOMNodePointer = mock(DOMNodePointer.class);
        rootContext = new RootContext(mockJXPathContextRef, mockDOMNodePointer);
        // Test adding values within the limit
        assertEquals(2, rootContext.setRegisteredValue("Value 3"), "Third value should be stored at index 2");}
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testSetRegisteredValue_StoresValuesCorrectly_4() {
        JXPathContextReferenceImpl mockJXPathContextRef = mock(JXPathContextReferenceImpl.class);
        DOMNodePointer mockDOMNodePointer = mock(DOMNodePointer.class);
        rootContext = new RootContext(mockJXPathContextRef, mockDOMNodePointer);
        // Test adding values within the limit
        assertEquals(3, rootContext.setRegisteredValue("Value 4"), "Fourth value should be stored at index 3");}
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testGetCurrentNodePointer() {
        rootContext = new RootContext(jxpathContext, domNodePointer);
        // Mock the behavior of the DOMNodePointer to return the mocked NodePointer
        when(domNodePointer.getNode()).thenReturn(pointer);
        // Call the method under test
        NodePointer result = rootContext.getCurrentNodePointer();
        // Assert that the result is the same as the mocked pointer
        assertEquals(pointer, result, "The returned NodePointer should be the same as the mocked NodePointer");
    }
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testGetRegisteredValue_InvalidIndex_ReturnsUnknownValue_1() throws Exception {
        // Initialize the registers array with some test data
        registers[0] = "First";
        registers[1] = "Second";
        registers[2] = "Third";
        registers[3] = "Fourth";
        // Create a RootContext with mocked dependencies
        rootContext = new RootContext(mockJXPathContextReferenceImpl, mockDOMNodePointer);
        // Using reflection to set the private field 'registers'
        java.lang.reflect.Field field = rootContext.getClass().getDeclaredField("registers");
        field.setAccessible(true);
        field.set(rootContext, registers);
        assertNull(rootContext.getRegisteredValue(-1), "Should return UNKNOWN_VALUE for negative index");}
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testGetRegisteredValue_InvalidIndex_ReturnsUnknownValue_2() throws Exception {
        // Initialize the registers array with some test data
        registers[0] = "First";
        registers[1] = "Second";
        registers[2] = "Third";
        registers[3] = "Fourth";
        // Create a RootContext with mocked dependencies
        rootContext = new RootContext(mockJXPathContextReferenceImpl, mockDOMNodePointer);
        // Using reflection to set the private field 'registers'
        java.lang.reflect.Field field = rootContext.getClass().getDeclaredField("registers");
        field.setAccessible(true);
        field.set(rootContext, registers);
        assertNull(rootContext.getRegisteredValue(MAX_REGISTER), "Should return UNKNOWN_VALUE for index equal to MAX_REGISTER");}
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testGetRegisteredValue_InvalidIndex_ReturnsUnknownValue_3() throws Exception {
        // Initialize the registers array with some test data
        registers[0] = "First";
        registers[1] = "Second";
        registers[2] = "Third";
        registers[3] = "Fourth";
        // Create a RootContext with mocked dependencies
        rootContext = new RootContext(mockJXPathContextReferenceImpl, mockDOMNodePointer);
        // Using reflection to set the private field 'registers'
        java.lang.reflect.Field field = rootContext.getClass().getDeclaredField("registers");
        field.setAccessible(true);
        field.set(rootContext, registers);
        assertNull(rootContext.getRegisteredValue(100), "Should return UNKNOWN_VALUE for index out of bounds");}
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
public void testGetConstantContextWithNodeSet_ecBG0_1() throws Exception {
    rootContext = new RootContext(jxpathContext, null);
    when(mockNodeSet instanceof NodeSet).thenReturn(true);
    EvalContext result = rootContext.getConstantContext(mockNodeSet);
    assertTrue(result instanceof NodeSetContext);}
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
public void testGetConstantContextWithNodeSet_ecBG0_2() throws Exception {
    rootContext = new RootContext(jxpathContext, null);
    when(mockNodeSet instanceof NodeSet).thenReturn(true);
    EvalContext result = rootContext.getConstantContext(mockNodeSet);
    assertTrue(mockNodeSet instanceof NodeSet);}
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
public void testGetAbsoluteRootContext_ZzNP0_eSsr0_2() {
    JXPathContextReferenceImpl jxpathContext = new JXPathContextReferenceImpl(null, new Object(), null);
    DOMNodePointer pointer = new DOMNodePointer(null, Locale.getDefault());
    RootContext rootContext = new RootContext(jxpathContext, pointer);
    EvalContext result = rootContext.getAbsoluteRootContext();
    assertTrue(result instanceof RootContext);}
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testGetValue_2_fid1() throws Exception {
        // Setup the RootContext with mocked JXPathContextReferenceImpl and DOMNodePointer
        rootContext = new RootContext(jxpathContext, domNodePointer);
        // Assuming there's a way to set thedomNodePointer, since it's private and no setter is shown
        // This might require adjusting the actual RootContext class to allow injection of NodePointer
        when(domNodePointer.getValue()).thenReturn(pointer);
        // Act
        Object result = rootContext.getValue();
        // Assert
        assertSame(pointer, result, "The result should be the same as the mocked NodePointer.");}
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testSetRegisteredValue_StoresValuesCorrectly_3_fid1() {
        JXPathContextReferenceImpl mockJXPathContextRef = mock(JXPathContextReferenceImpl.class);
        DOMNodePointer mockDOMNodePointer = mock(DOMNodePointer.class);
        rootContext = new RootContext(mockJXPathContextRef, mockDOMNodePointer);
        // Test adding values within the limit
        assertEquals(2, rootContext.setRegisteredValue("Value 3"), "Third value should be stored at index0");}
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testSetRegisteredValue_StoresValuesCorrectly_4_fid1() {
        JXPathContextReferenceImpl mockJXPathContextRef = mock(JXPathContextReferenceImpl.class);
        DOMNodePointer mockDOMNodePointer = mock(DOMNodePointer.class);
        rootContext = new RootContext(mockJXPathContextRef, mockDOMNodePointer);
        // Test adding values within the limit
        assertEquals(3, rootContext.setRegisteredValue("Value 4"), "Fourth value should be stored at index0");}
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testGetCurrentNodePointer_fid1() {
        rootContext = new RootContext(jxpathContext, domNodePointer);
        // Mock the behavior of the DOMNodePointer to return the mocked NodePointer
        when(domNodePointer.getNode()).thenReturn(pointer);
        // Call the method under test
        NodePointer result = rootContext.getCurrentNodePointer();
        // Assert that the result is the same as the mockeddomNodePointer
        assertEquals(pointer, result, "The returned NodePointer should be the same as the mocked NodePointer");
    }
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testGetValue() throws Exception {
        // Setup the RootContext with mocked JXPathContextReferenceImpl and DOMNodePointer
        rootContext = new RootContext(jxpathContext, domNodePointer);
        // Assuming there's a way to set the pointer, since it's private and no setter is shown
        // This might require adjusting the actual RootContext class to allow injection of NodePointer
        when(domNodePointer.getValue()).thenReturn(pointer);
        // Act
        Object result = rootContext.getValue();
        // Assert
        assertNotNull(result, "The result should not be null.");
        assertSame(pointer, result, "The result should be the same as the mocked NodePointer.");
    }
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testGetVariableContext() throws Exception {
        when(jxpathContext.getVariablePointer(any(QName.class))).thenReturn(variablePointer);
        rootContext = new RootContext(jxpathContext, domNodePointer);
        QName variableName = new QName("testVariable");
        InitialContext expectedContext = new InitialContext(new RootContext(jxpathContext, variablePointer));
        EvalContext resultContext = rootContext.getVariableContext(variableName);
        assertNotNull(resultContext, "The result context should not be null");
        assertTrue(resultContext instanceof InitialContext, "The result context should be an instance of InitialContext");
        assertEquals(expectedContext, resultContext, "The expected context does not match the result context");
    }
}