/**
 * Generated by Aster
 */
package org.apache.commons.jxpath.ri;
import java.util.Iterator;
import org.apache.commons.jxpath.Functions;
import org.apache.commons.jxpath.JXPathContext;
import org.apache.commons.jxpath.JXPathException;
import org.apache.commons.jxpath.JXPathFunctionNotFoundException;
import org.apache.commons.jxpath.JXPathTypeConversionException;
import org.apache.commons.jxpath.Pointer;
import org.apache.commons.jxpath.ri.compiler.Expression;
import org.apache.commons.jxpath.ri.model.NodePointer;
import org.apache.commons.jxpath.util.ClassLoaderUtil;
import static org.junit.jupiter.api.Assertions.*;
import java.util.Iterator;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.Timeout;
import org.junit.jupiter.api.Timeout.ThreadMode;
import java.util.concurrent.TimeUnit;
import static org.mockito.Mockito.*;
import static org.junit.jupiter.api.Timeout.ThreadMode.SEPARATE_THREAD;
public class Aster_JXPathContextReferenceImpl_Coverage_Test_Passing {
private JXPathContextReferenceImpl jxpathContextReferenceImpl;
private Expression expression;
@BeforeEach
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testGetNamespaceContextPointer_SPYv0() {
        JXPathContext parentContext = mock(JXPathContext.class);
        Object contextBean = new Object();
        NodePointer contextPointer = mock(NodePointer.class);
        NamespaceResolver namespaceResolver = mock(NamespaceResolver.class);
        Pointer expectedPointer = mock(Pointer.class);
        JXPathContextReferenceImpl contextReferenceImpl = new JXPathContextReferenceImpl(parentContext, contextBean, contextPointer);
        contextReferenceImpl.namespaceResolver = namespaceResolver; // Assuming there's a way to set this, e.g., via a setter or directly if it's public
        when(namespaceResolver.getNamespaceContextPointer()).thenReturn(expectedPointer);
        Pointer resultPointer = contextReferenceImpl.getNamespaceContextPointer();
    }
@BeforeEach
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testAllocateConditionally_ExistenceCheckClassNotFound_nkOU0() {
        String existenceCheckClassName = "com.example.NonExistentClass";
        String className = "com.example.SomeClass";
        try {
            ClassLoaderUtil.getClass(existenceCheckClassName, true);
            fail("ClassNotFoundException expected but not thrown");
        } catch (ClassNotFoundException e) {
        }
        Object result = JXPathContextReferenceImpl.allocateConditionally(className, existenceCheckClassName);
    }
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testRemovePath_PointerNotNull_pvwV0() {
        JXPathContextReferenceImpl context = new JXPathContextReferenceImpl(null, new Object());
        String xpath = "/some/path";
        Expression expr = mock(Expression.class);
        NodePointer mockPointer = mock(NodePointer.class);
        JXPathContextReferenceImpl spyContext = spy(context);
        doReturn(mockPointer).when(spyContext).getPointer(xpath, expr);
        spyContext.removePath(xpath, expr);
        verify(mockPointer).remove();
    }
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testRemovePath_CatchesExceptionAndRethrows_PHNp3() {
        JXPathContextReferenceImpl context = new JXPathContextReferenceImpl(null, new Object());
        String xpath = "/some/path";
        Expression expr = mock(Expression.class);
        JXPathContextReferenceImpl spyContext = spy(context);
        doThrow(new RuntimeException("Test Exception")).when(spyContext).getPointer(xpath, expr);
        try {
            spyContext.removePath(xpath, expr);
        } catch (JXPathException ex) {
            assertEquals("Exception trying to remove xpath " + xpath, ex.getMessage());
        }
    }
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testRemovePath_ExpressionComputesPointer_zJyW4() {
        JXPathContextReferenceImpl context = new JXPathContextReferenceImpl(null, new Object());
        String xpath = "/some/path";
        Expression expr = mock(Expression.class);
        NodePointer mockPointer = mock(NodePointer.class);
        JXPathContextReferenceImpl spyContext = spy(context);
        doReturn(mockPointer).when(spyContext).getPointer(xpath, expr);
        spyContext.removePath(xpath, expr);
        verify(spyContext).getPointer(xpath, expr);
    }
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testRemovePath_NoExceptionThrown_rKuo6() {
        JXPathContextReferenceImpl context = new JXPathContextReferenceImpl(null, new Object());
        String xpath = "/some/path";
        Expression expr = mock(Expression.class);
        NodePointer mockPointer = mock(NodePointer.class);
        JXPathContextReferenceImpl spyContext = spy(context);
        doReturn(mockPointer).when(spyContext).getPointer(xpath, expr);
        spyContext.removePath(xpath, expr);
    }
@BeforeEach
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testGetRelativeContextWithNonNullNode_mAtt1() {
        JXPathContext parentContext = mock(JXPathContext.class);
        Object contextBean = new Object();
        JXPathContextReferenceImpl contextReference = new JXPathContextReferenceImpl(parentContext, contextBean);
        Pointer pointer = mock(Pointer.class);
        Object node = new Object();
        when(pointer.getNode()).thenReturn(node);
        JXPathContext resultContext = contextReference.getRelativeContext(pointer);
        assertNotNull(resultContext);
        assertTrue(resultContext instanceof JXPathContextReferenceImpl);
    }
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testSetNamespaceContextPointer_WhenNamespaceResolverIsSealed_HyFT0() {
        JXPathContext parentContext = mock(JXPathContext.class);
        Object contextBean = new Object();
        NodePointer contextPointer = mock(NodePointer.class);
        JXPathContextReferenceImpl contextReference = new JXPathContextReferenceImpl(parentContext, contextBean, contextPointer);
        NamespaceResolver mockResolver = mock(NamespaceResolver.class);
        when(mockResolver.isSealed()).thenReturn(true);
        when(mockResolver.clone()).thenReturn(mock(NamespaceResolver.class));
        contextReference.namespaceResolver = mockResolver;
        Pointer pointer = mock(NodePointer.class);
        contextReference.setNamespaceContextPointer(pointer);
        verify(mockResolver).clone();
        verify(mockResolver).setNamespaceContextPointer((NodePointer) pointer);
    }
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testSetNamespaceContextPointer_WhenNamespaceResolverIsNotSealed_IDvh1() {
        JXPathContext parentContext = mock(JXPathContext.class);
        Object contextBean = new Object();
        NodePointer contextPointer = mock(NodePointer.class);
        JXPathContextReferenceImpl contextReference = new JXPathContextReferenceImpl(parentContext, contextBean, contextPointer);
        NamespaceResolver mockResolver = mock(NamespaceResolver.class);
        when(mockResolver.isSealed()).thenReturn(false);
        contextReference.namespaceResolver = mockResolver;
        Pointer pointer = mock(NodePointer.class);
        contextReference.setNamespaceContextPointer(pointer);
        verify(mockResolver, never()).clone();
        verify(mockResolver).setNamespaceContextPointer((NodePointer) pointer);
    }
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testSetNamespaceContextPointer_WithNullPointer_LvsT2() {
        JXPathContext parentContext = mock(JXPathContext.class);
        Object contextBean = new Object();
        NodePointer contextPointer = mock(NodePointer.class);
        JXPathContextReferenceImpl contextReference = new JXPathContextReferenceImpl(parentContext, contextBean, contextPointer);
        NamespaceResolver mockResolver = mock(NamespaceResolver.class);
        when(mockResolver.isSealed()).thenReturn(true);
        when(mockResolver.clone()).thenReturn(mock(NamespaceResolver.class));
        contextReference.namespaceResolver = mockResolver;
        Pointer pointer = null;
        contextReference.setNamespaceContextPointer(pointer);
        verify(mockResolver).clone();
        verify(mockResolver).setNamespaceContextPointer(null);
    }
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testRegisterNamespaceWithUnsealedResolver_FZrf0() {
        JXPathContext parentContext = mock(JXPathContext.class);
        Object contextBean = new Object();
        JXPathContextReferenceImpl context = new JXPathContextReferenceImpl(parentContext, contextBean);
        NamespaceResolver namespaceResolver = mock(NamespaceResolver.class);
        when(namespaceResolver.isSealed()).thenReturn(false);
        context.namespaceResolver = namespaceResolver;
        context.registerNamespace("prefix", "namespaceURI");
        verify(namespaceResolver).registerNamespace("prefix", "namespaceURI");
    }
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testRegisterNamespaceWithSealedResolver_cKCq1() {
        JXPathContext parentContext = mock(JXPathContext.class);
        Object contextBean = new Object();
        JXPathContextReferenceImpl context = new JXPathContextReferenceImpl(parentContext, contextBean);
        NamespaceResolver namespaceResolver = mock(NamespaceResolver.class);
        NamespaceResolver clonedResolver = mock(NamespaceResolver.class);
        when(namespaceResolver.isSealed()).thenReturn(true);
        when(namespaceResolver.clone()).thenReturn(clonedResolver);
        context.namespaceResolver = namespaceResolver;
        context.registerNamespace("prefix", "namespaceURI");
        verify(namespaceResolver).isSealed();
        verify(namespaceResolver).clone();
        verify(clonedResolver).registerNamespace("prefix", "namespaceURI");
    }
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testRegisterNamespaceWithSealedResolverAndVerifyCloneUsed_IUeS2() {
        JXPathContext parentContext = mock(JXPathContext.class);
        Object contextBean = new Object();
        JXPathContextReferenceImpl context = new JXPathContextReferenceImpl(parentContext, contextBean);
        NamespaceResolver namespaceResolver = mock(NamespaceResolver.class);
        NamespaceResolver clonedResolver = mock(NamespaceResolver.class);
        when(namespaceResolver.isSealed()).thenReturn(true);
        when(namespaceResolver.clone()).thenReturn(clonedResolver);
        context.namespaceResolver = namespaceResolver;
        context.registerNamespace("prefix", "namespaceURI");
        verify(namespaceResolver).isSealed();
        verify(namespaceResolver).clone();
        assert context.namespaceResolver == clonedResolver;
    }
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testRegisterNamespaceWithUnsealedResolverDirectCall_bxuK3() {
        JXPathContext parentContext = mock(JXPathContext.class);
        Object contextBean = new Object();
        JXPathContextReferenceImpl context = new JXPathContextReferenceImpl(parentContext, contextBean);
        NamespaceResolver namespaceResolver = new NamespaceResolver();
        context.namespaceResolver = namespaceResolver;
        context.registerNamespace("prefix", "namespaceURI");
        assert namespaceResolver.getNamespaceURI("prefix").equals("namespaceURI");
    }
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testGetValueWithIncompatibleTypes_VyQC4() {
        JXPathContext parentContext = mock(JXPathContext.class);
        Object contextBean = new Object();
        JXPathContextReferenceImpl context = new JXPathContextReferenceImpl(parentContext, contextBean);
        Expression expr = mock(Expression.class);
        when(expr.compute(any())).thenReturn(new Object());
        try {
            context.getValue("dummy/xpath", expr, Integer.class);
            fail("Expected JXPathTypeConversionException was not thrown");
        } catch (JXPathTypeConversionException e) {
        }
    }
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testGetFunction_NullParentContext_Emng3() {
        QName functionName = new QName("http://example.com", "testFunction");
        Object[] parameters = new Object[]{};
        JXPathContextReferenceImpl context = new JXPathContextReferenceImpl(null, new Object());
        Functions functions = mock(Functions.class);
        when(functions.getFunction("http://example.com", "testFunction", parameters)).thenReturn(null);
        JXPathContextReferenceImpl spyContext = spy(context);
        when(spyContext.getFunctions()).thenReturn(functions);
        when(spyContext.getParentContext()).thenReturn(null);
        try {
            spyContext.getFunction(functionName, parameters);
            fail("Expected JXPathFunctionNotFoundException to be thrown");
        } catch (JXPathFunctionNotFoundException e) {
            assertEquals("Undefined function: http://example.com:testFunction", e.getMessage());
        }
    }
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testGetFunction_NoFunctionsAvailable_oJPT5() {
        QName functionName = new QName("http://example.com", "testFunction");
        Object[] parameters = new Object[]{};
        JXPathContextReferenceImpl context = new JXPathContextReferenceImpl(null, new Object());
        JXPathContextReferenceImpl spyContext = spy(context);
        when(spyContext.getFunctions()).thenReturn(null);
        try {
            spyContext.getFunction(functionName, parameters);
            fail("Expected JXPathFunctionNotFoundException to be thrown");
        } catch (JXPathFunctionNotFoundException e) {
            assertEquals("Undefined function: http://example.com:testFunction", e.getMessage());
        }
    }
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testGetFunction_FunctionNotFoundInHierarchy_chws6() {
        QName functionName = new QName("http://example.com", "testFunction");
        Object[] parameters = new Object[]{};
        JXPathContextReferenceImpl childContext = new JXPathContextReferenceImpl(null, new Object());
        JXPathContextReferenceImpl parentContext = new JXPathContextReferenceImpl(null, new Object());
        Functions childFunctions = mock(Functions.class);
        Functions parentFunctions = mock(Functions.class);
        when(childFunctions.getFunction("http://example.com", "testFunction", parameters)).thenReturn(null);
        when(parentFunctions.getFunction("http://example.com", "testFunction", parameters)).thenReturn(null);
        JXPathContextReferenceImpl spyChildContext = spy(childContext);
        JXPathContextReferenceImpl spyParentContext = spy(parentContext);
        when(spyChildContext.getParentContext()).thenReturn(spyParentContext);
        when(spyChildContext.getFunctions()).thenReturn(childFunctions);
        when(spyParentContext.getFunctions()).thenReturn(parentFunctions);
        try {
            spyChildContext.getFunction(functionName, parameters);
            fail("Expected JXPathFunctionNotFoundException to be thrown");
        } catch (JXPathFunctionNotFoundException e) {
            assertEquals("Undefined function: http://example.com:testFunction", e.getMessage());
        }
    }
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
public void setup_JVlX00_bUvj0() throws Exception {
    JXPathContext parentContext = null; // Assuming null for simplification, replace with actual initialization
    Object contextBean = new Object(); // Assuming a new Object for contextBean, replace with actual initialization
    JXPathContextReferenceImpl jxpathcontextreferenceimpl = new JXPathContextReferenceImpl(parentContext, contextBean);
}
@BeforeEach
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
public void testGetValue_ReturnsDirectValueWhenNotContextDependent_dZwY15_yqnC0() throws Exception {
    Expression expr = mock(Expression.class);
    EvalContext evalContext = mock(EvalContext.class);
    JXPathContextReferenceImpl jxpathcontextreferenceimpl = mock(JXPathContextReferenceImpl.class);
    when(expr.computeValue(evalContext)).thenReturn("directValue");
    when(jxpathcontextreferenceimpl.getValue("xpath")).thenReturn("directValue");
    Object result = jxpathcontextreferenceimpl.getValue("xpath");
    assertEquals("directValue", result);
}
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
public void testGetNamespaceURI_RsMm0_QbVc0() {
    JXPathContext parentContext = mock(JXPathContext.class);
    Object contextBean = new Object();
    NamespaceResolver namespaceResolver = mock(NamespaceResolver.class);
    JXPathContextReferenceImpl contextReference = new JXPathContextReferenceImpl(parentContext, contextBean) {
    };
    contextReference.namespaceResolver = namespaceResolver; // Directly setting the mocked NamespaceResolver
    String expectedURI = "http://example.com/ns";
    when(namespaceResolver.getNamespaceURI("prefix")).thenReturn(expectedURI);
    String result = contextReference.getNamespaceURI("prefix");
    assertEquals("Expected and actual URI do not match", expectedURI, result);
}
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
public void testGetValueReturnsDirectly_vrjd0_jGQN0() {
    JXPathContext parentContext = mock(JXPathContext.class);
    Object contextBean = new Object();
    JXPathContextReferenceImpl context = new JXPathContextReferenceImpl(parentContext, contextBean);
    Expression expr = mock(Expression.class);
    when(expr.compute(any())).thenReturn(10);
    assertEquals(10, (int) context.getValue("dummy/xpath", expr, Integer.class));
}
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
public void testGetValueWithNullValue_KFby1_vsGP0() {
    JXPathContext parentContext = mock(JXPathContext.class);
    Object contextBean = new Object();
    JXPathContextReferenceImpl context = new JXPathContextReferenceImpl(parentContext, contextBean);
    Expression expr = mock(Expression.class);
    when(expr.compute(any())).thenReturn(null);
    assertNull(context.getValue("dummy/xpath", expr, Object.class));
}
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
public void testGetValue_VerifiesNodePointerWhenNotLenient_NbqT13_CIhJ0() throws Exception {
    Expression expr = mock(Expression.class);
    EvalContext evalContext = mock(EvalContext.class);
    NodePointer nodePointer = mock(NodePointer.class);
    JXPathContextReferenceImpl jxpathcontextreferenceimpl = mock(JXPathContextReferenceImpl.class);
    when(expr.computeValue(evalContext)).thenReturn(nodePointer);
    when(jxpathcontextreferenceimpl.isLenient()).thenReturn(false);
    when(jxpathcontextreferenceimpl.getValue("xpath", expr)).thenReturn(null);
    jxpathcontextreferenceimpl.getValue("xpath", expr);
    verify(nodePointer).isLeaf();
}
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
public void testGetValueWithNullRequiredType_yONA5_cHEL0() {
    JXPathContext parentContext = mock(JXPathContext.class);
    Object contextBean = new Object();
    JXPathContextReferenceImpl context = new JXPathContextReferenceImpl(parentContext, contextBean);
    Expression expr = mock(Expression.class);
    when(expr.compute(any())).thenReturn("123");
    assertEquals("123", context.getValue("dummy/xpath", expr, null), "Should return the original value when required type is null");
}
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
public void testGetFunction_FunctionInParentContext_iZFh4_sROm0() {
    QName functionName = new QName("http://example.com", "testFunction");
}
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
public void setup_Sgsf0_VKKw0() {
    JXPathContext parentContext = mock(JXPathContext.class);
    Object contextBean = new Object();
    NodePointer contextPointer = mock(NodePointer.class);
    JXPathContextReferenceImpl jxpathContextReferenceImpl = new JXPathContextReferenceImpl(parentContext, contextBean, contextPointer);
}
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
public void testRemoveAll_SingleElement_obqt3_MTWv0() {
    Iterator<NodePointer> iterator = mock(Iterator.class);
    NodePointer nodePointer = mock(NodePointer.class);
    JXPathContextReferenceImpl jxpathContextReferenceImpl = mock(JXPathContextReferenceImpl.class);
    Expression expr = mock(Expression.class);
    when(iterator.hasNext()).thenReturn(true).thenReturn(false);
    when(iterator.next()).thenReturn(nodePointer);
    doNothing().when(nodePointer).remove();
    jxpathContextReferenceImpl.removeAll("testXPath", expr);
    verify(nodePointer, times(1)).remove();
    verify(jxpathContextReferenceImpl, never()).removePath(anyString());
}
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
public void testRemoveAll_EmptyIterator_NcUe2_EgDQ0() {
    Iterator iterator = mock(Iterator.class);
    when(iterator.hasNext()).thenReturn(false);
    jxpathContextReferenceImpl.removePath("testXPath");
    verify(jxpathContextReferenceImpl, times(1)).removePath("testXPath");
}
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
public void testRemoveAll_ThrowsExceptionDuringRemove_fxHB5_Cyig0_1() {
    Iterator<NodePointer> iterator = mock(Iterator.class);
    NodePointer nodePointer = mock(NodePointer.class);
    JXPathContextReferenceImpl jxpathContextReferenceImpl = mock(JXPathContextReferenceImpl.class);
    when(iterator.hasNext()).thenReturn(true, false);
    when(iterator.next()).thenReturn(nodePointer);
    doThrow(new RuntimeException("Test Exception")).when(nodePointer).remove();
    Exception exception = assertThrows(JXPathException.class, () -> {
        jxpathContextReferenceImpl.removeAll("testXPath");
    });}
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
public void testRemoveAll_IterationCheck_yohh9_ACBp0() {
    Iterator<NodePointer> iterator = mock(Iterator.class);
    NodePointer nodePointer = mock(NodePointer.class);
    when(iterator.hasNext()).thenReturn(true, false);
    when(iterator.next()).thenReturn(nodePointer);
    JXPathContextReferenceImpl jxpathContextReferenceImpl = mock(JXPathContextReferenceImpl.class);
    jxpathContextReferenceImpl.removeAll("testXPath");
    verify(iterator, times(1)).next();
}
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
public void testRemoveAll_ContextDependentExpression_shOD11_KzPA0() {
    Expression expr = mock(Expression.class);
    when(expr.isContextDependent()).thenReturn(true);
    JXPathContextReferenceImpl jxpathContextReferenceImpl = mock(JXPathContextReferenceImpl.class);
    jxpathContextReferenceImpl.removeAll("testXPath", expr);
    verify(expr, times(1)).iterate(any(EvalContext.class));
}
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
public void testRemoveAll_ContextIndependentExpression_fYTI12_DWdr0() {
    Expression expr = mock(Expression.class);
    when(expr.isContextDependent()).thenReturn(false);
    JXPathContextReferenceImpl jxpathContextReferenceImpl = mock(JXPathContextReferenceImpl.class);
}
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
public void testRemoveAll_ExpressionEvaluation_UjAX13_bglg0() {
    Iterator<NodePointer> iterator = mock(Iterator.class);
    NodePointer nodePointer = mock(NodePointer.class);
    when(iterator.hasNext()).thenReturn(true, false);
    when(iterator.next()).thenReturn(nodePointer);
    Expression expr = mock(Expression.class);
    JXPathContextReferenceImpl jxpathContextReferenceImpl = mock(JXPathContextReferenceImpl.class);
    when(expr.iteratePointers(any())).thenReturn(iterator);
    jxpathContextReferenceImpl.removeAll("testXPath", expr);
    verify(expr, times(1)).iteratePointers(any());
}
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
public void testRemoveAll_ThrowsExceptionDuringRemovePath_lMLD6_DBYa0_1() {
    Iterator<NodePointer> iterator = mock(Iterator.class);
    when(iterator.hasNext()).thenReturn(true, true, false);
    NodePointer nodePointer = mock(NodePointer.class);
    when(iterator.next()).thenReturn(nodePointer).thenReturn(nodePointer);
    doNothing().when(nodePointer).remove();
    JXPathContextReferenceImpl jxpathContextReferenceImpl = mock(JXPathContextReferenceImpl.class);
    doThrow(new RuntimeException("Test Exception")).when(jxpathContextReferenceImpl).removePath(anyString());
    Exception exception = assertThrows(JXPathException.class, () -> {
        jxpathContextReferenceImpl.removeAll("testXPath");
    });}
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
public void testRemoveAll_NormalFlow_EjLO1_glsz0() {
    Iterator<NodePointer> iterator = mock(Iterator.class);
    NodePointer nodePointer = mock(NodePointer.class);
    JXPathContextReferenceImpl jxpathContextReferenceImpl = mock(JXPathContextReferenceImpl.class);
    Expression expr = mock(Expression.class);
    when(iterator.hasNext()).thenReturn(true, true, false);
    when(iterator.next()).thenReturn(nodePointer).thenReturn(nodePointer);
}
}