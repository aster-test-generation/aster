/**
 * Generated by Aster
 */
package org.apache.commons.jxpath.ri.model.dom;
import java.util.Locale;
import org.apache.commons.jxpath.JXPathContext;
import org.apache.commons.jxpath.JXPathException;
import org.apache.commons.jxpath.Pointer;
import org.apache.commons.jxpath.ri.Compiler;
import org.apache.commons.jxpath.ri.NamespaceResolver;
import org.apache.commons.jxpath.ri.QName;
import org.apache.commons.jxpath.ri.compiler.NodeNameTest;
import org.apache.commons.jxpath.ri.compiler.NodeTest;
import org.apache.commons.jxpath.ri.compiler.NodeTypeTest;
import org.apache.commons.jxpath.ri.model.NodeIterator;
import org.apache.commons.jxpath.ri.model.NodePointer;
import org.w3c.dom.Attr;
import org.w3c.dom.Document;
import org.w3c.dom.Element;
import org.w3c.dom.NamedNodeMap;
import org.w3c.dom.Node;
import org.w3c.dom.NodeList;
import org.w3c.dom.ProcessingInstruction;
import org.apache.commons.jxpath.AbstractFactory;
import static org.junit.jupiter.api.Assertions.*;
import java.util.Locale;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.Timeout;
import org.junit.jupiter.api.Timeout.ThreadMode;
import java.util.concurrent.TimeUnit;
import static org.junit.jupiter.api.Timeout.ThreadMode.SEPARATE_THREAD;
import org.junit.jupiter.api.extension.ExtendWith;
import org.mockito.junit.jupiter.MockitoSettings;
import org.mockito.quality.Strictness;
import org.mockito.InjectMocks;
import org.mockito.InjectMocks;
import org.mockito.Mock;
import org.mockito.Mockito;
import org.mockito.Mockito;
import org.mockito.junit.jupiter.MockitoExtension;
import static org.mockito.Mockito.*;   
@ExtendWith(MockitoExtension.class)
@MockitoSettings(strictness = Strictness.LENIENT)
public class Aster_DOMNodePointer_Test_Passing {
private NamespaceResolver localNamespaceResolver;
@Mock
    private Node node;
@Mock
    private NodePointer nodePointer1;
@Mock
    private NodePointer nodePointer2;
@Mock
    private NamedNodeMap namedNodeMap;
@InjectMocks
    private DOMNodePointer domNodePointer;
@Mock
    private NodeTest nodeTest;
private NodeList nodeList;
private Document document;
@Mock
    private JXPathContext context;
@Mock
    private AbstractFactory abstractFactory;
@Mock
    private NodeIterator nodeIterator;
private final QName qName = new QName("prefix", "localName");
private Locale locale = Locale.ENGLISH;
@Mock
    Element element;
@Mock
    private NodePointer startWith;
@Mock
    private NamespaceResolver namespaceResolver;
@Mock
    private Attr attr;
private final String id = "testId";
private NodePointer nodePointer;
private Node parentNode;
private ProcessingInstruction processingInstruction;
@Mock
    private NamespaceResolver parentNamespaceResolver;
    private String defaultNamespace;
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testCompareChildNodePointers_SameNode() {
        when(nodePointer1.getBaseValue()).thenReturn(node);
        when(nodePointer2.getBaseValue()).thenReturn(node);
        when(node.getAttributes()).thenReturn(namedNodeMap);
        when(namedNodeMap.getLength()).thenReturn(1);
        when(nodePointer1.getBaseValue()).thenReturn(node);
        when(nodePointer2.getBaseValue()).thenReturn(node);
        int result = domNodePointer.compareChildNodePointers(nodePointer1, nodePointer2);
        assertEquals(0, result);
    }
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testCompareChildNodePointers_DifferentNodes() {
        when(nodePointer1.getBaseValue()).thenReturn(node);
        when(nodePointer2.getBaseValue()).thenReturn(node);
        when(node.getAttributes()).thenReturn(namedNodeMap);
        when(namedNodeMap.getLength()).thenReturn(1);
        Node node1 = mock(Node.class);
        Node node2 = mock(Node.class);
        when(nodePointer1.getBaseValue()).thenReturn(node1);
        when(nodePointer2.getBaseValue()).thenReturn(node2);
        when(node.getFirstChild()).thenReturn(node1);
        when(node1.getNextSibling()).thenReturn(node2);
        int result = domNodePointer.compareChildNodePointers(nodePointer1, nodePointer2);
        assertEquals(-1, result);
        result = domNodePointer.compareChildNodePointers(nodePointer2, nodePointer1);
        assertEquals(1, result);
    }
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testSetValueWithTextNode() {
        node = mock(Node.class);
        nodeList = mock(NodeList.class);
        document = mock(Document.class);
        domNodePointer = new DOMNodePointer(node, Locale.getDefault());
        when(node.getNodeType()).thenReturn(Node.TEXT_NODE);
        when(node.getNodeValue()).thenReturn("original");
        when(node.getParentNode()).thenReturn(node);
        when(node.getOwnerDocument()).thenReturn(document);
        String newValue = "new value";
        domNodePointer.setValue(newValue);
        verify(node).setNodeValue(newValue);
    }
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testSetValueWithEmptyStringInTextNode() {
        node = mock(Node.class);
        nodeList = mock(NodeList.class);
        document = mock(Document.class);
        domNodePointer = new DOMNodePointer(node, Locale.getDefault());
        when(node.getNodeType()).thenReturn(Node.TEXT_NODE);
        when(node.getParentNode()).thenReturn(node);
        String newValue = "";
        domNodePointer.setValue(newValue);
        verify(node.getParentNode()).removeChild(node);
    }
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testIsCollection() {
        // Assuming the simplest constructor will suffice for this test
        domNodePointer = new DOMNodePointer(node, locale);
        // Since isCollection method in DOMNodePointer always returns false
        // we are testing this constant behavior.
        assertFalse(domNodePointer.isCollection(), "DOMNodePointer should not be a collection");
    }
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testGetImmediateNode() {
        // Assuming the constructor that just takes a Node and a Locale is the one we're testing
        domNodePointer = new DOMNodePointer(node, Locale.getDefault());
        // Since node is a mocked field, we need to define its behavior if required
        // For this test, we're assuming the node itself doesn't need any specific mocked behavior
        // Execute the method being tested
        Object result = domNodePointer.getImmediateNode();
        // Verify the result
        assertEquals(node, result, "The returned node should be the same as the mocked node");
    }
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
public void testIsCollectionReturnsFalse_fdpS0() {
    Node node = mock(Node.class);
    Locale locale = Locale.getDefault();
    DOMNodePointer domNodePointer = new DOMNodePointer(node, locale);
    assertFalse(domNodePointer.isCollection());
}
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testFindEnclosingAttribute_NoElementNode() {
        when(node.getNodeType()).thenReturn(Node.ELEMENT_NODE);
        when(element.getNodeType()).thenReturn(Node.ELEMENT_NODE);
        // Setup the node hierarchy and responses
        when(node.getNodeType()).thenReturn(Node.TEXT_NODE);
        when(node.getParentNode()).thenReturn(null);
        // Call the method under test
        String result = DOMNodePointer.findEnclosingAttribute(node, "targetAttr");
        // Assertions
        assertNull(result, "The result should be null when no element node is in the hierarchy.");
    }
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
public void testHashCodeConsistency_GHQq0() {
    Locale locale = new Locale("en", "US");
    DOMNodePointer domNodePointer = new DOMNodePointer(node, locale);
    int expectedHashCode = node.hashCode();
    int actualHashCode = domNodePointer.hashCode();
    assertEquals(expectedHashCode, actualHashCode);
}
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
public void testAttributeIterator_tAHW0() {
    Node node = mock(Node.class);
    Locale locale = Locale.getDefault();
    QName qName = new QName("testPrefix", "testLocalName");
    DOMNodePointer domNodePointer = new DOMNodePointer(node, locale);
    NodeIterator result = domNodePointer.attributeIterator(qName);
    assertNotNull(result);
    assertTrue(result instanceof DOMAttributeIterator);
}
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testGetLength() throws Exception {
        // Initialize DOMNodePointer with mocked Node and Locale
        domNodePointer = new DOMNodePointer(node, locale);
        // Since getLength is expected to always return 1, we assert that.
        assertEquals(1, domNodePointer.getLength(), "The length should always be 1.");
    }
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testGetNameForElementNode_xfRW0() {
        Element element = mock(Element.class);
        when(element.getNodeType()).thenReturn(Node.ELEMENT_NODE);
        when(element.getPrefix()).thenReturn("prefix");
        when(element.getLocalName()).thenReturn("localName");
        DOMNodePointer pointer = new DOMNodePointer(element, Locale.getDefault());
        QName result = pointer.getName();
        assertEquals("prefix", result.getPrefix());
        assertEquals("localName", result.getName());
    }
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testGetNameForProcessingInstructionNode_yOnL1() {
        ProcessingInstruction pi = mock(ProcessingInstruction.class);
        when(pi.getNodeType()).thenReturn(Node.PROCESSING_INSTRUCTION_NODE);
        when(pi.getTarget()).thenReturn("target");
        DOMNodePointer pointer = new DOMNodePointer(pi, Locale.getDefault());
        QName result = pointer.getName();
        assertNull(result.getPrefix());
        assertEquals("target", result.getName());
    }
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testGetNameForUnsupportedNodeType_SmZB2() {
        Node node = mock(Node.class);
        when(node.getNodeType()).thenReturn(Node.TEXT_NODE); // A node type that is not supported by getName
        DOMNodePointer pointer = new DOMNodePointer(node, Locale.getDefault());
        QName result = pointer.getName();
        assertNull(result.getPrefix());
        assertNull(result.getName());
    }
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testNamespaceIterator() throws Exception {
        // Assuming Locale and id are not significant for the namespaceIterator method
        domNodePointer = new DOMNodePointer(node, Locale.getDefault());
        NodeIterator result = domNodePointer.namespaceIterator();
        assertTrue(result instanceof DOMNamespaceIterator, "The returned object should be an instance of DOMNamespaceIterator");
    }
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
public void testGetLengthReturnsOne_RIZv0() {
    Node node = mock(Node.class);
    Locale locale = Locale.getDefault();
    DOMNodePointer domNodePointer = new DOMNodePointer(node, locale);
    int length = domNodePointer.getLength();
    assertEquals(1, length);
}
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testIsLeaf_WhenNodeHasNoChildNodes_ShouldReturnTrue() throws Exception {
        // Node and DOMNodePointer setup via Mockito annotations
        // Arrange
        when(node.hasChildNodes()).thenReturn(false);
        // Act
        boolean result = domNodePointer.isLeaf();
        // Assert
        assertTrue(result, "DOMNodePointer should be a leaf when its node has no child nodes.");
    }
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
public void testNamespaceIterator_sSMz0() {
    Node node = mock(Node.class);
    Locale locale = Locale.getDefault();
    DOMNodePointer domNodePointer = new DOMNodePointer(node, locale);
    NodeIterator result = domNodePointer.namespaceIterator();
    assertNotNull(result);
    assertTrue(result instanceof DOMNamespaceIterator);
}
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testEquals_SameObject() {
        domNodePointer = new DOMNodePointer(node, Locale.getDefault());
        assertTrue(domNodePointer.equals(domNodePointer), "A DOMNodePointer should be equal to itself.");
    }
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testEquals_Null() {
        domNodePointer = new DOMNodePointer(node, Locale.getDefault());
        assertFalse(domNodePointer.equals(null), "A DOMNodePointer should not be equal to null.");
    }
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testEquals_DifferentClass() {
        domNodePointer = new DOMNodePointer(node, Locale.getDefault());
        Object differentClassObject = new Object();
        assertFalse(domNodePointer.equals(differentClassObject), "A DOMNodePointer should not be equal to an object of a different class.");
    }
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testEquals_SameNode() {
        domNodePointer = new DOMNodePointer(node, Locale.getDefault());
        DOMNodePointer anotherPointerWithSameNode = new DOMNodePointer(node, Locale.getDefault());
        assertTrue(domNodePointer.equals(anotherPointerWithSameNode), "Two DOMNodePointers with the same Node should be equal.");
    }
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testEquals_DifferentNode() {
        domNodePointer = new DOMNodePointer(node, Locale.getDefault());
        Node anotherNode = mock(Node.class);
        DOMNodePointer anotherPointerWithDifferentNode = new DOMNodePointer(anotherNode, Locale.getDefault());
        assertFalse(domNodePointer.equals(anotherPointerWithDifferentNode), "Two DOMNodePointers with different Nodes should not be equal.");
    }
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testGetLocalName_WithLocalName() throws Exception {
        // Mock setup is already handled by annotations
        // Setup
        String expectedLocalName = "localName";
        when(node.getLocalName()).thenReturn(expectedLocalName);
        // Execute
        String result = DOMNodePointer.getLocalName(node);
        // Verify
        assertEquals(expectedLocalName, result, "The local name should be returned when it is not null.");
    }
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testGetLocalName_WithOnlyQualifiedName() throws Exception {
        // Mock setup is already handled by annotations
        // Setup
        when(node.getLocalName()).thenReturn(null);
        String qualifiedName = "prefix:localPart";
        when(node.getNodeName()).thenReturn(qualifiedName);
        // Execute
        String result = DOMNodePointer.getLocalName(node);
        // Verify
        assertEquals("localPart", result, "The local part of the qualified name should be returned when local name is null.");
    }
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testGetLocalName_WithNoColonInQualifiedName() throws Exception {
        // Mock setup is already handled by annotations
        // Setup
        when(node.getLocalName()).thenReturn(null);
        String nodeName = "nodeName";
        when(node.getNodeName()).thenReturn(nodeName);
        // Execute
        String result = DOMNodePointer.getLocalName(node);
        // Verify
        assertEquals(nodeName, result, "The node name should be returned when there is no colon in the qualified name.");
    }
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testRemove_ThrowsExceptionWhenNodeIsRoot() {
        domNodePointer = new DOMNodePointer(node, Locale.getDefault());
        when(node.getParentNode()).thenReturn(null);
        Exception exception = assertThrows(JXPathException.class, () -> {
            domNodePointer.remove();
        });
        assertEquals("Cannot remove root DOM node", exception.getMessage());
    }
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testIsLanguage_WhenCurrentLanguageIsNull_ShouldDelegateToSuper() {
        domNodePointer = new DOMNodePointer(node, Locale.ENGLISH);
        // Setup
        DOMNodePointer spyDomNodePointer = spy(domNodePointer);
        doReturn(null).when(spyDomNodePointer).getLanguage();
        doReturn(true).when(spyDomNodePointer).isLanguage("EN");
        // Execute
        boolean result = spyDomNodePointer.isLanguage("EN");
        // Verify
        assertTrue(result);
        verify(spyDomNodePointer).isLanguage("EN");
    }
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testIsLanguage_WhenCurrentLanguageIsNotNull_ShouldMatchLanguageCaseInsensitively() {
        domNodePointer = new DOMNodePointer(node, Locale.ENGLISH);
        // Setup
        DOMNodePointer spyDomNodePointer = spy(domNodePointer);
        doReturn("en-US").when(spyDomNodePointer).getLanguage();
        // Execute & Verify
        assertTrue(spyDomNodePointer.isLanguage("en"));
        assertFalse(spyDomNodePointer.isLanguage("fr"));
    }
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testGetPrefix_WithPrefix() {
        domNodePointer = new DOMNodePointer(node, null);
        // Setup
        when(node.getPrefix()).thenReturn("ns");
        when(node.getNodeName()).thenReturn("ns:Element");
        // Execute
        String result = DOMNodePointer.getPrefix(node);
        // Verify
        assertEquals("ns", result);
    }
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testGetPrefix_WithColonInNameButNoPrefix() {
        domNodePointer = new DOMNodePointer(node, null);
        // Setup
        when(node.getPrefix()).thenReturn(null);
        when(node.getNodeName()).thenReturn("ns:Element");
        // Execute
        String result = DOMNodePointer.getPrefix(node);
        // Verify
        assertEquals("ns", result);
    }
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testGetPrefix_NoColonInName() {
        domNodePointer = new DOMNodePointer(node, null);
        // Setup
        when(node.getPrefix()).thenReturn(null);
        when(node.getNodeName()).thenReturn("Element");
        // Execute
        String result = DOMNodePointer.getPrefix(node);
        // Verify
        assertNull(result);
    }
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testNode_WithNullNodeTest_ShouldReturnTrue() {
        node = mock(Node.class);
        nodeTest = mock(NodeTest.class); // Generic mock, will be cast in specific tests
        assertTrue(DOMNodePointer.testNode(node, null));
    }
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testNode_WithNodeNameTestAndElementNode_ShouldReturnTrue() {
        node = mock(Node.class);
        nodeTest = mock(NodeTest.class); // Generic mock, will be cast in specific tests
        NodeNameTest nodeNameTest = mock(NodeNameTest.class);
        QName qName = mock(QName.class);
        when(node.getNodeType()).thenReturn(Node.ELEMENT_NODE);
        when(nodeNameTest.getNodeName()).thenReturn(qName);
        when(nodeNameTest.isWildcard()).thenReturn(true);
        when(nodeNameTest.getNamespaceURI()).thenReturn(null);
        when(qName.getPrefix()).thenReturn(null);
        assertTrue(DOMNodePointer.testNode(node, nodeNameTest));
    }
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testNode_WithNodeNameTestAndNonElementNode_ShouldReturnFalse() {
        node = mock(Node.class);
        nodeTest = mock(NodeTest.class); // Generic mock, will be cast in specific tests
        NodeNameTest nodeNameTest = mock(NodeNameTest.class);
        when(node.getNodeType()).thenReturn(Node.TEXT_NODE);
        assertFalse(DOMNodePointer.testNode(node, nodeNameTest));
    }
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testNode_WithNodeTypeTestAndMatchingNodeType_ShouldReturnTrue() {
        node = mock(Node.class);
        nodeTest = mock(NodeTest.class); // Generic mock, will be cast in specific tests
        NodeTypeTest nodeTypeTest = mock(NodeTypeTest.class);
        when(node.getNodeType()).thenReturn(Node.TEXT_NODE);
        when(nodeTypeTest.getNodeType()).thenReturn(Compiler.NODE_TYPE_TEXT);
        assertTrue(DOMNodePointer.testNode(node, nodeTypeTest));
    }
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testNode_WithNodeTypeTestAndNonMatchingNodeType_ShouldReturnFalse() {
        node = mock(Node.class);
        nodeTest = mock(NodeTest.class); // Generic mock, will be cast in specific tests
        NodeTypeTest nodeTypeTest = mock(NodeTypeTest.class);
        when(node.getNodeType()).thenReturn(Node.ELEMENT_NODE);
        when(nodeTypeTest.getNodeType()).thenReturn(Compiler.NODE_TYPE_COMMENT);
        assertFalse(DOMNodePointer.testNode(node, nodeTypeTest));
    }
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testAsPathWithDocumentNode() {
        node = mock(Node.class);
        parentNode = mock(Node.class);
        processingInstruction = mock(ProcessingInstruction.class);
        domNodePointer = new DOMNodePointer(node, null);
        when(node.getNodeType()).thenReturn(Node.DOCUMENT_NODE);
        String path = domNodePointer.asPath();
        assertEquals("", path);
    }
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testGetBaseValue() {
        domNodePointer = new DOMNodePointer(node, Locale.getDefault());
        assertEquals(node, domNodePointer.getBaseValue(), "The base value should be the mocked Node object");
    }
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testIsActual() throws Exception {
        Node node = mock(Node.class); // Assuming Node is an interface or class you can mock
        Locale locale = Locale.ENGLISH; // Example locale
        domNodePointer = new DOMNodePointer(node, locale);
        // Since isActual method returns true, we assert that it indeed returns true
        assertTrue(domNodePointer.isActual());
    }
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
public void testIsActual_ioOD0() {
    Node node = mock(Node.class);
    Locale locale = Locale.getDefault();
    DOMNodePointer domNodePointer = new DOMNodePointer(node, locale);
    assertTrue(domNodePointer.isActual());
}
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
public void testAsPathWithTextNode_sqSE2() {
    Node node = mock(Node.class);
    when(node.getNodeType()).thenReturn(Node.TEXT_NODE);
    DOMNodePointer pointer = new DOMNodePointer(node, Locale.getDefault(), null);
    String result = pointer.asPath();
    assertEquals("/text()[1]", result);
}
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
public void testAsPathWithCDATANode_pMim3() {
    Node node = mock(Node.class);
    when(node.getNodeType()).thenReturn(Node.CDATA_SECTION_NODE);
    DOMNodePointer pointer = new DOMNodePointer(node, Locale.getDefault(), null);
    String result = pointer.asPath();
    assertEquals("/text()[1]", result);
}
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
public void testAsPathWithProcessingInstructionNode_LIPP4() {
    ProcessingInstruction pi = mock(ProcessingInstruction.class);
    when(pi.getNodeType()).thenReturn(Node.PROCESSING_INSTRUCTION_NODE);
    when(pi.getTarget()).thenReturn("targetPI");
    DOMNodePointer pointer = new DOMNodePointer(pi, Locale.getDefault(), null);
    String result = pointer.asPath();
    assertEquals("/processing-instruction('targetPI')[1]", result);
}
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
public void testAsPathWithDocumentNode_gdKt5() {
    Node node = mock(Node.class);
    when(node.getNodeType()).thenReturn(Node.DOCUMENT_NODE);
    DOMNodePointer pointer = new DOMNodePointer(node, Locale.getDefault(), null);
    String result = pointer.asPath();
    assertEquals("", result);
}
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
public void testAsPathWithElementNodeWithId_JqKN6() {
    Node node = mock(Element.class);
    when(node.getNodeType()).thenReturn(Node.ELEMENT_NODE);
    DOMNodePointer pointer = new DOMNodePointer(node, Locale.getDefault(), "uniqueId");
    String result = pointer.asPath();
    assertEquals("id('uniqueId')", result);
}
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
public void testAsPathWithMultiplePIs_Sxxn7() {
    ProcessingInstruction pi = mock(ProcessingInstruction.class);
    when(pi.getNodeType()).thenReturn(Node.PROCESSING_INSTRUCTION_NODE);
    when(pi.getTarget()).thenReturn("targetPI");
    Node previousPI = mock(ProcessingInstruction.class);
    when(previousPI.getNodeType()).thenReturn(Node.PROCESSING_INSTRUCTION_NODE);
    when(((ProcessingInstruction) previousPI).getTarget()).thenReturn("targetPI");
    when(pi.getPreviousSibling()).thenReturn(previousPI);
    when(previousPI.getPreviousSibling()).thenReturn(null);
    DOMNodePointer pointer = new DOMNodePointer(pi, Locale.getDefault(), null);
    String result = pointer.asPath();
    assertEquals("/processing-instruction('targetPI')[2]", result);
}
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testCompareChildNodePointers_DifferentNodes_1() {
        when(nodePointer1.getBaseValue()).thenReturn(node);
        when(nodePointer2.getBaseValue()).thenReturn(node);
        when(node.getAttributes()).thenReturn(namedNodeMap);
        when(namedNodeMap.getLength()).thenReturn(1);
        Node node1 = mock(Node.class);
        Node node2 = mock(Node.class);
        when(nodePointer1.getBaseValue()).thenReturn(node1);
        when(nodePointer2.getBaseValue()).thenReturn(node2);
        when(node.getFirstChild()).thenReturn(node1);
        when(node1.getNextSibling()).thenReturn(node2);
        int result = domNodePointer.compareChildNodePointers(nodePointer1, nodePointer2);
        result = domNodePointer.compareChildNodePointers(nodePointer2, nodePointer1);
        assertEquals(0, result);}
@Test
@Timeout(value =0, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testCompareChildNodePointers_DifferentNodes_2() {
        when(nodePointer1.getBaseValue()).thenReturn(node);
        when(nodePointer2.getBaseValue()).thenReturn(node);
        when(node.getAttributes()).thenReturn(namedNodeMap);
        when(namedNodeMap.getLength()).thenReturn(1);
        Node node1 = mock(Node.class);
        Node node2 = mock(Node.class);
        when(nodePointer1.getBaseValue()).thenReturn(node1);
        when(nodePointer2.getBaseValue()).thenReturn(node2);
        when(node.getFirstChild()).thenReturn(node1);
        when(node1.getNextSibling()).thenReturn(node2);
        int result = domNodePointer.compareChildNodePointers(nodePointer1, nodePointer2);
        result = domNodePointer.compareChildNodePointers(nodePointer2, nodePointer1);
        assertEquals(1, result);}
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
public void testAttributeIterator_tAHW0_1() {
    Node node = mock(Node.class);
    Locale locale = Locale.getDefault();
    QName qName = new QName("testPrefix", "testLocalName");
    DOMNodePointer domNodePointer = new DOMNodePointer(node, locale);
    NodeIterator result = domNodePointer.attributeIterator(qName);
    assertNotNull(result);}
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
public void testAttributeIterator_tAHW0_2() {
    Node node = mock(Node.class);
    Locale locale = Locale.getDefault();
    QName qName = new QName("testPrefix", "testLocalName");
    DOMNodePointer domNodePointer = new DOMNodePointer(node, locale);
    NodeIterator result = domNodePointer.attributeIterator(qName);
    assertTrue(result instanceof DOMAttributeIterator);}
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testGetNameForElementNode_xfRW0_1() {
        Element element = mock(Element.class);
        when(element.getNodeType()).thenReturn(Node.ELEMENT_NODE);
        when(element.getPrefix()).thenReturn("prefix");
        when(element.getLocalName()).thenReturn("localName");
        DOMNodePointer pointer = new DOMNodePointer(element, Locale.getDefault());
        QName result = pointer.getName();
        assertEquals("prefix", result.getPrefix());}
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testGetNameForElementNode_xfRW0_2() {
        Element element = mock(Element.class);
        when(element.getNodeType()).thenReturn(Node.ELEMENT_NODE);
        when(element.getPrefix()).thenReturn("prefix");
        when(element.getLocalName()).thenReturn("localName");
        DOMNodePointer pointer = new DOMNodePointer(element, Locale.getDefault());
        QName result = pointer.getName();
        assertEquals("localName", result.getName());}
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testGetNameForProcessingInstructionNode_yOnL1_1() {
        ProcessingInstruction pi = mock(ProcessingInstruction.class);
        when(pi.getNodeType()).thenReturn(Node.PROCESSING_INSTRUCTION_NODE);
        when(pi.getTarget()).thenReturn("target");
        DOMNodePointer pointer = new DOMNodePointer(pi, Locale.getDefault());
        QName result = pointer.getName();
        assertNull(result.getPrefix());}
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testGetNameForProcessingInstructionNode_yOnL1_2() {
        ProcessingInstruction pi = mock(ProcessingInstruction.class);
        when(pi.getNodeType()).thenReturn(Node.PROCESSING_INSTRUCTION_NODE);
        when(pi.getTarget()).thenReturn("target");
        DOMNodePointer pointer = new DOMNodePointer(pi, Locale.getDefault());
        QName result = pointer.getName();
        assertEquals("target", result.getName());}
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testGetNameForUnsupportedNodeType_SmZB2_1() {
        Node node = mock(Node.class);
        when(node.getNodeType()).thenReturn(Node.TEXT_NODE); // A node type that is not supported by getName
        DOMNodePointer pointer = new DOMNodePointer(node, Locale.getDefault());
        QName result = pointer.getName();
        assertNull(result.getPrefix());}
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testGetNameForUnsupportedNodeType_SmZB2_2() {
        Node node = mock(Node.class);
        when(node.getNodeType()).thenReturn(Node.TEXT_NODE); // A node type that is not supported by getName
        DOMNodePointer pointer = new DOMNodePointer(node, Locale.getDefault());
        QName result = pointer.getName();
        assertNull(result.getName());}
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testIsLeaf_WhenNodeHasChildNodes_ShouldReturnFalse_fid1() throws Exception {
        // Node and DOMNodePointer setup via Mockito annotations
        // Arrange
        when(node.hasChildNodes()).thenReturn(true);
        // Act
        boolean result = domNodePointer.isLeaf();
        // Assert
        assertTrue(result, "DOMNodePointer should not be a leaf when its node has child nodes.");
    }
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
public void testNamespaceIterator_sSMz0_1() {
    Node node = mock(Node.class);
    Locale locale = Locale.getDefault();
    DOMNodePointer domNodePointer = new DOMNodePointer(node, locale);
    NodeIterator result = domNodePointer.namespaceIterator();
    assertNotNull(result);}
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
public void testNamespaceIterator_sSMz0_2() {
    Node node = mock(Node.class);
    Locale locale = Locale.getDefault();
    DOMNodePointer domNodePointer = new DOMNodePointer(node, locale);
    NodeIterator result = domNodePointer.namespaceIterator();
    assertTrue(result instanceof DOMNamespaceIterator);}
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testGetValue_WhenNodeIsCommentNodeAndDataIsNotNull_ShouldReturnTrimmedData_fid1() {
}
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testRemove_ThrowsExceptionWhenNodeIsRoot_1() {
        domNodePointer = new DOMNodePointer(node, Locale.getDefault());
        when(node.getParentNode()).thenReturn(null);
        Exception exception = assertThrows(JXPathException.class, () -> {
            domNodePointer.remove();
        });}
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testIsLanguage_WhenCurrentLanguageIsNotNull_ShouldMatchLanguageCaseInsensitively_1() {
        domNodePointer = new DOMNodePointer(node, Locale.ENGLISH);
        // Setup
        DOMNodePointer spyDomNodePointer = spy(domNodePointer);
        doReturn("en-US").when(spyDomNodePointer).getLanguage();
        // Execute & Verify
        assertTrue(spyDomNodePointer.isLanguage("en"));}
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testIsLanguage_WhenCurrentLanguageIsNotNull_ShouldMatchLanguageCaseInsensitively_2() {
        domNodePointer = new DOMNodePointer(node, Locale.ENGLISH);
        // Setup
        DOMNodePointer spyDomNodePointer = spy(domNodePointer);
        doReturn("en-US").when(spyDomNodePointer).getLanguage();
        // Execute & Verify
        assertFalse(spyDomNodePointer.isLanguage("fr"));}
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testNamespacePointer_1() {
        domNodePointer = new DOMNodePointer(node, locale);
        String prefix = "testPrefix";
        NodePointer result = domNodePointer.namespacePointer(prefix);
        assertNotNull(result);}
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testNamespacePointer_2() {
        domNodePointer = new DOMNodePointer(node, locale);
        String prefix = "testPrefix";
        NodePointer result = domNodePointer.namespacePointer(prefix);
        assertTrue(result instanceof NamespacePointer);}
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
public void testNamespacePointer_KdfR0_1() {
    Node node = mock(Node.class);
    Locale locale = Locale.getDefault();
    DOMNodePointer domNodePointer = new DOMNodePointer(node, locale);
    String prefix = "testPrefix";
    NodePointer result = domNodePointer.namespacePointer(prefix);
    assertNotNull(result);}
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
public void testNamespacePointer_KdfR0_2() {
    Node node = mock(Node.class);
    Locale locale = Locale.getDefault();
    DOMNodePointer domNodePointer = new DOMNodePointer(node, locale);
    String prefix = "testPrefix";
    NodePointer result = domNodePointer.namespacePointer(prefix);
    assertTrue(result instanceof NamespacePointer);}
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
public void testAttributeIterator_aNWO0() throws Exception {
    domNodePointer = new DOMNodePointer(node, locale);
    QName qName = new QName("testPrefix", "testLocalName");
    NodeIterator result = domNodePointer.attributeIterator(qName);
    DOMAttributeIterator iterator = (DOMAttributeIterator) result;
}
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
public void testChildIterator_BfQV0_LFPI0() {
    Node node = mock(Node.class);
    Locale locale = Locale.getDefault();
    DOMNodePointer domNodePointer = new DOMNodePointer(node, locale);
    NodeTest nodeTest = new NodeTypeTest(Node.ELEMENT_NODE);
    boolean reverse = false;
    NodePointer startWith = null;
    NodeIterator result = domNodePointer.childIterator(nodeTest, reverse, startWith);
    assertNotNull(result);
}
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
public void testGetPointerByID_NodeIsNotDocument_oOIY2_zZlB0() {
    Node node = Mockito.mock(Node.class);
    Document document = Mockito.mock(Document.class);
    Element element = Mockito.mock(Element.class);
    Mockito.when(node.getNodeType()).thenReturn(Node.ELEMENT_NODE);
    Mockito.when(node.getOwnerDocument()).thenReturn(document);
    Mockito.when(document.getElementById("testID")).thenReturn(element);
    DOMNodePointer domNodePointer = new DOMNodePointer(node, Locale.ENGLISH);
    JXPathContext context = Mockito.mock(JXPathContext.class);
    Pointer result = domNodePointer.getPointerByID(context, "testID");
    assertTrue(result instanceof DOMNodePointer);
}
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
public void testAsPathWithTextNode_YoQA0() {
    Node node = mock(Node.class);
    DOMNodePointer domNodePointer = new DOMNodePointer(node, Locale.getDefault());
    when(node.getNodeType()).thenReturn(Node.TEXT_NODE);
    when(node.getParentNode()).thenReturn(node);
    when(node.getPreviousSibling()).thenReturn(null);
    String path = domNodePointer.asPath();
    assertEquals("/text()[1]", path);
}
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
public void testAsPathWithCDATASectionNode_pFye0() {
    Node node = mock(Node.class);
    DOMNodePointer domNodePointer = new DOMNodePointer(node, Locale.getDefault());
    when(node.getNodeType()).thenReturn(Node.CDATA_SECTION_NODE);
    when(node.getParentNode()).thenReturn(node); // Simulate the parent node as itself for simplicity
    String path = domNodePointer.asPath();
    assertEquals("/text()[1]", path);
}
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
public void testAsPathWithTextNode_EPOZ2_Nrxa0() {
    Node node = Mockito.mock(Node.class);
    when(node.getNodeType()).thenReturn(Node.TEXT_NODE);
    when(node.getNodeValue()).thenReturn("Sample text");
    DOMNodePointer pointer = new DOMNodePointer(node, Locale.getDefault());
    assertEquals("/text()[1]", pointer.asPath());
}
}