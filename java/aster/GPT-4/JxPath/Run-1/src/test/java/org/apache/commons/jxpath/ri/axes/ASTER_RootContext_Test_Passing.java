/**
 * Generated by Aster
 */
package org.apache.commons.jxpath.ri.axes;
import org.apache.commons.jxpath.Function;
import org.apache.commons.jxpath.JXPathContext;
import org.apache.commons.jxpath.NodeSet;
import org.apache.commons.jxpath.ri.EvalContext;
import org.apache.commons.jxpath.ri.JXPathContextReferenceImpl;
import org.apache.commons.jxpath.ri.QName;
import org.apache.commons.jxpath.ri.model.NodePointer;
import org.apache.commons.jxpath.ri.model.dom.DOMNodePointer;
import org.apache.commons.jxpath.ri.model.VariablePointer;
import static org.junit.jupiter.api.Assertions.*;
import java.util.Locale;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.Timeout;
import org.junit.jupiter.api.Timeout.ThreadMode;
import java.util.concurrent.TimeUnit;
import static org.junit.jupiter.api.Timeout.ThreadMode.SEPARATE_THREAD;
import org.junit.jupiter.api.extension.ExtendWith;
import org.mockito.junit.jupiter.MockitoSettings;
import org.mockito.quality.Strictness;
import org.mockito.InjectMocks;
import org.mockito.InjectMocks;
import org.mockito.Mock;
import org.mockito.junit.jupiter.MockitoExtension;
import static org.mockito.Mockito.*;
import java.lang.reflect.Field;   
@ExtendWith(MockitoExtension.class)
@MockitoSettings(strictness = Strictness.LENIENT)
public class Aster_RootContext_Test_Passing {
@Mock
    private JXPathContextReferenceImpl jxpathContext;
@Mock
    private DOMNodePointer pointer;
@InjectMocks
    private RootContext rootContext;
@Mock
    private DOMNodePointer domNodePointer;
@Mock
    private EvalContext expectedEvalContext;
@Mock
    private NodePointer mockNodePointer;
@Mock
    private NodeSet mockNodeSet;
@Mock
    private JXPathContextReferenceImpl mockJXPathContextReferenceImpl;
@Mock
    private DOMNodePointer mockDOMNodePointer;
@Mock
    private VariablePointer variablePointer;
@Mock
    private EvalContext evalContext;
private static final int MAX_REGISTER = 4;
private Object[] registers = new Object[MAX_REGISTER];
    private int availableRegister = 0;
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testSetPosition() throws Exception {
        // Initialization of mocks is handled by Mockito
        // Test that setPosition throws UnsupportedOperationException
        assertThrows(UnsupportedOperationException.class, () -> rootContext.setPosition(1));
    }
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testGetJXPathContext() {
        rootContext = new RootContext(jxpathContext, domNodePointer);
        JXPathContext result = rootContext.getJXPathContext();
        assertSame(jxpathContext, result, "The returned JXPathContext should be the same as the one passed to the constructor");
    }
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testGetAbsoluteRootContext() throws Exception {
        // Setup the mocks and the object under test
        when(jxpathContext.getAbsoluteRootContext()).thenReturn(expectedEvalContext);
        rootContext = new RootContext(jxpathContext, null);
        // Act
        EvalContext actualEvalContext = rootContext.getAbsoluteRootContext();
        // Assert
        assertSame(expectedEvalContext, actualEvalContext, "The returned EvalContext should be the same as the mocked one");
        verify(jxpathContext, times(1)).getAbsoluteRootContext();
    }
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testNextNode() throws Exception {
        // Mock dependencies
        JXPathContextReferenceImpl jxpathContext = mock(JXPathContextReferenceImpl.class);
        DOMNodePointer pointer = mock(DOMNodePointer.class);
        // Initialize RootContext with mocked dependencies
        rootContext = new RootContext(jxpathContext, pointer);
        // Test that nextNode throws UnsupportedOperationException
        assertThrows(UnsupportedOperationException.class, () -> rootContext.nextNode());
    }
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testGetValue_1() throws Exception {
        // Setup the RootContext with mocked JXPathContextReferenceImpl and DOMNodePointer
        rootContext = new RootContext(jxpathContext, domNodePointer);
        // Assuming there's a way to set the pointer, since it's private and no setter is shown
        // This might require adjusting the actual RootContext class to allow injection of NodePointer
        when(domNodePointer.getValue()).thenReturn(pointer);
        // Act
        Object result = rootContext.getValue();
        // Assert
        assertNotNull(result, "The result should not be null.");}
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testNextSetThrowsUnsupportedOperationException() {
        // Initialization of RootContext with mocks is handled by Mockito's @InjectMocks
        // Test that the nextSet method throws UnsupportedOperationException
        assertThrows(UnsupportedOperationException.class, () -> rootContext.nextSet());
    }
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testGetVariableContext_1() throws Exception {
        when(jxpathContext.getVariablePointer(any(QName.class))).thenReturn(variablePointer);
        rootContext = new RootContext(jxpathContext, domNodePointer);
        QName variableName = new QName("testVariable");
        InitialContext expectedContext = new InitialContext(new RootContext(jxpathContext, variablePointer));
        EvalContext resultContext = rootContext.getVariableContext(variableName);
        assertNotNull(resultContext, "The result context should not be null");}
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testGetVariableContext_2() throws Exception {
        when(jxpathContext.getVariablePointer(any(QName.class))).thenReturn(variablePointer);
        rootContext = new RootContext(jxpathContext, domNodePointer);
        QName variableName = new QName("testVariable");
        InitialContext expectedContext = new InitialContext(new RootContext(jxpathContext, variablePointer));
        EvalContext resultContext = rootContext.getVariableContext(variableName);
        assertTrue(resultContext instanceof InitialContext, "The result context should be an instance of InitialContext");}
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
public void testNextSetThrowsUnsupportedOperationException_EivW0() {
    JXPathContextReferenceImpl jxPathContextRefImpl = new JXPathContextReferenceImpl(null, new Object(), null);
    DOMNodePointer domNodePointer = new DOMNodePointer(null, Locale.getDefault());
    RootContext rootContext = new RootContext(jxPathContextRefImpl, domNodePointer);
    assertThrows(UnsupportedOperationException.class, () -> rootContext.nextSet());
}
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testSetRegisteredValue_StoresValuesCorrectly_1() {
        JXPathContextReferenceImpl mockJXPathContextRef = mock(JXPathContextReferenceImpl.class);
        DOMNodePointer mockDOMNodePointer = mock(DOMNodePointer.class);
        rootContext = new RootContext(mockJXPathContextRef, mockDOMNodePointer);
        // Test adding values within the limit
        assertEquals(0, rootContext.setRegisteredValue("Value 1"), "First value should be stored at index 0");}
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testSetRegisteredValue_ReturnsErrorOnExceedingLimit() {
        JXPathContextReferenceImpl mockJXPathContextRef = mock(JXPathContextReferenceImpl.class);
        DOMNodePointer mockDOMNodePointer = mock(DOMNodePointer.class);
        rootContext = new RootContext(mockJXPathContextRef, mockDOMNodePointer);
        // Fill the register
        rootContext.setRegisteredValue("Value 1");
        rootContext.setRegisteredValue("Value 2");
        rootContext.setRegisteredValue("Value 3");
        rootContext.setRegisteredValue("Value 4");
        // Try adding another value
        assertEquals(-1, rootContext.setRegisteredValue("Value 5"), "Should return -1 when trying to add beyond capacity");
    }
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testGetRegisteredValue_ValidIndex_ReturnsCorrectObject_1() throws Exception {
        // Initialize the registers array with some test data
        registers[0] = "First";
        registers[1] = "Second";
        registers[2] = "Third";
        registers[3] = "Fourth";
        // Create a RootContext with mocked dependencies
        rootContext = new RootContext(mockJXPathContextReferenceImpl, mockDOMNodePointer);
        // Using reflection to set the private field 'registers'
        java.lang.reflect.Field field = rootContext.getClass().getDeclaredField("registers");
        field.setAccessible(true);
        field.set(rootContext, registers);
        assertEquals("First", rootContext.getRegisteredValue(0), "Should return the first register");}
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testGetRegisteredValue_ValidIndex_ReturnsCorrectObject_2() throws Exception {
        // Initialize the registers array with some test data
        registers[0] = "First";
        registers[1] = "Second";
        registers[2] = "Third";
        registers[3] = "Fourth";
        // Create a RootContext with mocked dependencies
        rootContext = new RootContext(mockJXPathContextReferenceImpl, mockDOMNodePointer);
        // Using reflection to set the private field 'registers'
        java.lang.reflect.Field field = rootContext.getClass().getDeclaredField("registers");
        field.setAccessible(true);
        field.set(rootContext, registers);
        assertEquals("Second", rootContext.getRegisteredValue(1), "Should return the second register");}
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testGetRegisteredValue_ValidIndex_ReturnsCorrectObject_3() throws Exception {
        // Initialize the registers array with some test data
        registers[0] = "First";
        registers[1] = "Second";
        registers[2] = "Third";
        registers[3] = "Fourth";
        // Create a RootContext with mocked dependencies
        rootContext = new RootContext(mockJXPathContextReferenceImpl, mockDOMNodePointer);
        // Using reflection to set the private field 'registers'
        java.lang.reflect.Field field = rootContext.getClass().getDeclaredField("registers");
        field.setAccessible(true);
        field.set(rootContext, registers);
        assertEquals("Third", rootContext.getRegisteredValue(2), "Should return the third register");}
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testGetRegisteredValue_ValidIndex_ReturnsCorrectObject_4() throws Exception {
        // Initialize the registers array with some test data
        registers[0] = "First";
        registers[1] = "Second";
        registers[2] = "Third";
        registers[3] = "Fourth";
        // Create a RootContext with mocked dependencies
        rootContext = new RootContext(mockJXPathContextReferenceImpl, mockDOMNodePointer);
        // Using reflection to set the private field 'registers'
        java.lang.reflect.Field field = rootContext.getClass().getDeclaredField("registers");
        field.setAccessible(true);
        field.set(rootContext, registers);
        assertEquals("Fourth", rootContext.getRegisteredValue(3), "Should return the fourth register");}
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testGetCurrentPosition() throws Exception {
        // Initialization of mocks and inject mocks is handled by Mockito
        // Test that getCurrentPosition throws UnsupportedOperationException
        assertThrows(UnsupportedOperationException.class, () -> rootContext.getCurrentPosition());
    }
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testGetRegisteredValue_ValidIndex_xeYx0() {
        JXPathContextReferenceImpl contextRef = new JXPathContextReferenceImpl(null, new Object(), null);
        DOMNodePointer domNodePointer = new DOMNodePointer(null, null, null);
        RootContext rootContext = new RootContext(contextRef, domNodePointer);
        assertNotNull(rootContext.getRegisteredValue(0));
    }
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
public void testNextNodeUnsupportedOperationException_iLxF0_kgiQ0() {
    JXPathContextReferenceImpl jxPathContextRefImpl = new JXPathContextReferenceImpl(null, new Object(), null);
    DOMNodePointer domNodePointer = new DOMNodePointer(null, Locale.getDefault());
    RootContext rootContext = new RootContext(jxPathContextRefImpl, domNodePointer);
    assertThrows(UnsupportedOperationException.class, () -> rootContext.nextNode());
}
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
public void testGetAbsoluteRootContext_ZzNP0_eSsr0_1() {
    JXPathContextReferenceImpl jxpathContext = new JXPathContextReferenceImpl(null, new Object(), null);
    DOMNodePointer pointer = new DOMNodePointer(null, Locale.getDefault());
    RootContext rootContext = new RootContext(jxpathContext, pointer);
    EvalContext result = rootContext.getAbsoluteRootContext();
    assertNotNull(result);}
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
public void testGetConstantContextWithOtherObject_itMF2_IBfF0_1() {
    JXPathContextReferenceImpl jxpathContext = new JXPathContextReferenceImpl(null, new Object(), null);
    RootContext rootContext = new RootContext(jxpathContext, null);
    String constant = "testString";
    EvalContext result = rootContext.getConstantContext(constant);
    assertTrue(result instanceof InitialContext);}
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
public void testGetConstantContextWithOtherObject_itMF2_IBfF0_2() {
    JXPathContextReferenceImpl jxpathContext = new JXPathContextReferenceImpl(null, new Object(), null);
    RootContext rootContext = new RootContext(jxpathContext, null);
    String constant = "testString";
    EvalContext result = rootContext.getConstantContext(constant);
    assertNotNull(((InitialContext) result).getContextNodePointer());}
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
public void testGetFunction_pdhB0_OdFW0() {
    JXPathContextReferenceImpl parentContext = new JXPathContextReferenceImpl(null, new Object(), null);
    DOMNodePointer pointer = new DOMNodePointer(null, Locale.getDefault());
    RootContext rootContext = new RootContext(parentContext, pointer);
    QName functionName = new QName("testFunction");
}
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
public void testGetFunction_rmkA0() throws Exception {
    rootContext = new RootContext(jxpathContext, domNodePointer);
    QName functionName = new QName("testFunction");
    Object[] parameters = new Object[]{"param1", 123};
    Function expectedFunction = mock(Function.class);
    when(jxpathContext.getFunction(functionName, parameters)).thenReturn(expectedFunction);
    Function result = rootContext.getFunction(functionName, parameters);
    assertNotNull(result, "Function returned should not be null");
    verify(jxpathContext, times(1)).getFunction(functionName, parameters);
}
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
public void testSetRegisteredValue_FirstValue_xGoY0_Edln0() {
    JXPathContextReferenceImpl jxpathContext = new JXPathContextReferenceImpl(null, new Object(), null);
    DOMNodePointer pointer = new DOMNodePointer(null, null, null);
    RootContext rootContext = new RootContext(jxpathContext, pointer);
    int index = rootContext.setRegisteredValue("First Value");
    assertEquals(0, index);
}
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
public void testSetRegisteredValue_SecondValue_Hemb1_pSqw0() {
    JXPathContextReferenceImpl jxpathContext = new JXPathContextReferenceImpl(null, new Object(), null);
    DOMNodePointer pointer = new DOMNodePointer(null, null, null);
    RootContext rootContext = new RootContext(jxpathContext, pointer);
    rootContext.setRegisteredValue("First Value");
    int index = rootContext.setRegisteredValue("Second Value");
    assertEquals(1, index);
}
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
public void testGetRootContext_IQMs0() {
    JXPathContextReferenceImpl jxPathContextRef = new JXPathContextReferenceImpl(null, new Object(), null);
    DOMNodePointer domNodePointer = new DOMNodePointer(null, Locale.getDefault(), null);
    RootContext rootContext = new RootContext(jxPathContextRef, domNodePointer);
    RootContext returnedContext = rootContext.getRootContext();
    assertSame(rootContext, returnedContext, "getRootContext should return the same RootContext instance");
}
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
public void testSetRegisteredValue_NullValue_HgAo3_zhCE0() {
    JXPathContextReferenceImpl jxpathContext = new JXPathContextReferenceImpl(null, new Object(), null);
    DOMNodePointer pointer = new DOMNodePointer(null, null, null);
    RootContext rootContext = new RootContext(jxpathContext, pointer);
    int index = rootContext.setRegisteredValue(null);
    assertEquals(0, index);
}
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
public void testSetRegisteredValue_MaxRegisterLimit_KIwj2_MGvz0() {
    JXPathContextReferenceImpl jxpathContext = new JXPathContextReferenceImpl(null, new Object(), null);
    DOMNodePointer pointer = new DOMNodePointer(null, null, null);
    RootContext rootContext = new RootContext(jxpathContext, pointer);
    for (int i = 0; i < MAX_REGISTER; i++) {
        rootContext.setRegisteredValue("Value " + i);
    }
    int index = rootContext.setRegisteredValue("Overflow Value");
    assertEquals(-1, index);
}
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
public void testGetCurrentPositionThrowsUnsupportedOperationException_lrGz0_mSgG0() {
    JXPathContextReferenceImpl jxPathContextRefImpl = new JXPathContextReferenceImpl(null, new Object(), null);
    DOMNodePointer domNodePointer = new DOMNodePointer(null, Locale.getDefault());
    RootContext rootContext = new RootContext(jxPathContextRefImpl, domNodePointer);
    assertThrows(UnsupportedOperationException.class, rootContext::getCurrentPosition);
}
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
public void testGetRegisteredValue_InvalidIndexNegative_uRPe1_aAvu0() {
    JXPathContextReferenceImpl contextRef = new JXPathContextReferenceImpl(null, new Object(), null);
    DOMNodePointer domNodePointer = new DOMNodePointer(null, null, null);
    RootContext rootContext = new RootContext(contextRef, domNodePointer);
    assertEquals(rootContext.UNKNOWN_VALUE, rootContext.getRegisteredValue(-1));
}
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
public void testGetRootContext_Ecqc0_dRhl0() {
    JXPathContextReferenceImpl jxPathContextRefImpl = new JXPathContextReferenceImpl(null, new Object(), null);
    DOMNodePointer domNodePointer = new DOMNodePointer(null, Locale.getDefault());
    RootContext rootContext = new RootContext(jxPathContextRefImpl, domNodePointer);
    RootContext result = rootContext.getRootContext();
    assertEquals(rootContext, result);
}
@Test
@Timeout(value =0, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testSetRegisteredValue_StoresValuesCorrectly_2_fid1() {
        JXPathContextReferenceImpl mockJXPathContextRef = mock(JXPathContextReferenceImpl.class);
        DOMNodePointer mockDOMNodePointer = mock(DOMNodePointer.class);
        rootContext = new RootContext(mockJXPathContextRef, mockDOMNodePointer);
        // Test adding values within the limit
        assertEquals(1, rootContext.setRegisteredValue("Value 2"), "Second value should be stored at index0");}
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testGetRegisteredValue_InvalidIndex_ReturnsUnknownValue_1_fid1() throws Exception {
        // Initialize the registers array with some test data
        registers[0] = "First";
        registers[1] = "Second";
        registers[2] = "Third";
        registers[3] = "Fourth";
        // Create a RootContext with mocked dependencies
        rootContext = new RootContext(mockJXPathContextReferenceImpl, mockDOMNodePointer);
}
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testSetRegisteredValue_StoresValuesCorrectly() {
        JXPathContextReferenceImpl mockJXPathContextRef = mock(JXPathContextReferenceImpl.class);
        DOMNodePointer mockDOMNodePointer = mock(DOMNodePointer.class);
        rootContext = new RootContext(mockJXPathContextRef, mockDOMNodePointer);
        // Test adding values within the limit
        assertEquals(0, rootContext.setRegisteredValue("Value 1"), "First value should be stored at index 0");
        assertEquals(1, rootContext.setRegisteredValue("Value 2"), "Second value should be stored at index 1");
        assertEquals(2, rootContext.setRegisteredValue("Value 3"), "Third value should be stored at index 2");
        assertEquals(3, rootContext.setRegisteredValue("Value 4"), "Fourth value should be stored at index 3");
    }
}