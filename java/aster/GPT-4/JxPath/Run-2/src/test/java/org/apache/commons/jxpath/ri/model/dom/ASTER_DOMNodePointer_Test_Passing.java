/**
 * Generated by Aster
 */
package org.apache.commons.jxpath.ri.model.dom;
import java.util.Locale;
import org.apache.commons.jxpath.JXPathContext;
import org.apache.commons.jxpath.JXPathException;
import org.apache.commons.jxpath.ri.Compiler;
import org.apache.commons.jxpath.ri.NamespaceResolver;
import org.apache.commons.jxpath.ri.QName;
import org.apache.commons.jxpath.ri.compiler.NodeTest;
import org.apache.commons.jxpath.ri.compiler.NodeTypeTest;
import org.apache.commons.jxpath.ri.model.NodeIterator;
import org.apache.commons.jxpath.ri.model.NodePointer;
import org.w3c.dom.Attr;
import org.w3c.dom.Comment;
import org.w3c.dom.Document;
import org.w3c.dom.Element;
import org.w3c.dom.NamedNodeMap;
import org.w3c.dom.Node;
import org.w3c.dom.NodeList;
import org.apache.commons.jxpath.AbstractFactory;
import static org.junit.jupiter.api.Assertions.*;
import java.util.Locale;
import java.util.Objects;
import org.junit.jupiter.api.Assertions;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.Timeout;
import org.junit.jupiter.api.Timeout.ThreadMode;
import java.util.concurrent.TimeUnit;
import static org.junit.jupiter.api.Timeout.ThreadMode.SEPARATE_THREAD;
import org.junit.jupiter.api.extension.ExtendWith;
import org.mockito.junit.jupiter.MockitoSettings;
import org.mockito.quality.Strictness;
import org.mockito.InjectMocks;
import org.mockito.InjectMocks;
import org.mockito.Mock;
import org.mockito.Mockito;
import org.mockito.Mockito;
import org.mockito.junit.jupiter.MockitoExtension;
import static org.mockito.Mockito.*;   
@ExtendWith(MockitoExtension.class)
@MockitoSettings(strictness = Strictness.LENIENT)
public class Aster_DOMNodePointer_Test_Passing {
private NamespaceResolver localNamespaceResolver;
private String defaultNamespace;
@Mock
    private Node node;
@Mock
    private NodePointer nodePointer1;
@Mock
    private NodePointer nodePointer2;
@Mock
    private NamedNodeMap namedNodeMap;
@InjectMocks
    private DOMNodePointer domNodePointer;
@Mock
    private NodeTest nodeTest;
@Mock
    private NodeList nodeList;
@Mock
    private Document document;
@Mock
    private JXPathContext context;
@Mock
    private AbstractFactory abstractFactory;
@Mock
    private NodeIterator nodeIterator;
@Mock
    private NodePointer nodePointer;
private QName qName;
@Mock
    Element element;
@Mock
    private Locale locale;
@Mock
    private NodePointer startWith;
@Mock
    private DOMNodeIterator expectedIterator;
@Mock
    private NamespaceResolver namespaceResolver;
private QName qNameWithPrefix;
private QName qNameWithoutPrefix;
@Mock
    private Node anotherNode;
@Mock
    private Attr attr;
@Mock
    private Comment commentNode;
private final String id = "testId";
private Locale mockLocale;
@Mock
    private DOMNodePointer parent;
@Mock
    private NamespaceResolver parentNamespaceResolver;
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testCompareChildNodePointers_SameNode() throws Exception {
        when(nodePointer1.getBaseValue()).thenReturn(node);
        when(nodePointer2.getBaseValue()).thenReturn(node);
        when(node.getAttributes()).thenReturn(namedNodeMap);
        when(node.getFirstChild()).thenReturn(node);
        when(node.getNextSibling()).thenReturn(null);
        assertEquals(0, domNodePointer.compareChildNodePointers(nodePointer1, nodePointer2),
                "Should return 0 when both pointers refer to the same node");
    }
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testCompareChildNodePointers_AttributeNodes_2() throws Exception {
        when(nodePointer1.getBaseValue()).thenReturn(node);
        when(nodePointer2.getBaseValue()).thenReturn(node);
        when(node.getAttributes()).thenReturn(namedNodeMap);
        when(node.getFirstChild()).thenReturn(node);
        when(node.getNextSibling()).thenReturn(null);
        Node attributeNode1 = mock(Node.class);
        Node attributeNode2 = mock(Node.class);
        when(nodePointer1.getBaseValue()).thenReturn(attributeNode1);
        when(nodePointer2.getBaseValue()).thenReturn(attributeNode2);
        when(attributeNode1.getNodeType()).thenReturn(Node.ATTRIBUTE_NODE);
        when(attributeNode2.getNodeType()).thenReturn(Node.ATTRIBUTE_NODE);
        when(namedNodeMap.getLength()).thenReturn(2);
        when(namedNodeMap.item(0)).thenReturn(attributeNode1);
        when(namedNodeMap.item(1)).thenReturn(attributeNode2);
        assertEquals(1, domNodePointer.compareChildNodePointers(nodePointer2, nodePointer1),
                "Should return 1 when first attribute node is after the second in the map");}
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testSetValueWithTextNodeAndEmptyString() {
        when(node.getOwnerDocument()).thenReturn(document);
        when(node.getChildNodes()).thenReturn(nodeList);
        when(node.appendChild(any(Node.class))).thenAnswer(invocation -> invocation.getArgument(0));
        when(node.removeChild(any(Node.class))).thenReturn(null);
        when(node.getParentNode()).thenReturn(node);
        when(node.getNodeType()).thenReturn(Node.TEXT_NODE);
        String testValue = "";
        domNodePointer.setValue(testValue);
        verify(node.getParentNode(), times(1)).removeChild(node);
    }
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testSetValueWithNonTextNodeAndEmptyStringValue() {
        when(node.getOwnerDocument()).thenReturn(document);
        when(node.getChildNodes()).thenReturn(nodeList);
        when(node.appendChild(any(Node.class))).thenAnswer(invocation -> invocation.getArgument(0));
        when(node.removeChild(any(Node.class))).thenReturn(null);
        when(node.getParentNode()).thenReturn(node);
        when(node.getNodeType()).thenReturn(Node.ELEMENT_NODE);
        String testValue = "";
        domNodePointer.setValue(testValue);
        verify(node, never()).appendChild(any(Node.class));
    }
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testSetValueWithTextNodeNonEmptyString_TjDJ0() {
        Node node = mock(Node.class);
        when(node.getNodeType()).thenReturn(Node.TEXT_NODE);
        when(node.getNodeValue()).thenReturn("initial");
        DOMNodePointer domNodePointer = new DOMNodePointer(node, Locale.getDefault());
        domNodePointer.setValue("new value");
        verify(node).setNodeValue("new value");
    }
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testSetValueWithTextNodeEmptyString_hIyd1() {
        Node parentNode = mock(Node.class);
        Node node = mock(Node.class);
        when(node.getNodeType()).thenReturn(Node.TEXT_NODE);
        when(node.getParentNode()).thenReturn(parentNode);
        DOMNodePointer domNodePointer = new DOMNodePointer(node, Locale.getDefault());
        domNodePointer.setValue("");
        verify(parentNode).removeChild(node);
    }
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testSetValueWithCDATANode_wxYw2() {
        Node node = mock(Node.class);
        when(node.getNodeType()).thenReturn(Node.CDATA_SECTION_NODE);
        DOMNodePointer domNodePointer = new DOMNodePointer(node, Locale.getDefault());
        domNodePointer.setValue("CDATA content");
        verify(node).setNodeValue("CDATA content");
    }
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testSetValueWithNullToElement_PiPp7() {
        Node node = mock(Node.class);
        when(node.getNodeType()).thenReturn(Node.ELEMENT_NODE);
        NodeList nodeList = mock(NodeList.class);
        when(node.getChildNodes()).thenReturn(nodeList);
        when(nodeList.getLength()).thenReturn(1);
        Node childNode = mock(Node.class);
        when(nodeList.item(0)).thenReturn(childNode);
        DOMNodePointer domNodePointer = new DOMNodePointer(node, Locale.getDefault());
        domNodePointer.setValue(null);
        verify(node).removeChild(childNode);
    }
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testSetValueWithEmptyStringToCDATA_XMQy9() {
        Node parentNode = mock(Node.class);
        Node node = mock(Node.class);
        when(node.getNodeType()).thenReturn(Node.CDATA_SECTION_NODE);
        when(node.getParentNode()).thenReturn(parentNode);
        DOMNodePointer domNodePointer = new DOMNodePointer(node, Locale.getDefault());
        domNodePointer.setValue("");
        verify(parentNode).removeChild(node);
    }
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testSetValueWithNonEmptyStringToCDATA_mTdl10() {
        Node node = mock(Node.class);
        when(node.getNodeType()).thenReturn(Node.CDATA_SECTION_NODE);
        when(node.getNodeValue()).thenReturn("initial");
        DOMNodePointer domNodePointer = new DOMNodePointer(node, Locale.getDefault());
        domNodePointer.setValue("new CDATA content");
        verify(node).setNodeValue("new CDATA content");
}
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testIsCollection() {
        // Mocking the Node and Locale as they are external to DOMNodePointer and not the focus of the test
        Node mockNode = org.mockito.Mockito.mock(Node.class);
        Locale mockLocale = org.mockito.Mockito.mock(Locale.class);
        // Initialize DOMNodePointer with mocked Node and Locale
        domNodePointer = new DOMNodePointer(mockNode, mockLocale);
        // Since isCollection() always returns false, we assert that this is indeed the case
        assertFalse(domNodePointer.isCollection(), "DOMNodePointer should not be a collection");
    }
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
public void testIsCollectionReturnsFalse_fACx0() {
    Node node = mock(Node.class);
    Locale locale = new Locale("en");
    DOMNodePointer domNodePointer = new DOMNodePointer(node, locale);
    assertFalse(domNodePointer.isCollection());
}
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testGetImmediateNode() {
        domNodePointer = new DOMNodePointer(node, null);
        assertEquals(node, domNodePointer.getImmediateNode(), "The returned node should be the same as the mocked node");
    }
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
public void testGetImmediateNode_cZoQ0() {
    Node testNode = mock(Node.class);
    Locale testLocale = Locale.getDefault();
    DOMNodePointer domNodePointer = new DOMNodePointer(testNode, testLocale);
    Node result = (Node) domNodePointer.getImmediateNode();
    assertEquals(testNode, result);
}
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testFindEnclosingAttribute_NoElementNode() {
        when(node.getNodeType()).thenReturn(Node.ELEMENT_NODE);
        when(node.getParentNode()).thenReturn(null); // Assume no parent for simplicity
        when(element.getNodeType()).thenReturn(Node.ELEMENT_NODE);
        // Setup
        String attrName = "testAttr";
        when(node.getNodeType()).thenReturn(Node.TEXT_NODE); // Not an ELEMENT_NODE
        when(node.getParentNode()).thenReturn(null);
        // Execute
        String result = DOMNodePointer.findEnclosingAttribute(node, attrName);
        // Verify
        assertNull(result, "The result should be null when no ELEMENT_NODE is encountered.");
    }
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
public void testHashCodeConsistency_paJK0() {
    Node testNode = mock(Node.class);
    Locale testLocale = Locale.getDefault();
    DOMNodePointer domNodePointer = new DOMNodePointer(testNode, testLocale);
    int expectedHashCode = testNode.hashCode();
    int actualHashCode = domNodePointer.hashCode();
    assertEquals(expectedHashCode, actualHashCode);
}
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testAttributeIterator_1() throws Exception {
        domNodePointer = new DOMNodePointer(node, locale);
        QName qName = new QName("testName");
        NodeIterator resultIterator = domNodePointer.attributeIterator(qName);
        // Verify that the constructor of DOMAttributeIterator was called with the correct parameters
        DOMAttributeIterator expectedIterator = new DOMAttributeIterator(domNodePointer, qName);
        assertNotNull(resultIterator, "The result should not be null.");}
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testAttributeIterator_2() throws Exception {
        domNodePointer = new DOMNodePointer(node, locale);
        QName qName = new QName("testName");
        NodeIterator resultIterator = domNodePointer.attributeIterator(qName);
        // Verify that the constructor of DOMAttributeIterator was called with the correct parameters
        DOMAttributeIterator expectedIterator = new DOMAttributeIterator(domNodePointer, qName);
        assertTrue(resultIterator instanceof DOMAttributeIterator, "The result should be an instance of DOMAttributeIterator.");}
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testAttributeIterator_3() throws Exception {
        domNodePointer = new DOMNodePointer(node, locale);
        QName qName = new QName("testName");
        NodeIterator resultIterator = domNodePointer.attributeIterator(qName);
        // Verify that the constructor of DOMAttributeIterator was called with the correct parameters
        DOMAttributeIterator expectedIterator = new DOMAttributeIterator(domNodePointer, qName);
        assertEquals(expectedIterator.getClass(), resultIterator.getClass(), "Expected iterator class does not match the actual class.");}
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testGetName_ElementNode_1() {
        domNodePointer = new DOMNodePointer(node, Locale.getDefault());
        when(node.getNodeType()).thenReturn(Node.ELEMENT_NODE);
        when(node.getPrefix()).thenReturn("ns");
        when(node.getLocalName()).thenReturn("ln");
        QName result = domNodePointer.getName();
        assertEquals("ns", result.getPrefix());}
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testGetName_ElementNode_2() {
        domNodePointer = new DOMNodePointer(node, Locale.getDefault());
        when(node.getNodeType()).thenReturn(Node.ELEMENT_NODE);
        when(node.getPrefix()).thenReturn("ns");
        when(node.getLocalName()).thenReturn("ln");
        QName result = domNodePointer.getName();
        assertEquals("ln", result.getName());}
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testChildIterator_1() throws Exception {
        Locale locale = Locale.getDefault();
        domNodePointer = new DOMNodePointer(node, locale);
        // Arrange
        boolean reverse = false;
        // Act
        NodeIterator result = domNodePointer.childIterator(nodeTest, reverse, startWith);
        // Assert
        assertNotNull(result, "The result should not be null.");}
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testChildIterator_2() throws Exception {
        Locale locale = Locale.getDefault();
        domNodePointer = new DOMNodePointer(node, locale);
        // Arrange
        boolean reverse = false;
        // Act
        NodeIterator result = domNodePointer.childIterator(nodeTest, reverse, startWith);
        // Assert
        assertTrue(result instanceof DOMNodeIterator, "The result should be an instance of DOMNodeIterator.");}
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testGetLength() throws Exception {
        // Assuming the use of the constructor that takes a Node and a Locale.
        domNodePointer = new DOMNodePointer(node, locale);
        // Act
        int length = domNodePointer.getLength();
        // Assert
        assertEquals(1, length, "The length should always be 1 as per the current implementation.");
    }
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
public void testGetLengthReturnsOne_juYc0() {
    Node node = mock(Node.class);
    Locale locale = Locale.getDefault();
    DOMNodePointer domNodePointer = new DOMNodePointer(node, locale);
    int length = domNodePointer.getLength();
    assertEquals(1, length);
}
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testNamespaceIterator_1() throws Exception {
        locale = Locale.getDefault();
        domNodePointer = new DOMNodePointer(node, locale);
        NodeIterator result = domNodePointer.namespaceIterator();
        assertNotNull(result, "The result should not be null.");}
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testNamespaceIterator_2() throws Exception {
        locale = Locale.getDefault();
        domNodePointer = new DOMNodePointer(node, locale);
        NodeIterator result = domNodePointer.namespaceIterator();
        assertTrue(result instanceof DOMNamespaceIterator, "The result should be an instance of DOMNamespaceIterator.");}
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testNamespaceIterator_ytyY0() {
        DOMNodePointer domNodePointer = new DOMNodePointer(node, locale);
        NodeIterator result = domNodePointer.namespaceIterator();
    }
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testIsLeaf_WhenNodeHasNoChildNodes_ShouldReturnTrue() {
        domNodePointer = new DOMNodePointer(node, null);
        when(node.hasChildNodes()).thenReturn(false);
        assertTrue(domNodePointer.isLeaf());
    }
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testIsLeaf_WhenNodeHasChildNodes_ShouldReturnFalse() {
        domNodePointer = new DOMNodePointer(node, null);
        when(node.hasChildNodes()).thenReturn(true);
        assertFalse(domNodePointer.isLeaf());
    }
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testEquals_SameObject_ShouldReturnTrue() {
        domNodePointer = new DOMNodePointer(node, Locale.getDefault());
        assertTrue(domNodePointer.equals(domNodePointer), "The same object should be equal to itself.");
    }
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testEquals_Null_ShouldReturnFalse() {
        domNodePointer = new DOMNodePointer(node, Locale.getDefault());
        assertFalse(domNodePointer.equals(null), "Any object should not be equal to null.");
    }
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testEquals_DifferentClass_ShouldReturnFalse() {
        domNodePointer = new DOMNodePointer(node, Locale.getDefault());
        Object differentObject = new Object();
        assertFalse(domNodePointer.equals(differentObject), "Objects of different types should not be equal.");
    }
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testEquals_SameNode_ShouldReturnTrue() {
        domNodePointer = new DOMNodePointer(node, Locale.getDefault());
        DOMNodePointer anotherDOMNodePointer = new DOMNodePointer(node, Locale.getDefault());
        assertTrue(domNodePointer.equals(anotherDOMNodePointer), "Objects with the same node should be equal.");
    }
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testEquals_DifferentNode_ShouldReturnFalse() {
        domNodePointer = new DOMNodePointer(node, Locale.getDefault());
        DOMNodePointer anotherDOMNodePointer = new DOMNodePointer(anotherNode, Locale.getDefault());
        assertFalse(domNodePointer.equals(anotherDOMNodePointer), "Objects with different nodes should not be equal.");
    }
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testGetLocalName_WithLocalName() throws Exception {
        // Node is already mocked by MockitoExtension
        when(node.getLocalName()).thenReturn("localName");
        String result = DOMNodePointer.getLocalName(node);
        assertEquals("localName", result, "The local name should be returned when it is not null.");
    }
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testGetLocalName_WithNullLocalNameAndQualifiedName() throws Exception {
        // Node is already mocked by MockitoExtension
        when(node.getLocalName()).thenReturn(null);
        when(node.getNodeName()).thenReturn("prefix:qualifiedName");
        String result = DOMNodePointer.getLocalName(node);
        assertEquals("qualifiedName", result, "The part after the colon in the node name should be returned when local name is null.");
    }
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testGetLocalName_WithNullLocalNameAndNoColonInName() throws Exception {
        // Node is already mocked by MockitoExtension
        when(node.getLocalName()).thenReturn(null);
        when(node.getNodeName()).thenReturn("nodeName");
        String result = DOMNodePointer.getLocalName(node);
        assertEquals("nodeName", result, "The node name should be returned when there is no colon and local name is null.");
    }
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testRemove_NodeHasParent_RemovesNode() throws Exception {
        domNodePointer = new DOMNodePointer(node, Locale.getDefault());
        Node parentNode = mock(Node.class);
        when(node.getParentNode()).thenReturn(parentNode);
        domNodePointer.remove();
        verify(parentNode).removeChild(node);
    }
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testRemove_NodeIsRoot_ThrowsException() {
        domNodePointer = new DOMNodePointer(node, Locale.getDefault());
        when(node.getParentNode()).thenReturn(null);
        assertThrows(JXPathException.class, () -> domNodePointer.remove());
    }
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testIsLanguage_WhenCurrentLanguageIsNull_ShouldDelegateToSuper() {
        domNodePointer = new DOMNodePointer(node, Locale.ENGLISH);
        // Assuming super.isLanguage is always true for this test case
        DOMNodePointer spyDomNodePointer = spy(domNodePointer);
        doReturn(null).when(spyDomNodePointer).getLanguage();
        doReturn(true).when(spyDomNodePointer).isLanguage(anyString());
        assertTrue(spyDomNodePointer.isLanguage("EN"));
        verify(spyDomNodePointer).isLanguage("EN");
    }
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testIsLanguage_WhenCurrentLanguageIsNotNull_ShouldMatchLanguageCaseInsensitively_1() {
        domNodePointer = new DOMNodePointer(node, Locale.ENGLISH);
        DOMNodePointer spyDomNodePointer = spy(domNodePointer);
        doReturn("en-US").when(spyDomNodePointer).getLanguage();
        assertTrue(spyDomNodePointer.isLanguage("en"));}
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testIsLanguage_WhenCurrentLanguageIsNotNull_ShouldMatchLanguageCaseInsensitively_2() {
        domNodePointer = new DOMNodePointer(node, Locale.ENGLISH);
        DOMNodePointer spyDomNodePointer = spy(domNodePointer);
        doReturn("en-US").when(spyDomNodePointer).getLanguage();
        assertFalse(spyDomNodePointer.isLanguage("fr"));}
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testIsLanguage_MatchingLanguage_NpWt0() {
        Locale locale = new Locale("en");
        DOMNodePointer domNodePointer = new DOMNodePointer(node, locale);
        assertTrue(domNodePointer.isLanguage("EN"));
    }
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testIsLanguage_NonMatchingLanguage_eGFk1() {
        Locale locale = new Locale("fr");
        DOMNodePointer domNodePointer = new DOMNodePointer(node, locale);
        assertFalse(domNodePointer.isLanguage("EN"));
    }
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testGetPrefix_WithPrefix() {
        domNodePointer = new DOMNodePointer(node, null);
        // Setup the mock to return a prefix
        when(node.getPrefix()).thenReturn("prefix");
        // Call the method under test
        String result = DOMNodePointer.getPrefix(node);
        // Assert the result
        assertEquals("prefix", result, "The prefix should be returned correctly.");
    }
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testGetPrefix_WithoutPrefix_WithColonInName() {
        domNodePointer = new DOMNodePointer(node, null);
        // Setup the mock to return null for prefix and a qualified name with a colon
        when(node.getPrefix()).thenReturn(null);
        when(node.getNodeName()).thenReturn("namespace:localName");
        // Call the method under test
        String result = DOMNodePointer.getPrefix(node);
        // Assert the result
        assertEquals("namespace", result, "The namespace part of the node name should be returned as the prefix.");
    }
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testGetPrefix_WithoutPrefix_WithoutColonInName() {
        domNodePointer = new DOMNodePointer(node, null);
        // Setup the mock to return null for prefix and a simple name without a colon
        when(node.getPrefix()).thenReturn(null);
        when(node.getNodeName()).thenReturn("localName");
        // Call the method under test
        String result = DOMNodePointer.getPrefix(node);
        // Assert the result
        assertNull(result, "No prefix should be returned when there is no colon in the node name.");
    }
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testNamespacePointer_Reuo0_1() {
        Locale locale = new Locale("en", "US");
        DOMNodePointer domNodePointer = new DOMNodePointer(node, locale);
        String prefix = "testPrefix";
        NodePointer result = domNodePointer.namespacePointer(prefix);
        assertNotNull(result);}
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testNamespacePointer_Reuo0_2() {
        Locale locale = new Locale("en", "US");
        DOMNodePointer domNodePointer = new DOMNodePointer(node, locale);
        String prefix = "testPrefix";
        NodePointer result = domNodePointer.namespacePointer(prefix);
        assertEquals(NamespacePointer.class, result.getClass());}
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testGetLanguage_WhenLangAttributeAbsent() {
        when(node.getAttributes()).thenReturn(null);
        when(node.getParentNode()).thenReturn(element);
        when(element.getAttributes()).thenReturn(null);
        when(element.getParentNode()).thenReturn(null);
        // Setup
        when(node.getAttributes()).thenReturn(null);
        // Execute
        String language = domNodePointer.getLanguage();
        // Verify
        assertNull(language);
    }
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testNode_WithNullNodeTest_ShouldReturnTrue() {
        node = mock(Node.class);
        nodeTest = mock(NodeTest.class); // Generic mock, will be cast in specific tests
        assertTrue(DOMNodePointer.testNode(node, null));
    }
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testNode_WithNodeTypeTestAndTextNode_ShouldReturnTrueForTextType() {
        node = mock(Node.class);
        nodeTest = mock(NodeTest.class); // Generic mock, will be cast in specific tests
        NodeTypeTest nodeTypeTest = mock(NodeTypeTest.class);
        when(node.getNodeType()).thenReturn(Node.TEXT_NODE);
        when(nodeTypeTest.getNodeType()).thenReturn(Compiler.NODE_TYPE_TEXT);
        assertTrue(DOMNodePointer.testNode(node, nodeTypeTest));
    }
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testNode_WithMismatchedNodeType_ShouldReturnFalse() {
        node = mock(Node.class);
        nodeTest = mock(NodeTest.class); // Generic mock, will be cast in specific tests
        NodeTypeTest nodeTypeTest = mock(NodeTypeTest.class);
        when(node.getNodeType()).thenReturn(Node.COMMENT_NODE);
        when(nodeTypeTest.getNodeType()).thenReturn(Compiler.NODE_TYPE_TEXT);
        assertFalse(DOMNodePointer.testNode(node, nodeTypeTest));
    }
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testAsPathWithNonNullId() {
        when(node.getNodeType()).thenReturn(Node.ELEMENT_NODE);
        when(node.getLocalName()).thenReturn("elementName");
        domNodePointer = new DOMNodePointer(node, Locale.getDefault(), "uniqueId");
        String expectedPath = "id('uniqueId')";
        assertEquals(expectedPath, domNodePointer.asPath());
    }
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testAsPathWithTextNode() {
        when(node.getNodeType()).thenReturn(Node.ELEMENT_NODE);
        when(node.getLocalName()).thenReturn("elementName");
        when(node.getNodeType()).thenReturn(Node.TEXT_NODE);
        domNodePointer = new DOMNodePointer(node, Locale.getDefault());
        String expectedPath = "/text()[1]";
        assertEquals(expectedPath, domNodePointer.asPath());
    }
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testAsPathWithDocumentNode() {
        when(node.getNodeType()).thenReturn(Node.ELEMENT_NODE);
        when(node.getLocalName()).thenReturn("elementName");
        when(node.getNodeType()).thenReturn(Node.DOCUMENT_NODE);
        domNodePointer = new DOMNodePointer(node, Locale.getDefault());
        String expectedPath = "";
        assertEquals(expectedPath, domNodePointer.asPath());
    }
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testGetNamespaceURI_WithXMLPrefix_ReturnsXMLNamespace() {
        when(node.getNodeType()).thenReturn(Node.ELEMENT_NODE);
        when(node.getParentNode()).thenReturn(null);
        when(document.getDocumentElement()).thenReturn(element);
        String result = domNodePointer.getNamespaceURI("xml");
        assertEquals("http://www.w3.org/XML/1998/namespace", result);
    }
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testGetNamespaceURI_WithXMLNSPrefix_ReturnsXMLNSNamespace() {
        when(node.getNodeType()).thenReturn(Node.ELEMENT_NODE);
        when(node.getParentNode()).thenReturn(null);
        when(document.getDocumentElement()).thenReturn(element);
        String result = domNodePointer.getNamespaceURI("xmlns");
        assertEquals("http://www.w3.org/2000/xmlns/", result);
    }
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testGetBaseValue() {
        domNodePointer = new DOMNodePointer(node, null);
        assertEquals(node, domNodePointer.getBaseValue(), "The base value should be the mocked Node object");
    }
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
public void testGetBaseValue_dssI0() {
    Node testNode = mock(Node.class);
    Locale testLocale = Locale.getDefault();
    DOMNodePointer domNodePointer = new DOMNodePointer(testNode, testLocale);
    Object result = domNodePointer.getBaseValue();
    assertEquals(testNode, result);
}
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testIsActual() {
        // Mock the dependencies
        Node node = org.mockito.Mockito.mock(Node.class);
        Locale locale = new Locale("en", "US");
        // Initialize DOMNodePointer with mocked Node and Locale
        domNodePointer = new DOMNodePointer(node, locale);
        // Execute the method
        boolean result = domNodePointer.isActual();
        // Assert the expected result
        assertTrue(result, "DOMNodePointer.isActual() should return true.");
    }
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
public void testIsActual_DCWm0() {
    Node node = mock(Node.class);
    Locale locale = new Locale("en", "US");
    DOMNodePointer domNodePointer = new DOMNodePointer(node, locale);
    assertTrue(domNodePointer.isActual());
}
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
public void testChildIterator_dUXW0_Zsme0() {
    Node node = mock(Node.class);
    Locale locale = Locale.getDefault();
    DOMNodePointer domNodePointer = new DOMNodePointer(node, locale);
    boolean reverse = false;
    NodePointer startWith = null;
    NodeIterator result = domNodePointer.childIterator(nodeTest, reverse, startWith);
    assertNotNull(result);
}
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
public void testNamespacePointer_ULGz0() throws Exception {
    Node mockNode = mock(Node.class);
    Locale mockLocale = mock(Locale.class);
    String id = "testId";
    DOMNodePointer domNodePointer = new DOMNodePointer(mockNode, mockLocale, id);
    String prefix = "testPrefix";
    NodePointer result = domNodePointer.namespacePointer(prefix);
}
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
public void testNode_NullTest_ReturnsTrue_JYKS0_LRqM0() {
    Node node = Mockito.mock(Node.class);
    when(node.getNodeType()).thenReturn(Node.ELEMENT_NODE);
    DOMNodePointer domNodePointer = new DOMNodePointer(node, Locale.getDefault());
    assertTrue(domNodePointer.getNamespaceResolver() != null);
}
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
public void testNode_NodeTypeTest_NodeTypeNode_ReturnsTrue_kHuV7_Ugjn0() {
    Node node = Mockito.mock(Node.class);
    Mockito.when(node.getNodeType()).thenReturn(Node.ELEMENT_NODE);
    NodeTypeTest test = new NodeTypeTest(Compiler.NODE_TYPE_NODE);
    assertTrue(DOMNodePointer.testNode(node, test));
}
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
public void testNode_EqualStrings_BothNull_ReturnsTrue_XLKr14_NcaQ0() {
    assertTrue(Objects.equals(null, null));
}
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
public void testNode_EqualStrings_FirstNullSecondEmpty_ReturnsTrue_PcdU15_ieRF0() {
    assertFalse(Objects.equals(null, ""));
}
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
public void testNode_EqualStrings_NonTrimmedEqual_ReturnsTrue_teER17_NYei0() {
    assertTrue(" test ".trim().equals("test".trim()));
}
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
public void testNode_EqualStrings_DifferentStrings_ReturnsFalse_yHpJ18_KUml0() {
    assertFalse("test1".equals("test2"));
}
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
public void testAsPathWithTextNode_tquZ2_YFUN0() {
    Node node = Mockito.mock(Node.class);
    when(node.getNodeType()).thenReturn(Node.TEXT_NODE);
    when(node.getNodeName()).thenReturn("#text");
    DOMNodePointer pointer = new DOMNodePointer(node, Locale.getDefault());
    assertEquals("/text()[1]", pointer.asPath());
}
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
public void testGetNamespaceResolver_FirstCall_DpUe0_ntwa0() {
    DOMNodePointer domNodePointer = new DOMNodePointer(node, locale);
    NamespaceResolver result = domNodePointer.getNamespaceResolver();
    Assertions.assertNotNull(result, "NamespaceResolver should not be null after first call");
}
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
public void testGetNamespaceResolver_SubsequentCall_ePIT1_TEdX0_1() {
    DOMNodePointer domNodePointer = new DOMNodePointer(node, locale);
    NamespaceResolver firstCallResolver = domNodePointer.getNamespaceResolver();
    NamespaceResolver secondCallResolver = domNodePointer.getNamespaceResolver();
    assertNotNull(secondCallResolver, "NamespaceResolver should not be null on subsequent calls");}
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
public void testGetNamespaceResolver_SubsequentCall_ePIT1_TEdX0_2() {
    DOMNodePointer domNodePointer = new DOMNodePointer(node, locale);
    NamespaceResolver firstCallResolver = domNodePointer.getNamespaceResolver();
    NamespaceResolver secondCallResolver = domNodePointer.getNamespaceResolver();
    assertSame(firstCallResolver, secondCallResolver, "NamespaceResolver should be the same object on subsequent calls");}
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testAttributeIterator() throws Exception {
        domNodePointer = new DOMNodePointer(node, locale);
        QName qName = new QName("testName");
        NodeIterator resultIterator = domNodePointer.attributeIterator(qName);
        assertNotNull(resultIterator, "The result should not be null.");
        assertTrue(resultIterator instanceof DOMAttributeIterator, "The result should be an instance of DOMAttributeIterator.");
        // Verify that the constructor of DOMAttributeIterator was called with the correct parameters
        DOMAttributeIterator expectedIterator = new DOMAttributeIterator(domNodePointer, qName);
        assertEquals(expectedIterator.getClass(), resultIterator.getClass(), "Expected iterator class does not match the actual class.");
    }
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testGetName_ElementNode() {
        domNodePointer = new DOMNodePointer(node, Locale.getDefault());
        when(node.getNodeType()).thenReturn(Node.ELEMENT_NODE);
        when(node.getPrefix()).thenReturn("ns");
        when(node.getLocalName()).thenReturn("ln");
        QName result = domNodePointer.getName();
        assertEquals("ns", result.getPrefix());
        assertEquals("ln", result.getName());
    }
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testChildIterator() throws Exception {
        Locale locale = Locale.getDefault();
        domNodePointer = new DOMNodePointer(node, locale);
        // Arrange
        boolean reverse = false;
        // Act
        NodeIterator result = domNodePointer.childIterator(nodeTest, reverse, startWith);
        // Assert
        assertNotNull(result, "The result should not be null.");
        assertTrue(result instanceof DOMNodeIterator, "The result should be an instance of DOMNodeIterator.");
    }
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testNamespaceIterator() throws Exception {
        locale = Locale.getDefault();
        domNodePointer = new DOMNodePointer(node, locale);
        NodeIterator result = domNodePointer.namespaceIterator();
        assertNotNull(result, "The result should not be null.");
        assertTrue(result instanceof DOMNamespaceIterator, "The result should be an instance of DOMNamespaceIterator.");
    }
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testIsLanguage_WhenCurrentLanguageIsNotNull_ShouldMatchLanguageCaseInsensitively() {
        domNodePointer = new DOMNodePointer(node, Locale.ENGLISH);
        DOMNodePointer spyDomNodePointer = spy(domNodePointer);
        doReturn("en-US").when(spyDomNodePointer).getLanguage();
        assertTrue(spyDomNodePointer.isLanguage("en"));
        assertFalse(spyDomNodePointer.isLanguage("fr"));
    }
}