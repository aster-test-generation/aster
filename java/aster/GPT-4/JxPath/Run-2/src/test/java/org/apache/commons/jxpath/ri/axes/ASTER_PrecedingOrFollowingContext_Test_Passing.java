/**
 * Generated by Aster
 */
package org.apache.commons.jxpath.ri.axes;
import java.util.Stack;
import org.apache.commons.jxpath.ri.model.NodeIterator;
import org.apache.commons.jxpath.ri.model.NodePointer;
import org.apache.commons.jxpath.ri.compiler.NodeTypeTest;
import static org.junit.jupiter.api.Assertions.*;
import java.util.Stack;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.Timeout;
import org.junit.jupiter.api.Timeout.ThreadMode;
import java.util.concurrent.TimeUnit;
import static org.junit.jupiter.api.Timeout.ThreadMode.SEPARATE_THREAD;
import org.junit.jupiter.api.extension.ExtendWith;
import org.mockito.junit.jupiter.MockitoSettings;
import org.mockito.quality.Strictness;
import org.mockito.InjectMocks;
import org.mockito.InjectMocks;
import org.mockito.Mock;
import org.mockito.junit.jupiter.MockitoExtension;
import static org.mockito.Mockito.*;
import java.lang.reflect.Field;   
@ExtendWith(MockitoExtension.class)
@MockitoSettings(strictness = Strictness.LENIENT)
public class Aster_PrecedingOrFollowingContext_Test_Passing {
@Mock
    private NamespaceContext mockNamespaceContext;
@Mock
    private NodeTypeTest mockNodeTypeTest;
@InjectMocks
    private PrecedingOrFollowingContext precedingOrFollowingContext;
private PrecedingOrFollowingContext precedingOrFollowingContextTrue;
private PrecedingOrFollowingContext precedingOrFollowingContextFalse;
@Mock
    private NodePointer currentNodePointer;
@Mock
    private NamespaceContext namespaceContext;
@Mock
    private NodeTypeTest nodeTypeTest;
@Mock
    private NamespaceContext parentContext;
@Mock
    private NodeTypeTest nodeTest;
@Mock
    private NodePointer currentRootLocation;
@Mock
    private NodePointer parentNode;
@Mock
    private NodeIterator nodeIterator;
    private boolean setStarted = false;
    private Stack stack = null;
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testSetPosition_SuccessfullyAdvancesPosition() throws Exception {
        // Initialize PrecedingOrFollowingContext with mocks
        precedingOrFollowingContext = new PrecedingOrFollowingContext(mockNamespaceContext, mockNodeTypeTest, false);
        // Arrange
        int initialPosition = 1;
        int newPosition = 3;
        when(precedingOrFollowingContext.nextNode()).thenReturn(true, true, false);
        // Act
        boolean result = precedingOrFollowingContext.setPosition(newPosition);
        // Assert
        assertTrue(result, "setPosition should return true when it can advance to the requested position.");
        verify(precedingOrFollowingContext, times(2)).nextNode();
    }
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testSetPosition_FailsToAdvancePosition() throws Exception {
        // Initialize PrecedingOrFollowingContext with mocks
        precedingOrFollowingContext = new PrecedingOrFollowingContext(mockNamespaceContext, mockNodeTypeTest, false);
        // Arrange
        int initialPosition = 1;
        int newPosition = 3;
        when(precedingOrFollowingContext.nextNode()).thenReturn(true, false);
        // Act
        boolean result = precedingOrFollowingContext.setPosition(newPosition);
        // Assert
        assertFalse(result, "setPosition should return false when it cannot advance to the requested position.");
        verify(precedingOrFollowingContext, times(2)).nextNode();
    }
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testSetPosition_ResetCalledWhenPositionIsLessThanCurrent() throws Exception {
        // Initialize PrecedingOrFollowingContext with mocks
        precedingOrFollowingContext = new PrecedingOrFollowingContext(mockNamespaceContext, mockNodeTypeTest, false);
        // Arrange
        int initialPosition = 3;
        int newPosition = 2;
        doNothing().when(precedingOrFollowingContext).reset();
        // Act
        boolean result = precedingOrFollowingContext.setPosition(newPosition);
        // Assert
        verify(precedingOrFollowingContext).reset();
    }
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testSetPositionDecreasePosition_VVpv0() {
        NodeTypeTest nodeTypeTest = new NodeTypeTest(1);
        SelfContext selfContext = new SelfContext(null, nodeTypeTest);
        NamespaceContext namespaceContext = new NamespaceContext(selfContext, nodeTypeTest);
        PrecedingOrFollowingContext context = new PrecedingOrFollowingContext(namespaceContext, nodeTypeTest, false);
        context.setPosition(5); // Set initial position to 5
        boolean result = context.setPosition(3); // Try to set a lower position
        assertTrue(result);
    }
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testSetPositionIncreasePosition_IiMS1() {
        NodeTypeTest nodeTypeTest = new NodeTypeTest(1);
        SelfContext selfContext = new SelfContext(null, nodeTypeTest);
        NamespaceContext namespaceContext = new NamespaceContext(selfContext, nodeTypeTest);
        PrecedingOrFollowingContext context = new PrecedingOrFollowingContext(namespaceContext, nodeTypeTest, false);
        context.setPosition(2); // Set initial position to 2
        boolean result = context.setPosition(4); // Try to set a higher position
        assertTrue(result);
    }
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testSetPositionToSamePosition_HFrV2() {
        NodeTypeTest nodeTypeTest = new NodeTypeTest(1);
        SelfContext selfContext = new SelfContext(null, nodeTypeTest);
        NamespaceContext namespaceContext = new NamespaceContext(selfContext, nodeTypeTest);
        PrecedingOrFollowingContext context = new PrecedingOrFollowingContext(namespaceContext, nodeTypeTest, false);
        context.setPosition(3); // Set initial position to 3
        boolean result = context.setPosition(3); // Try to set the same position
        assertTrue(result);
    }
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testSetPositionBeyondAvailableNodes_GlfX3() {
        NodeTypeTest nodeTypeTest = new NodeTypeTest(1);
        SelfContext selfContext = new SelfContext(null, nodeTypeTest);
        NamespaceContext namespaceContext = new NamespaceContext(selfContext, nodeTypeTest);
        PrecedingOrFollowingContext context = new PrecedingOrFollowingContext(namespaceContext, nodeTypeTest, false);
        context.setPosition(1); // Set initial position to 1
        boolean result = context.setPosition(10); // Try to set a position beyond available nodes
        assertFalse(result);
    }
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testGetDocumentOrder_WhenReverseTrue_ThenReturnsNegativeOne() {
        // Mock the dependencies
        NamespaceContext mockNamespaceContext = new NamespaceContext(null, new NodeTypeTest(1));
        // Create instances of PrecedingOrFollowingContext with different 'reverse' values
        precedingOrFollowingContextTrue = new PrecedingOrFollowingContext(mockNamespaceContext, new NodeTypeTest(1), true);
        precedingOrFollowingContextFalse = new PrecedingOrFollowingContext(mockNamespaceContext, new NodeTypeTest(1), false);
        int result = precedingOrFollowingContextTrue.getDocumentOrder();
        assertEquals(-1, result, "Expected document order to be -1 when reverse is true");
    }
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testGetDocumentOrder_WhenReverseFalse_ThenReturnsOne() {
        // Mock the dependencies
        NamespaceContext mockNamespaceContext = new NamespaceContext(null, new NodeTypeTest(1));
        // Create instances of PrecedingOrFollowingContext with different 'reverse' values
        precedingOrFollowingContextTrue = new PrecedingOrFollowingContext(mockNamespaceContext, new NodeTypeTest(1), true);
        precedingOrFollowingContextFalse = new PrecedingOrFollowingContext(mockNamespaceContext, new NodeTypeTest(1), false);
        int result = precedingOrFollowingContextFalse.getDocumentOrder();
        assertEquals(1, result, "Expected document order to be 1 when reverse is false");
    }
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testGetDocumentOrderReturnsPositiveOneWhenReverseIsFalse_TUrh0() {
        NodeTypeTest nodeTypeTest = new NodeTypeTest(1);
        SelfContext selfContext = new SelfContext(null, nodeTypeTest);
        NamespaceContext namespaceContext = new NamespaceContext(selfContext, nodeTypeTest);
        PrecedingOrFollowingContext context = new PrecedingOrFollowingContext(namespaceContext, nodeTypeTest, false);
        int result = context.getDocumentOrder();
        assertEquals(1, result);
    }
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testGetDocumentOrderReturnsNegativeOneWhenReverseIsTrue_EeWp1() {
        NodeTypeTest nodeTypeTest = new NodeTypeTest(1);
        SelfContext selfContext = new SelfContext(null, nodeTypeTest);
        NamespaceContext namespaceContext = new NamespaceContext(selfContext, nodeTypeTest);
        PrecedingOrFollowingContext context = new PrecedingOrFollowingContext(namespaceContext, nodeTypeTest, true);
        int result = context.getDocumentOrder();
        assertEquals(-1, result);
    }
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
public void testGetCurrentNodePointer_FcJd0() {
    NodeTypeTest nodeTypeTest = new NodeTypeTest(1);
    SelfContext selfContext = new SelfContext(null, nodeTypeTest);
    NamespaceContext namespaceContext = new NamespaceContext(selfContext, nodeTypeTest);
    PrecedingOrFollowingContext context = new PrecedingOrFollowingContext(namespaceContext, nodeTypeTest, false);
    NodePointer expected = context.getCurrentNodePointer();
    assertEquals(expected, context.getCurrentNodePointer());
}
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testNextNode() throws Exception {
        when(parentContext.getCurrentNodePointer()).thenReturn(currentRootLocation);
        when(currentRootLocation.getParent()).thenReturn(parentNode);
        when(parentNode.childIterator(null, false, currentRootLocation)).thenReturn(nodeIterator);
        when(nodeIterator.setPosition(anyInt())).thenReturn(true);
        when(nodeIterator.getNodePointer()).thenReturn(currentRootLocation);
        when(currentRootLocation.isLeaf()).thenReturn(true);
        when(currentRootLocation.testNode(nodeTest)).thenReturn(true);
        // Setup the initial conditions where the node iterator returns a node that passes the test
        boolean result = precedingOrFollowingContext.nextNode();
        // Verify interactions
        verify(parentContext).getCurrentNodePointer();
        verify(currentRootLocation).getParent();
        verify(parentNode).childIterator(null, false, currentRootLocation);
        verify(nodeIterator).setPosition(1);
        verify(currentRootLocation).isLeaf();
        verify(currentRootLocation).testNode(nodeTest);
        // Assert the result of nextNode
        assertTrue(result, "Expected nextNode to return true when a matching node is found");
    }
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testNextNode1_gvwX0() {
        NodeTypeTest nodeTypeTest = new NodeTypeTest(1);
        SelfContext selfContext = new SelfContext(null, nodeTypeTest);
        NamespaceContext namespaceContext = new NamespaceContext(selfContext, nodeTypeTest);
        PrecedingOrFollowingContext context = new PrecedingOrFollowingContext(namespaceContext, nodeTypeTest, false);
        boolean result = context.nextNode();
        assertFalse(result);
    }
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testNextNode2_YWFI1() {
        NodeTypeTest nodeTypeTest = new NodeTypeTest(2);
        SelfContext selfContext = new SelfContext(null, nodeTypeTest);
        NamespaceContext namespaceContext = new NamespaceContext(selfContext, nodeTypeTest);
        PrecedingOrFollowingContext context = new PrecedingOrFollowingContext(namespaceContext, nodeTypeTest, true);
        boolean result = context.nextNode();
        assertFalse(result);
    }
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testNextNode3_uREp2() {
        NodeTypeTest nodeTypeTest = new NodeTypeTest(3);
        SelfContext selfContext = new SelfContext(null, nodeTypeTest);
        NamespaceContext namespaceContext = new NamespaceContext(selfContext, nodeTypeTest);
        PrecedingOrFollowingContext context = new PrecedingOrFollowingContext(namespaceContext, nodeTypeTest, false);
        boolean result = context.nextNode();
        assertFalse(result);
    }
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testNextNode4_pNHN3() {
        NodeTypeTest nodeTypeTest = new NodeTypeTest(4);
        SelfContext selfContext = new SelfContext(null, nodeTypeTest);
        NamespaceContext namespaceContext = new NamespaceContext(selfContext, nodeTypeTest);
        PrecedingOrFollowingContext context = new PrecedingOrFollowingContext(namespaceContext, nodeTypeTest, true);
        boolean result = context.nextNode();
        assertFalse(result);
    }
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testNextNode5_KBIM4() {
        NodeTypeTest nodeTypeTest = new NodeTypeTest(5);
        SelfContext selfContext = new SelfContext(null, nodeTypeTest);
        NamespaceContext namespaceContext = new NamespaceContext(selfContext, nodeTypeTest);
        PrecedingOrFollowingContext context = new PrecedingOrFollowingContext(namespaceContext, nodeTypeTest, false);
        boolean result = context.nextNode();
        assertFalse(result);
    }
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testNextNode6_ZwDM5() {
        NodeTypeTest nodeTypeTest = new NodeTypeTest(6);
        SelfContext selfContext = new SelfContext(null, nodeTypeTest);
        NamespaceContext namespaceContext = new NamespaceContext(selfContext, nodeTypeTest);
        PrecedingOrFollowingContext context = new PrecedingOrFollowingContext(namespaceContext, nodeTypeTest, true);
        boolean result = context.nextNode();
        assertFalse(result);
    }
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testNextNode7_XdJL6() {
        NodeTypeTest nodeTypeTest = new NodeTypeTest(7);
        SelfContext selfContext = new SelfContext(null, nodeTypeTest);
        NamespaceContext namespaceContext = new NamespaceContext(selfContext, nodeTypeTest);
        PrecedingOrFollowingContext context = new PrecedingOrFollowingContext(namespaceContext, nodeTypeTest, false);
        boolean result = context.nextNode();
        assertFalse(result);
    }
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testNextNode8_HjFp7() {
        NodeTypeTest nodeTypeTest = new NodeTypeTest(8);
        SelfContext selfContext = new SelfContext(null, nodeTypeTest);
        NamespaceContext namespaceContext = new NamespaceContext(selfContext, nodeTypeTest);
        PrecedingOrFollowingContext context = new PrecedingOrFollowingContext(namespaceContext, nodeTypeTest, true);
        boolean result = context.nextNode();
        assertFalse(result);
    }
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testNextNode9_eESy8() {
        NodeTypeTest nodeTypeTest = new NodeTypeTest(9);
        SelfContext selfContext = new SelfContext(null, nodeTypeTest);
        NamespaceContext namespaceContext = new NamespaceContext(selfContext, nodeTypeTest);
        PrecedingOrFollowingContext context = new PrecedingOrFollowingContext(namespaceContext, nodeTypeTest, false);
        boolean result = context.nextNode();
        assertFalse(result);
    }
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testNextNode10_OQNZ9() {
        NodeTypeTest nodeTypeTest = new NodeTypeTest(10);
        SelfContext selfContext = new SelfContext(null, nodeTypeTest);
        NamespaceContext namespaceContext = new NamespaceContext(selfContext, nodeTypeTest);
        PrecedingOrFollowingContext context = new PrecedingOrFollowingContext(namespaceContext, nodeTypeTest, true);
        boolean result = context.nextNode();
        assertFalse(result);
    }
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testNextNode11_czem10() {
        NodeTypeTest nodeTypeTest = new NodeTypeTest(11);
        SelfContext selfContext = new SelfContext(null, nodeTypeTest);
        NamespaceContext namespaceContext = new NamespaceContext(selfContext, nodeTypeTest);
        PrecedingOrFollowingContext context = new PrecedingOrFollowingContext(namespaceContext, nodeTypeTest, false);
        boolean result = context.nextNode();
        assertFalse(result);
    }
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testNextNode12_aJRX11() {
        NodeTypeTest nodeTypeTest = new NodeTypeTest(12);
        SelfContext selfContext = new SelfContext(null, nodeTypeTest);
        NamespaceContext namespaceContext = new NamespaceContext(selfContext, nodeTypeTest);
        PrecedingOrFollowingContext context = new PrecedingOrFollowingContext(namespaceContext, nodeTypeTest, true);
        boolean result = context.nextNode();
        assertFalse(result);
    }
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testNextNode13_xVJB12() {
        NodeTypeTest nodeTypeTest = new NodeTypeTest(13);
        SelfContext selfContext = new SelfContext(null, nodeTypeTest);
        NamespaceContext namespaceContext = new NamespaceContext(selfContext, nodeTypeTest);
        PrecedingOrFollowingContext context = new PrecedingOrFollowingContext(namespaceContext, nodeTypeTest, false);
        boolean result = context.nextNode();
        assertFalse(result);
    }
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testNextNode14_Eraf13() {
        NodeTypeTest nodeTypeTest = new NodeTypeTest(14);
        SelfContext selfContext = new SelfContext(null, nodeTypeTest);
        NamespaceContext namespaceContext = new NamespaceContext(selfContext, nodeTypeTest);
        PrecedingOrFollowingContext context = new PrecedingOrFollowingContext(namespaceContext, nodeTypeTest, true);
        boolean result = context.nextNode();
        assertFalse(result);
    }
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testNextNode15_GGSe14() {
        NodeTypeTest nodeTypeTest = new NodeTypeTest(15);
        SelfContext selfContext = new SelfContext(null, nodeTypeTest);
        NamespaceContext namespaceContext = new NamespaceContext(selfContext, nodeTypeTest);
        PrecedingOrFollowingContext context = new PrecedingOrFollowingContext(namespaceContext, nodeTypeTest, false);
        boolean result = context.nextNode();
        assertFalse(result);
    }
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testNextNode16_mRdh15() {
        NodeTypeTest nodeTypeTest = new NodeTypeTest(16);
        SelfContext selfContext = new SelfContext(null, nodeTypeTest);
        NamespaceContext namespaceContext = new NamespaceContext(selfContext, nodeTypeTest);
        PrecedingOrFollowingContext context = new PrecedingOrFollowingContext(namespaceContext, nodeTypeTest, true);
        boolean result = context.nextNode();
        assertFalse(result);
    }
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testNextNode17_aWHX16() {
        NodeTypeTest nodeTypeTest = new NodeTypeTest(17);
        SelfContext selfContext = new SelfContext(null, nodeTypeTest);
        NamespaceContext namespaceContext = new NamespaceContext(selfContext, nodeTypeTest);
        PrecedingOrFollowingContext context = new PrecedingOrFollowingContext(namespaceContext, nodeTypeTest, false);
        boolean result = context.nextNode();
        assertFalse(result);
    }
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testNextNode18_CeYB17() {
        NodeTypeTest nodeTypeTest = new NodeTypeTest(18);
        SelfContext selfContext = new SelfContext(null, nodeTypeTest);
        NamespaceContext namespaceContext = new NamespaceContext(selfContext, nodeTypeTest);
        PrecedingOrFollowingContext context = new PrecedingOrFollowingContext(namespaceContext, nodeTypeTest, true);
        boolean result = context.nextNode();
        assertFalse(result);
    }
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
public void testReset_EoWw0() throws Exception {
    PrecedingOrFollowingContext precedingOrFollowingContext = new PrecedingOrFollowingContext(mockNamespaceContext, mockNodeTypeTest, false);
    Field setStartedField = PrecedingOrFollowingContext.class.getDeclaredField("setStarted");
    setStartedField.setAccessible(true);
    setStartedField.set(precedingOrFollowingContext, true);
    precedingOrFollowingContext.reset();
    assertFalse(setStartedField.getBoolean(precedingOrFollowingContext));
}
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
public void testGetCurrentNodePointer_dbEW0() throws Exception {
    NamespaceContext namespaceContext = mock(NamespaceContext.class);
    NodeTypeTest nodeTypeTest = mock(NodeTypeTest.class);
    NodePointer currentNodePointer = mock(NodePointer.class);
    PrecedingOrFollowingContext precedingOrFollowingContext = new PrecedingOrFollowingContext(namespaceContext, nodeTypeTest, false);
    when(precedingOrFollowingContext.getCurrentNodePointer()).thenReturn(currentNodePointer);
    NodePointer result = precedingOrFollowingContext.getCurrentNodePointer();
}
}