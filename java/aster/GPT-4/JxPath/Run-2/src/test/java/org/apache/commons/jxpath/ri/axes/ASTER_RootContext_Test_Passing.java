/**
 * Generated by Aster
 */
package org.apache.commons.jxpath.ri.axes;
import org.apache.commons.jxpath.Function;
import org.apache.commons.jxpath.JXPathContext;
import org.apache.commons.jxpath.NodeSet;
import org.apache.commons.jxpath.ri.EvalContext;
import org.apache.commons.jxpath.ri.JXPathContextReferenceImpl;
import org.apache.commons.jxpath.ri.QName;
import org.apache.commons.jxpath.ri.model.NodePointer;
import org.apache.commons.jxpath.ri.model.dom.DOMNodePointer;
import org.apache.commons.jxpath.ri.model.VariablePointer;
import static org.junit.jupiter.api.Assertions.*;
import java.util.Locale;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.Timeout;
import org.junit.jupiter.api.Timeout.ThreadMode;
import java.util.concurrent.TimeUnit;
import static org.junit.jupiter.api.Timeout.ThreadMode.SEPARATE_THREAD;
import org.junit.jupiter.api.extension.ExtendWith;
import org.mockito.junit.jupiter.MockitoSettings;
import org.mockito.quality.Strictness;
import org.mockito.InjectMocks;
import org.mockito.InjectMocks;
import org.mockito.Mock;
import org.mockito.junit.jupiter.MockitoExtension;
import static org.mockito.Mockito.*;   
@ExtendWith(MockitoExtension.class)
@MockitoSettings(strictness = Strictness.LENIENT)
public class Aster_RootContext_Test_Passing {
@Mock
    private JXPathContextReferenceImpl jxpathContext;
@Mock
    private DOMNodePointer pointer;
@InjectMocks
    private RootContext rootContext;
@Mock
    private EvalContext expectedEvalContext;
@Mock
    private DOMNodePointer domNodePointer;
@Mock
    private NodePointer mockPointer;
@Mock
    private NodeSet mockNodeSet;
@Mock
    private VariablePointer variablePointer;
@Mock
    private QName variableName;
@Mock
    private Function expectedFunction;
private static final int MAX_REGISTER = 4;
private static final Object UNKNOWN_VALUE = null;
private Object[] registers;
@Mock
    private JXPathContextReferenceImpl mockJXPathContextRefImpl;
@Mock
    private DOMNodePointer mockDOMNodePointer;
    private int availableRegister = 0;
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testSetPosition_ThrowsUnsupportedOperationException() {
        // Initialization of mocks is handled by MockitoExtension
        // Test that setPosition throws UnsupportedOperationException
        assertThrows(UnsupportedOperationException.class, () -> {
            rootContext.setPosition(1);
        });
    }
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testGetJXPathContext() throws Exception {
        // Initialize RootContext with mocked JXPathContextReferenceImpl
        rootContext = new RootContext(jxpathContext, null);
        // Act
        JXPathContext result = rootContext.getJXPathContext();
        // Assert
        assertSame(jxpathContext, result, "The returned JXPathContext should be the same as the mocked JXPathContextReferenceImpl");
    }
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testGetAbsoluteRootContext() throws Exception {
        // Initialize RootContext with mocked JXPathContextReferenceImpl
        rootContext = new RootContext(jxpathContext, null);
        // Setup the behavior of the mocked JXPathContextReferenceImpl
        when(jxpathContext.getAbsoluteRootContext()).thenReturn(expectedEvalContext);
        // Execute the method to test
        EvalContext actualEvalContext = rootContext.getAbsoluteRootContext();
        // Verify the interaction with the mock
        verify(jxpathContext).getAbsoluteRootContext();
        // Assert that the returned EvalContext is the one expected
        assertSame(expectedEvalContext, actualEvalContext, "The returned EvalContext should be the expected one.");
    }
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testNextNode() throws Exception {
        // Initialization of mocks is handled by MockitoExtension
        // Test that nextNode throws UnsupportedOperationException
        assertThrows(UnsupportedOperationException.class, () -> rootContext.nextNode());
    }
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testGetValue() throws Exception {
        rootContext = new RootContext(jxpathContext, domNodePointer);
        when(domNodePointer.getValue()).thenReturn(domNodePointer);
        assertEquals(domNodePointer, rootContext.getValue(), "The getValue method should return the correct NodePointer instance.");
    }
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testNextSet() throws Exception {
        JXPathContextReferenceImpl jxpathContext = mock(JXPathContextReferenceImpl.class);
        DOMNodePointer pointer = mock(DOMNodePointer.class);
        rootContext = new RootContext(jxpathContext, pointer);
        assertThrows(UnsupportedOperationException.class, () -> rootContext.nextSet());
    }
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testGetVariableContext_1() throws Exception {
        // Initialize mocks and the object under test
        when(jxpathContext.getVariablePointer(variableName)).thenReturn(variablePointer);
        rootContext = new RootContext(jxpathContext, domNodePointer);
        // Act
        EvalContext result = rootContext.getVariableContext(variableName);
        // Assert
        // Verify interactions
        verify(jxpathContext).getVariablePointer(variableName);
        assertNotNull(result, "The result should not be null");}
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testGetVariableContext_2() throws Exception {
        // Initialize mocks and the object under test
        when(jxpathContext.getVariablePointer(variableName)).thenReturn(variablePointer);
        rootContext = new RootContext(jxpathContext, domNodePointer);
        // Act
        EvalContext result = rootContext.getVariableContext(variableName);
        // Assert
        // Verify interactions
        verify(jxpathContext).getVariablePointer(variableName);
        assertTrue(result instanceof InitialContext, "The result should be an instance of InitialContext");}
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testGetFunction() throws Exception {
        rootContext = new RootContext(jxpathContext, domNodePointer);
        QName functionName = new QName("testFunction");
        Object[] parameters = new Object[]{"param1", 123, true};
        when(jxpathContext.getFunction(functionName, parameters)).thenReturn(expectedFunction);
        Function result = rootContext.getFunction(functionName, parameters);
        verify(jxpathContext).getFunction(functionName, parameters);
        assertEquals(expectedFunction, result, "The function returned was not as expected.");
    }
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testSetRegisteredValue_StoresValueCorrectly_1() throws Exception {
        JXPathContextReferenceImpl jxpathContext = new JXPathContextReferenceImpl(null, new Object(), null);
        DOMNodePointer pointer = new DOMNodePointer(null, null, null);
        rootContext = new RootContext(jxpathContext, pointer);
        // Test adding a value when registers are not full
        Object testValue1 = new Object();
        int index1 = rootContext.setRegisteredValue(testValue1);
        // Test adding another value
        Object testValue2 = new Object();
        int index2 = rootContext.setRegisteredValue(testValue2);
        // Test adding a third value
        Object testValue3 = new Object();
        int index3 = rootContext.setRegisteredValue(testValue3);
        assertEquals(0, index1, "The value should be stored at index 0");}
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testSetRegisteredValue_StoresValueCorrectly_2() throws Exception {
        JXPathContextReferenceImpl jxpathContext = new JXPathContextReferenceImpl(null, new Object(), null);
        DOMNodePointer pointer = new DOMNodePointer(null, null, null);
        rootContext = new RootContext(jxpathContext, pointer);
        // Test adding a value when registers are not full
        Object testValue1 = new Object();
        int index1 = rootContext.setRegisteredValue(testValue1);
        // Test adding another value
        Object testValue2 = new Object();
        int index2 = rootContext.setRegisteredValue(testValue2);
        // Test adding a third value
        Object testValue3 = new Object();
        int index3 = rootContext.setRegisteredValue(testValue3);
        assertEquals(1, index2, "The value should be stored at index 1");}
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testSetRegisteredValue_StoresValueCorrectly_3() throws Exception {
        JXPathContextReferenceImpl jxpathContext = new JXPathContextReferenceImpl(null, new Object(), null);
        DOMNodePointer pointer = new DOMNodePointer(null, null, null);
        rootContext = new RootContext(jxpathContext, pointer);
        // Test adding a value when registers are not full
        Object testValue1 = new Object();
        int index1 = rootContext.setRegisteredValue(testValue1);
        // Test adding another value
        Object testValue2 = new Object();
        int index2 = rootContext.setRegisteredValue(testValue2);
        // Test adding a third value
        Object testValue3 = new Object();
        int index3 = rootContext.setRegisteredValue(testValue3);
        assertEquals(2, index3, "The value should be stored at index 2");}
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testSetRegisteredValue_ReturnsMinusOneWhenFull() throws Exception {
        JXPathContextReferenceImpl jxpathContext = new JXPathContextReferenceImpl(null, new Object(), null);
        DOMNodePointer pointer = new DOMNodePointer(null, null, null);
        rootContext = new RootContext(jxpathContext, pointer);
        // Fill the registers
        rootContext.setRegisteredValue(new Object());
        rootContext.setRegisteredValue(new Object());
        rootContext.setRegisteredValue(new Object());
        rootContext.setRegisteredValue(new Object());
        // Try to add another value
        Object overflowValue = new Object();
        int overflowIndex = rootContext.setRegisteredValue(overflowValue);
        assertEquals(-1, overflowIndex, "Should return -1 when registers are full");
    }
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testGetCurrentNodePointer() throws Exception {
        // Initialize RootContext with mocked JXPathContextReferenceImpl and NodePointer
        rootContext = new RootContext(jxpathContext, pointer);
        // Setup the behavior of the mocked pointer if needed
        // For example: when(pointer.someMethod()).thenReturn(someValue);
        // Call the method under test
        NodePointer result = rootContext.getCurrentNodePointer();
        // Assert the result
        assertEquals(pointer, result, "The returned NodePointer should be the same as the mocked pointer.");
    }
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testGetRootContext() throws Exception {
        // Initialize RootContext with mocked dependencies
        rootContext = new RootContext(mockJXPathContextRefImpl, mockDOMNodePointer);
        // Act
        RootContext result = rootContext.getRootContext();
        // Assert
        assertSame(rootContext, result, "getRootContext should return the current instance of RootContext");
    }
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
public void testSetRegisteredValue_FirstRegister_MjLr0_EADw0() {
    JXPathContextReferenceImpl jxpathContext = new JXPathContextReferenceImpl(null, new Object(), null);
    DOMNodePointer pointer = new DOMNodePointer(null, Locale.getDefault(), "id");
    RootContext rootContext = new RootContext(jxpathContext, pointer);
    int registerIndex = rootContext.setRegisteredValue("First Value");
    assertEquals(0, registerIndex);
}
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
public void testSetRegisteredValue_SecondRegister_xKIx1_wzIk0() {
    JXPathContextReferenceImpl jxpathContext = new JXPathContextReferenceImpl(null, new Object(), null);
    DOMNodePointer pointer = new DOMNodePointer(null, Locale.getDefault(), null);
    RootContext rootContext = new RootContext(jxpathContext, pointer);
    rootContext.setRegisteredValue("First Value");
    int registerIndex = rootContext.setRegisteredValue("Second Value");
    assertEquals(1, registerIndex);
}
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
public void testSetRegisteredValue_MaxRegisterLimit_sNzW2_fTCv0() {
    JXPathContextReferenceImpl jxpathContext = new JXPathContextReferenceImpl(null, new Object(), null);
    DOMNodePointer pointer = new DOMNodePointer(null, Locale.getDefault(), null);
    RootContext rootContext = new RootContext(jxpathContext, pointer);
    for (int i = 0; i < MAX_REGISTER; i++) {
        rootContext.setRegisteredValue("Value " + i);
    }
    int registerIndex = rootContext.setRegisteredValue("Overflow Value");
    assertEquals(-1, registerIndex);
}
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
public void testSetRegisteredValue_RegisterValueCheck_rSdl3_LDJd0() {
    JXPathContextReferenceImpl jxpathContext = new JXPathContextReferenceImpl(null, new Object(), null);
    DOMNodePointer pointer = new DOMNodePointer(null, Locale.getDefault());
    RootContext rootContext = new RootContext(jxpathContext, pointer);
    int registerIndex = rootContext.setRegisteredValue("Test Value");
    assertEquals("Test Value", rootContext.getRegisteredValue(registerIndex));
}
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
public void testGetRegisteredValue_ValidIndex_ReturnsCorrectValue_yLfF0_2() {
    Object[] registers = new Object[MAX_REGISTER];
    JXPathContextReferenceImpl jxpathContext = null; // Mock or instantiate as required
    DOMNodePointer pointer = null; // Mock or instantiate as required
    RootContext rootContext = new RootContext(jxpathContext, pointer);
}
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
public void testGetRegisteredValue_InvalidIndex_ReturnsUnknownValue_QVku0() {
    Object[] registers = new Object[MAX_REGISTER];
    JXPathContextReferenceImpl jxpathContext = null; // Mock or instantiate as required
    DOMNodePointer pointer = null; // Mock or instantiate as required
    RootContext rootContext = new RootContext(jxpathContext, pointer);
    registers[0] = "FirstValue";
    registers[1] = "SecondValue";
    registers[2] = "ThirdValue";
    registers[3] = "FourthValue";
}
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
public void testGetRootContext_OgwD0() throws Exception {
    JXPathContextReferenceImpl mockJXPathContextRefImpl = mock(JXPathContextReferenceImpl.class);
    DOMNodePointer mockDOMNodePointer = mock(DOMNodePointer.class);
    RootContext rootContext = new RootContext(mockJXPathContextRefImpl, mockDOMNodePointer);
    RootContext result = rootContext.getRootContext();
    assertSame(rootContext, result, "getRootContext should return the current instance of RootContext");
}
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testGetVariableContext() throws Exception {
        // Initialize mocks and the object under test
        when(jxpathContext.getVariablePointer(variableName)).thenReturn(variablePointer);
        rootContext = new RootContext(jxpathContext, domNodePointer);
        // Act
        EvalContext result = rootContext.getVariableContext(variableName);
        // Assert
        assertNotNull(result, "The result should not be null");
        assertTrue(result instanceof InitialContext, "The result should be an instance of InitialContext");
        // Verify interactions
        verify(jxpathContext).getVariablePointer(variableName);
    }
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testSetRegisteredValue_StoresValueCorrectly() throws Exception {
        JXPathContextReferenceImpl jxpathContext = new JXPathContextReferenceImpl(null, new Object(), null);
        DOMNodePointer pointer = new DOMNodePointer(null, null, null);
        rootContext = new RootContext(jxpathContext, pointer);
        // Test adding a value when registers are not full
        Object testValue1 = new Object();
        int index1 = rootContext.setRegisteredValue(testValue1);
        assertEquals(0, index1, "The value should be stored at index 0");
        // Test adding another value
        Object testValue2 = new Object();
        int index2 = rootContext.setRegisteredValue(testValue2);
        assertEquals(1, index2, "The value should be stored at index 1");
        // Test adding a third value
        Object testValue3 = new Object();
        int index3 = rootContext.setRegisteredValue(testValue3);
        assertEquals(2, index3, "The value should be stored at index 2");
    }
}