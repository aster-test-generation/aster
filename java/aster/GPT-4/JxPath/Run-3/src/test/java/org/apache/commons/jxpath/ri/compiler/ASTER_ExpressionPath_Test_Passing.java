/**
 * Generated by Aster
 */
package org.apache.commons.jxpath.ri.compiler;
import org.apache.commons.jxpath.ri.EvalContext;
import org.apache.commons.jxpath.ri.axes.InitialContext;
import org.apache.commons.jxpath.ri.axes.NodeSetContext;
import org.apache.commons.jxpath.ri.model.NodePointer;
import org.apache.commons.jxpath.ri.axes.NamespaceContext;
import org.apache.commons.jxpath.ri.axes.RootContext;
import static org.junit.jupiter.api.Assertions.*;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.Timeout;
import org.junit.jupiter.api.Timeout.ThreadMode;
import java.util.concurrent.TimeUnit;
import static org.mockito.Mockito.*;
import static org.junit.jupiter.api.Timeout.ThreadMode.SEPARATE_THREAD;
import org.junit.jupiter.api.extension.ExtendWith;
import org.mockito.junit.jupiter.MockitoSettings;
import org.mockito.quality.Strictness;
import org.mockito.Mock;
import org.mockito.junit.jupiter.MockitoExtension;   
@ExtendWith(MockitoExtension.class)
@MockitoSettings(strictness = Strictness.LENIENT)
public class Aster_ExpressionPath_Test_Passing {
private ExpressionPath expressionPath;
private EvalContext mockContext;
private Constant mockExpression;
private Expression[] mockPredicates;
private Step[] mockSteps;
@Mock
    private Constant expression;
@Mock
    private Expression[] predicates;
@Mock
    private Step[] steps;
@Mock
    private EvalContext context;
@Mock
    private EvalContext evalContext;
@Mock
    private RootContext rootContext;
@Mock
    private NodePointer nodePointer;
@Mock
    private NodeSetContext nodeSetContext;
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
public void testToStringWithEmptyPredicatesAndSteps_NfKa0() {
    Constant constant = new Constant("Test");
    ExpressionPath expressionPath = new ExpressionPath(constant, null, null);
    assertEquals("Test", expressionPath.toString());
}
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
public void testToStringWithSinglePredicate_RHhk1() {
    Constant constant = new Constant("Test");
    Expression[] predicates = {new Constant(1)};
    ExpressionPath expressionPath = new ExpressionPath(constant, predicates, null);
    assertEquals("Test[1]", expressionPath.toString());
}
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
public void testToStringWithMultiplePredicates_UOIf2() {
    Constant constant = new Constant("Test");
    Expression[] predicates = {new Constant(1), new Constant(2)};
    ExpressionPath expressionPath = new ExpressionPath(constant, predicates, null);
    assertEquals("Test[1][2]", expressionPath.toString());
}
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testIsSimpleExpressionPath_AllTrue_wyGz0() {
        Constant constant = new Constant("test");
        Expression[] predicates = new Expression[]{};
        Step[] steps = new Step[]{};
        ExpressionPath expressionPath = new ExpressionPath(constant, predicates, steps);
        assertTrue(expressionPath.isSimpleExpressionPath());
    }
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testIsSimpleExpressionPath_FalseSimplePath_IRnN1() {
        Constant constant = new Constant(123);
        Expression[] predicates = new Expression[]{};
        Step[] steps = new Step[]{};
        ExpressionPath expressionPath = new ExpressionPath(constant, predicates, steps);
        assertFalse(expressionPath.isSimpleExpressionPath());
    }
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testExpressionPathWithInitialContext() throws Exception {
        // Setup the ExpressionPath with no predicates and no steps
        expressionPath = new ExpressionPath(new Constant("test"), new Expression[0], new Step[0]);
        // Setup
        InitialContext initialContext = mock(InitialContext.class);
        when(expression.compute(evalContext)).thenReturn(initialContext);
        // Execute
        Object result = expressionPath.expressionPath(evalContext, true);
        // Verify
        assertSame(initialContext, result, "The result should be the initial context when expression computes to an InitialContext.");
    }
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testExpressionPathWithSingleNodePointer() throws Exception {
        // Setup the ExpressionPath with no predicates and no steps
        expressionPath = new ExpressionPath(new Constant("test"), new Expression[0], new Step[0]);
        // Setup
        when(expression.compute(evalContext)).thenReturn(nodeSetContext);
        when(nodeSetContext.getSingleNodePointer()).thenReturn(nodePointer);
        when(nodePointer.getIndex()).thenReturn(NodePointer.WHOLE_COLLECTION);
        // Execute
        Object result = expressionPath.expressionPath(evalContext, true);
        // Verify
        assertNotNull(result, "The result should not be null when a single node pointer is available.");
    }
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
public void testToStringWithNestedExpressions_IXWY7_gWUI0() {
    Constant constant = new Constant("Nested");
    ExpressionPath expressionPath = new ExpressionPath(constant, null, null);
    assertEquals("(Nested)", expressionPath.toString());
}
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
public void testComputeValue_RulH0() throws Exception {
    Constant mockExpression = mock(Constant.class);
    EvalContext mockContext = mock(EvalContext.class);
    RootContext mockRootContext = mock(RootContext.class);
    when(mockContext.getRootContext()).thenReturn(mockRootContext);
    ExpressionPath expressionPath = new ExpressionPath(mockExpression, null, null);
    expressionPath.expressionPath(mockContext, true);
    verify(mockContext).getRootContext();
}
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
public void testComputeValue_qSwP0_LXjH0() {
    Constant expression = new Constant("testExpression");
    Expression[] predicates = new Expression[0];
    Step[] steps = new Step[0];
    ExpressionPath expressionPath = new ExpressionPath(expression, predicates, steps);
    NodeTypeTest nodeTypeTest = new NodeTypeTest(1);
    NamespaceContext namespaceContext = new NamespaceContext(null, nodeTypeTest);
    Object result = expressionPath.expressionPath(evalContext, true);
    assertNotNull(result);
}
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
public void testCompute_nJSL0() throws Exception {
    Constant expression = mock(Constant.class);
    Expression[] predicates = new Expression[0];
    Step[] steps = new Step[0];
    ExpressionPath expressionPath = new ExpressionPath(expression, predicates, steps);
    EvalContext context = mock(EvalContext.class);
    Object expectedValue = new Object();
    when(expression.compute(context)).thenReturn(expectedValue);
    Object result = expressionPath.expressionPath(context, false);
}
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
public void testCompute_JYYe0_PJRG0() {
    Constant constant = new Constant("test");
    Expression[] predicates = new Expression[0];
    Step[] steps = new Step[0];
    ExpressionPath expressionPath = new ExpressionPath(constant, predicates, steps);
    NodeTypeTest nodeTypeTest = new NodeTypeTest(1);
    NamespaceContext namespaceContext = new NamespaceContext(null, nodeTypeTest);
    Object result = expressionPath.expressionPath(evalContext, true); // Correct method call
    assertNotNull(result);
}
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
public void testGetExpression_EYib0_gJYI0() {
    Constant constant = new Constant("test");
    assertNotNull(constant);
}
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
public void testExpressionPathWithNullPredicates_tXTz11_Xlfz0() {
    Constant expression = new Constant("nullPredicates");
    Expression[] predicates = null;
    Step[] steps = new Step[0];
    ExpressionPath expressionPath = new ExpressionPath(expression, predicates, steps);
    NamespaceContext namespaceContext = new NamespaceContext(null, new NodeTypeTest(1));
    Object result = expressionPath.expressionPath(evalContext, false);
    assertTrue(result instanceof Object); // Adjust assertion as per actual expected type
}
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
public void testExpressionPathWithSingleNodePointer_TJUR0() throws Exception {
    Constant expression = new Constant("test");
    ExpressionPath expressionPath = new ExpressionPath(expression, new Expression[0], new Step[0]);
    EvalContext evalContext = mock(EvalContext.class);
    RootContext rootContext = mock(RootContext.class);
    NodePointer nodePointer = mock(NodePointer.class);
    when(expression.compute(evalContext)).thenReturn(rootContext);
    when(rootContext.getSingleNodePointer()).thenReturn(nodePointer);
    when(nodePointer.getIndex()).thenReturn(NodePointer.WHOLE_COLLECTION);
    Object result = expressionPath.expressionPath(evalContext, true);
}
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
public void testExpressionPathWithInitialContext_EZsD0() throws Exception {
    Constant constant = new Constant("test");
    Expression[] noPredicates = new Expression[0];
    Step[] noSteps = new Step[0];
    ExpressionPath expressionPath = new ExpressionPath(constant, noPredicates, noSteps);
    EvalContext evalContext = mock(EvalContext.class);
    InitialContext initialContext = mock(InitialContext.class);
    RootContext rootContext = mock(RootContext.class);
    when(evalContext.getRootContext()).thenReturn(rootContext);
    when(rootContext.getConstantContext("test")).thenReturn(initialContext);
    Object result = expressionPath.expressionPath(evalContext, true);
}
}