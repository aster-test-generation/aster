/**
 * Generated by Aster
 */
package org.apache.commons.jxpath.ri.model.container;
import java.util.Locale;
import org.apache.commons.jxpath.Container;
import org.apache.commons.jxpath.ri.QName;
import org.apache.commons.jxpath.ri.compiler.NodeTest;
import org.apache.commons.jxpath.ri.model.NodeIterator;
import org.apache.commons.jxpath.ri.model.NodePointer;
import org.apache.commons.jxpath.util.ValueUtils;
import org.apache.commons.jxpath.ri.model.dom.DOMNodePointer;
import org.apache.commons.jxpath.xml.DocumentContainer;
import org.apache.commons.jxpath.ri.compiler.NodeNameTest;
import static org.junit.jupiter.api.Assertions.*;
import java.util.Collections;
import java.util.Locale;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.Timeout;
import org.junit.jupiter.api.Timeout.ThreadMode;
import java.util.concurrent.TimeUnit;
import static org.mockito.Mockito.*;
import static org.junit.jupiter.api.Timeout.ThreadMode.SEPARATE_THREAD;
import org.junit.jupiter.api.extension.ExtendWith;
import org.mockito.junit.jupiter.MockitoSettings;
import org.mockito.quality.Strictness;
import org.mockito.Mock;
import org.mockito.Mockito;
import org.mockito.Mockito;
import org.mockito.junit.jupiter.MockitoExtension;   
@ExtendWith(MockitoExtension.class)
@MockitoSettings(strictness = Strictness.LENIENT)
public class Aster_ContainerPointer_Test_Passing {
private ContainerPointer containerPointer;
@Mock
    private NodePointer pointer1;
@Mock
    private NodePointer pointer2;
private Container container;
@Mock
    private DocumentContainer documentContainer;
@Mock
    private DOMNodePointer domNodePointer;
@Mock
    private DOMNodePointer domNodePointerMock;
@Mock
    private DocumentContainer documentContainerMock;
@Mock
    private NodeTest nodeTestMock;
@Mock
    private DOMNodePointer parentNode;
@Mock
    private NodePointer mockValuePointer;
@Mock
    private QName mockQName;
@Mock
    private DocumentContainer mockDocumentContainer;
@Mock
    private DOMNodePointer mockDomNodePointer;
@Mock
    private NodeIterator mockNodeIterator;
@Mock
    private DOMNodePointer mockParent;
@Mock
    private DocumentContainer mockContainer;
@Mock
    private NodePointer mockNamespacePointer;
@Mock
    private QName qNameMock;
@Mock
    private NodePointer mockNodePointer;
@Mock
    private DOMNodePointer mockParentNodePointer;
@Mock
    private NodeIterator nodeIteratorMock;
    private NodePointer valuePointer;
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testEquals_SameObject_ReturnsTrue() throws Exception {
        container = mock(Container.class);
        containerPointer = new ContainerPointer(container, Locale.getDefault());
        assertTrue(containerPointer.equals(containerPointer), "Should return true when comparing the same object.");
    }
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testEquals_Null_ReturnsFalse() throws Exception {
        container = mock(Container.class);
        containerPointer = new ContainerPointer(container, Locale.getDefault());
        assertFalse(containerPointer.equals(null), "Should return false when comparing to null.");
    }
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testEquals_DifferentClass_ReturnsFalse() throws Exception {
        container = mock(Container.class);
        containerPointer = new ContainerPointer(container, Locale.getDefault());
        Object differentObject = new Object();
        assertFalse(containerPointer.equals(differentObject), "Should return false when comparing to an object of a different class.");
    }
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testEquals_SameContainer_ReturnsTrue() throws Exception {
        container = mock(Container.class);
        containerPointer = new ContainerPointer(container, Locale.getDefault());
        ContainerPointer anotherPointer = new ContainerPointer(container, Locale.getDefault());
        assertTrue(containerPointer.equals(anotherPointer), "Should return true when comparing two pointers with the same container.");
    }
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testEquals_DifferentContainer_ReturnsFalse() throws Exception {
        container = mock(Container.class);
        containerPointer = new ContainerPointer(container, Locale.getDefault());
        Container differentContainer = mock(Container.class);
        ContainerPointer anotherPointer = new ContainerPointer(differentContainer, Locale.getDefault());
        assertFalse(containerPointer.equals(anotherPointer), "Should return false when comparing two pointers with different containers.");
    }
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testEquals_SameObject_ofVo0() {
        DocumentContainer container = new DocumentContainer(null);
        ContainerPointer pointer = new ContainerPointer(container, Locale.getDefault());
        assertTrue(pointer.equals(pointer));
    }
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testEquals_DifferentClass_bLPK1() {
        DocumentContainer container = new DocumentContainer(null);
        ContainerPointer pointer = new ContainerPointer(container, Locale.getDefault());
        assertFalse(pointer.equals(new Object()));
    }
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testEquals_Null_HVtj2() {
        DocumentContainer container = new DocumentContainer(null);
        ContainerPointer pointer = new ContainerPointer(container, Locale.getDefault());
        assertFalse(pointer.equals(null));
    }
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testEquals_EquivalentObjects_pgIp3() {
        DocumentContainer container1 = new DocumentContainer(null);
        DocumentContainer container2 = new DocumentContainer(null);
        ContainerPointer pointer1 = new ContainerPointer(container1, Locale.getDefault());
        ContainerPointer pointer2 = new ContainerPointer(container2, Locale.getDefault());
        assertTrue(pointer1.equals(pointer2));
    }
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testEquals_NonEquivalentObjects_lBdi4() {
        DocumentContainer container1 = new DocumentContainer(null);
        DocumentContainer container2 = new DocumentContainer(null, "model");
        ContainerPointer pointer1 = new ContainerPointer(container1, Locale.getDefault());
        ContainerPointer pointer2 = new ContainerPointer(container2, Locale.getDefault());
        assertFalse(pointer1.equals(pointer2));
    }
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testSetValue() throws Exception {
        // Initialize ContainerPointer with a DOMNodePointer and a DocumentContainer
        containerPointer = new ContainerPointer(domNodePointer, documentContainer);
        // Arrange
        Object value = new Object();
        // Act
        containerPointer.setValue(value);
        // Assert
        verify(container).setValue(value);
    }
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testIsCollectionTrue() throws Exception {
        // Assuming DocumentContainer and DOMNodePointer are correctly instantiated or mocked
        containerPointer = new ContainerPointer(domNodePointer, documentContainer);
        // Mock the behavior of getBaseValue to return a collection type
        when(domNodePointer.getBaseValue()).thenReturn(java.util.Collections.singletonList("example"));
        // Execute the method under test
        boolean result = containerPointer.isCollection();
        // Assert the result is true
        assertTrue(result, "isCollection should return true when base value is a collection");
    }
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testIsCollectionFalse() throws Exception {
        // Assuming DocumentContainer and DOMNodePointer are correctly instantiated or mocked
        containerPointer = new ContainerPointer(domNodePointer, documentContainer);
        // Mock the behavior of getBaseValue to return a non-collection type
        when(domNodePointer.getBaseValue()).thenReturn("Not a collection");
        // Execute the method under test
        boolean result = containerPointer.isCollection();
        // Assert the result is false
        assertFalse(result, "isCollection should return false when base value is not a collection");
    }
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
public void testIsCollectionWithEmptyCollection_GmyU0() {
    DocumentContainer documentContainer = new DocumentContainer(null);
    ContainerPointer containerPointer = new ContainerPointer(documentContainer, Locale.getDefault());
    assertFalse(containerPointer.isCollection());
}
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
public void testIsCollectionWithNonEmptyCollection_ToqY1() {
    DocumentContainer documentContainer = new DocumentContainer(null);
    ContainerPointer containerPointer = new ContainerPointer(documentContainer, Locale.getDefault());
    assertTrue(containerPointer.isCollection());
}
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
public void testIsCollectionWithNull_tJiA2() {
    ContainerPointer containerPointer = new ContainerPointer((DocumentContainer) null, Locale.getDefault());
    assertFalse(containerPointer.isCollection());
}
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testIsContainer() throws Exception {
        // Since ContainerPointer and its method isContainer() do not interact with its internal state
        // related to the DocumentContainer or DOMNodePointer, we can safely mock these dependencies.
        DocumentContainer mockDocumentContainer = mock(DocumentContainer.class);
        Locale mockLocale = mock(Locale.class);
        containerPointer = new ContainerPointer(mockDocumentContainer, mockLocale);
        // Act
        boolean result = containerPointer.isContainer();
        // Assert
        assertTrue(result, "isContainer should always return true");
    }
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
public void testIsContainer_WSSi0() {
    DocumentContainer container = new DocumentContainer(null);
    ContainerPointer containerPointer = new ContainerPointer(container, Locale.getDefault());
    assertTrue(containerPointer.isContainer());
}
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
public void testHashCode_hNba0() {
    DocumentContainer container = new DocumentContainer(null);
    ContainerPointer containerPointer = new ContainerPointer(container, Locale.getDefault());
    int expectedHashCode = System.identityHashCode(container) + 0; // Assuming 'index' is 0 as it's not defined in the provided context
    assertEquals(expectedHashCode, containerPointer.hashCode());
}
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testAttributeIterator() throws Exception {
        containerPointer = new ContainerPointer(mockDomNodePointer, mockDocumentContainer);
        QName qName = new QName("testName");
        when(mockDomNodePointer.attributeIterator(qName)).thenReturn(mockNodeIterator);
        NodeIterator result = containerPointer.attributeIterator(qName);
        assertNotNull(result, "The result should not be null");
        verify(mockDomNodePointer).attributeIterator(qName);
    }
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testNamespacePointer_1() throws Exception {
        // Initialize ContainerPointer with mocked DOMNodePointer and DocumentContainer
        containerPointer = new ContainerPointer(mockParent, mockContainer);
        // Setup the behavior of mocked objects
        when(mockParent.getValuePointer()).thenReturn(mockValuePointer);
        when(mockValuePointer.namespacePointer(anyString())).thenReturn(mockNamespacePointer);
        // Define the namespace to test
        String namespace = "http://example.com/ns";
        // Execute the method under test
        NodePointer result = containerPointer.namespacePointer(namespace);
        // Verify interactions
        verify(mockValuePointer).namespacePointer(namespace);
        // Assertions
        assertNotNull(result, "The result should not be null.");}
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testNamespacePointer_2() throws Exception {
        // Initialize ContainerPointer with mocked DOMNodePointer and DocumentContainer
        containerPointer = new ContainerPointer(mockParent, mockContainer);
        // Setup the behavior of mocked objects
        when(mockParent.getValuePointer()).thenReturn(mockValuePointer);
        when(mockValuePointer.namespacePointer(anyString())).thenReturn(mockNamespacePointer);
        // Define the namespace to test
        String namespace = "http://example.com/ns";
        // Execute the method under test
        NodePointer result = containerPointer.namespacePointer(namespace);
        // Verify interactions
        verify(mockValuePointer).namespacePointer(namespace);
        // Assertions
        assertEquals(mockNamespacePointer, result, "The returned NodePointer should match the mock.");}
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testGetName() throws Exception {
        // Initialize ContainerPointer with a mocked DOMNodePointer and DocumentContainer
        containerPointer = new ContainerPointer(domNodePointerMock, documentContainerMock);
        // Setup mock behavior
        when(domNodePointerMock.getName()).thenReturn(qNameMock);
        when(qNameMock.getName()).thenReturn("ExpectedName");
        // Act
        QName result = containerPointer.getName();
        // Assert
        assertEquals("ExpectedName", result.getName(), "The name returned was not as expected");
    }
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
public void testGetNameReturnsNull_UAJI0() {
    DocumentContainer container = new DocumentContainer(null);
    ContainerPointer containerPointer = new ContainerPointer(container, Locale.getDefault());
    QName result = containerPointer.getName();
    assertNull(result);
}
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testAsPath_WithParent() throws Exception {
        // Scenario where the container pointer has a parent node pointer
        when(mockParentNodePointer.asPath()).thenReturn("/parent/path");
        // Initialize ContainerPointer with a parent
        containerPointer = new ContainerPointer(mockParentNodePointer, mockDocumentContainer);
        // Execute
        String result = containerPointer.asPath();
        // Verify
        assertEquals("/parent/path", result, "The path should be the same as the parent's path.");
    }
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testAsPath_WithoutParent() throws Exception {
        // Scenario where the container pointer has a parent node pointer
        when(mockParentNodePointer.asPath()).thenReturn("/parent/path");
        // Initialize ContainerPointer with a parent
        containerPointer = new ContainerPointer(mockParentNodePointer, mockDocumentContainer);
        // Setup for scenario without a parent
        ContainerPointer containerPointerNoParent = new ContainerPointer(mockDocumentContainer, null);
        // Execute
        String result = containerPointerNoParent.asPath();
        // Verify
        assertEquals("/", result, "The path should be root '/' when there is no parent.");
    }
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testAsPathRoot_JVph0() {
        DocumentContainer container = new DocumentContainer(null);
        ContainerPointer pointer = new ContainerPointer(container, null);
        String expected = "/";
        String actual = pointer.asPath();
        assertEquals(expected, actual);
    }
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testGetLength_BaseValueNull_ReturnsOne() throws Exception {
        containerPointer = new ContainerPointer(mockDomNodePointer, mockDocumentContainer);
        // Arrange
        when(mockDomNodePointer.getBaseValue()).thenReturn(null);
        // Act
        int length = containerPointer.getLength();
        // Assert
        assertEquals(1, length, "Length should be 1 when base value is null");
    }
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testGetLength_BaseValueNotNull_ReturnsCalculatedLength() throws Exception {
        containerPointer = new ContainerPointer(mockDomNodePointer, mockDocumentContainer);
        // Arrange
        Object baseValue = new Object(); // Assuming getBaseValue returns an Object
        when(mockDomNodePointer.getBaseValue()).thenReturn(baseValue);
        int expectedLength = 5; // Assuming ValueUtils.getLength returns 5 for the given baseValue
        when(ValueUtils.getLength(baseValue)).thenReturn(expectedLength);
        // Act
        int length = containerPointer.getLength();
        // Assert
        assertEquals(expectedLength, length, "Length should match the calculated value from ValueUtils.getLength");
    }
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testGetLength_BaseValueNull_QPEs0() {
        DocumentContainer docContainer = new DocumentContainer(null);
        ContainerPointer containerPointer = new ContainerPointer(docContainer, Locale.getDefault());
        int length = containerPointer.getLength();
        assertEquals(1, length);
    }
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testGetLength_BaseValueNotNull_fxOQ1() {
        DocumentContainer docContainer = new DocumentContainer(null);
        ContainerPointer containerPointer = new ContainerPointer(docContainer, Locale.getDefault());
        int length = containerPointer.getLength();
        assertEquals(3, length);
    }
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testGetNamespaceURI() throws Exception {
        // Setup the DOMNodePointer to use a mocked DocumentContainer
        containerPointer = new ContainerPointer(mockDomNodePointer, mockDocumentContainer);
        // Setup the behavior of the DOMNodePointer to return the mock ValuePointer
        when(mockDomNodePointer.getValuePointer()).thenReturn(mockValuePointer);
        // Define the prefix and the expected URI
        String prefix = "xmlns";
        String expectedNamespaceURI = "http://www.example.com";
        // Configure the mock to return the expected URI when getNamespaceURI is called
        when(mockValuePointer.getNamespaceURI(prefix)).thenReturn(expectedNamespaceURI);
        // Call the method under test
        String result = containerPointer.getNamespaceURI(prefix);
        // Verify the interaction with the mock
        verify(mockValuePointer).getNamespaceURI(prefix);
        // Assert that the result is as expected
        assertEquals(expectedNamespaceURI, result, "The namespace URI should match the expected value.");
    }
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testGetBaseValue() throws Exception {
        // Mocking the necessary dependencies for ContainerPointer
        when(domNodePointer.getNode()).thenReturn(null); // Assuming getNode method exists for the sake of example
        containerPointer = new ContainerPointer(domNodePointer, documentContainer);
        // Setup the behavior of the getBaseValue to return the mocked container
        when(containerPointer.getBaseValue()).thenReturn(container);
        // Execute the method under test
        Object result = containerPointer.getBaseValue();
        // Verify the result
        assertEquals(container, result, "The returned container should match the mocked container instance");
    }
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testIsLeaf_True() throws Exception {
        // Assuming ValuePointer is an interface or a class that has the isLeaf method.
        // Setup the necessary mocking relationships
        when(domNodePointer.getValuePointer()).thenReturn(valuePointer);
        containerPointer = new ContainerPointer(domNodePointer, documentContainer);
        // Setup the condition
        when(valuePointer.isLeaf()).thenReturn(true);
        // Execute the method under test
        boolean result = containerPointer.isLeaf();
        // Verify the result
        assertTrue(result, "The isLeaf method should return true when the delegated ValuePointer returns true");
    }
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testIsLeaf_False() throws Exception {
        // Assuming ValuePointer is an interface or a class that has the isLeaf method.
        // Setup the necessary mocking relationships
        when(domNodePointer.getValuePointer()).thenReturn(valuePointer);
        containerPointer = new ContainerPointer(domNodePointer, documentContainer);
        // Setup the condition
        when(valuePointer.isLeaf()).thenReturn(false);
        // Execute the method under test
        boolean result = containerPointer.isLeaf();
        // Verify the result
        assertFalse(result, "The isLeaf method should return false when the delegated ValuePointer returns false");
    }
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testNamespaceIterator_1() throws Exception {
        // Initialize ContainerPointer with mocked DOMNodePointer and DocumentContainer
        containerPointer = new ContainerPointer(domNodePointerMock, documentContainerMock);
        when(domNodePointerMock.namespaceIterator()).thenReturn(nodeIteratorMock);
        // Act
        NodeIterator result = containerPointer.namespaceIterator();
        // Assert
        verify(domNodePointerMock).namespaceIterator(); // Verify that namespaceIterator was called on the mock
        assertNotNull(result, "The result should not be null");}
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testNamespaceIterator_2() throws Exception {
        // Initialize ContainerPointer with mocked DOMNodePointer and DocumentContainer
        containerPointer = new ContainerPointer(domNodePointerMock, documentContainerMock);
        when(domNodePointerMock.namespaceIterator()).thenReturn(nodeIteratorMock);
        // Act
        NodeIterator result = containerPointer.namespaceIterator();
        // Assert
        verify(domNodePointerMock).namespaceIterator(); // Verify that namespaceIterator was called on the mock
        assertEquals(nodeIteratorMock, result, "The returned NodeIterator should be the one provided by the mocked DOMNodePointer");}
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
public void testCompareChildNodePointers_SameIndex_hyjA0() throws Exception {
    Locale defaultLocale = Locale.getDefault();
    DocumentContainer documentContainer = new DocumentContainer(null);
    ContainerPointer containerPointer = new ContainerPointer(documentContainer, defaultLocale);
    when(pointer1.getIndex()).thenReturn(1);
    when(pointer2.getIndex()).thenReturn(1);
    int result = containerPointer.compareChildNodePointers(pointer1, pointer2);
    assertEquals(0, result, "Expected both pointers to have the same index");
}
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
public void testCompareChildNodePointers_SecondHigher_daqd0() throws Exception {
    Locale defaultLocale = Locale.getDefault();
    DocumentContainer documentContainer = new DocumentContainer(null, null);
    ContainerPointer containerPointer = new ContainerPointer(documentContainer, defaultLocale);
    DOMNodePointer pointer1 = mock(DOMNodePointer.class);
    DOMNodePointer pointer2 = mock(DOMNodePointer.class);
    when(pointer1.getIndex()).thenReturn(1);
    when(pointer2.getIndex()).thenReturn(2);
    int result = containerPointer.compareChildNodePointers(pointer1, pointer2);
    assertEquals(-1, result, "Expected pointer2 to have a higher index than pointer1");
}
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
public void testGetImmediateNodeReturnsCorrectValue_RWJc0() throws Exception {
    ContainerPointer containerPointer = new ContainerPointer(domNodePointerMock, documentContainerMock);
    Object expectedValue = new Object();
    when(containerPointer.getBaseValue()).thenReturn(expectedValue);
    when(containerPointer.getLength()).thenReturn(1); // Assuming there's at least one item
    Object result = containerPointer.getImmediateNode();
}
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
public void testGetImmediateNodeReturnsNullForInvalidIndex_oLIT0() throws Exception {
    ContainerPointer containerPointer = new ContainerPointer(domNodePointerMock, documentContainerMock);
    when(containerPointer.getBaseValue()).thenReturn(new Object());
    when(containerPointer.getLength()).thenReturn(1); // Assuming there's at least one item
    containerPointer.setIndex(-1); // Correctly setting invalid index using setter method
    Object result = containerPointer.getImmediateNode();
}
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
public void testGetImmediateNodeReturnsWholeCollection_dmUZ0() throws Exception {
    ContainerPointer containerPointer = new ContainerPointer(domNodePointerMock, documentContainerMock);
    Object expectedCollection = new Object();
    when(containerPointer.getBaseValue()).thenReturn(expectedCollection);
    when(containerPointer.getIndex()).thenReturn(ContainerPointer.WHOLE_COLLECTION);
    Object result = containerPointer.getImmediateNode();
}
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
public void testGetImmediateNode_WholeCollection_Lkxi0_Ochu0() {
    DocumentContainer container = new DocumentContainer(null);
    ContainerPointer cp = new ContainerPointer(container, Locale.getDefault());
    cp.setIndex(-1); // WHOLE_COLLECTION using setter method
    Object result = cp.getImmediateNode();
    assertNull(result, "Expected null for whole collection with no base value");
}
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
public void testGetImmediateNode_InvalidIndex_Xdmp2_hiwc0() {
    DocumentContainer container = new DocumentContainer(null);
    ContainerPointer cp = new ContainerPointer(container, Locale.getDefault());
    cp.setIndex(2); // Correct way to set index using a setter method
    ContainerPointer spyCp = Mockito.spy(cp);
    Mockito.when(spyCp.getBaseValue()).thenReturn(new Object[]{ "test" });
    Object result = spyCp.getImmediateNode();
    assertNull(result, "Expected null for an invalid index");
}
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
public void testGetImmediateNode_NegativeIndex_LsCK3_oWnu0() {
    DocumentContainer container = new DocumentContainer(null);
    ContainerPointer cp = new ContainerPointer(container, Locale.getDefault());
    cp.setIndex(-2); // Correctly setting the index using a setter method
    Object result = cp.getImmediateNode();
    assertNull(result, "Expected null for a negative index");
}
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
public void testChildIterator_nXZB0() throws Exception {
    when(mockNodePointer.childIterator(any(NodeTest.class), anyBoolean(), any(NodePointer.class)))
        .thenReturn(mockNodeIterator);
    NodeTest test = new NodeNameTest(new QName("testNode"));
    boolean reverse = false;
    NodePointer startWith = null;
    NodeIterator result = containerPointer.childIterator(test, reverse, startWith);
    verify(mockNodePointer).childIterator(test, reverse, startWith);
}
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
public void testAsPathWithParent_qWDU1_FegB0() {
    org.w3c.dom.Node node = mock(org.w3c.dom.Node.class); // Corrected and mocked Node
    Locale locale = Locale.getDefault();
    DOMNodePointer domNodePointer = new DOMNodePointer(node, locale);
    DocumentContainer container = new DocumentContainer(null);
    ContainerPointer pointer = new ContainerPointer(domNodePointer, container);
    String expected = domNodePointer.asPath();
    String actual = pointer.asPath();
    assertEquals(expected, actual);
}
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
public void testNamespaceIterator_bTOI0() throws Exception {
    ContainerPointer containerPointer = new ContainerPointer(domNodePointerMock, documentContainerMock);
    when(domNodePointerMock.namespaceIterator()).thenReturn(nodeIteratorMock);
    NodeIterator result = containerPointer.namespaceIterator();
    verify(domNodePointerMock).namespaceIterator(); // Verify that namespaceIterator was called on the mock
}
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testNamespacePointer() throws Exception {
        // Initialize ContainerPointer with mocked DOMNodePointer and DocumentContainer
        containerPointer = new ContainerPointer(mockParent, mockContainer);
        // Setup the behavior of mocked objects
        when(mockParent.getValuePointer()).thenReturn(mockValuePointer);
        when(mockValuePointer.namespacePointer(anyString())).thenReturn(mockNamespacePointer);
        // Define the namespace to test
        String namespace = "http://example.com/ns";
        // Execute the method under test
        NodePointer result = containerPointer.namespacePointer(namespace);
        // Verify interactions
        verify(mockValuePointer).namespacePointer(namespace);
        // Assertions
        assertNotNull(result, "The result should not be null.");
        assertEquals(mockNamespacePointer, result, "The returned NodePointer should match the mock.");
    }
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testNamespaceIterator() throws Exception {
        // Initialize ContainerPointer with mocked DOMNodePointer and DocumentContainer
        containerPointer = new ContainerPointer(domNodePointerMock, documentContainerMock);
        when(domNodePointerMock.namespaceIterator()).thenReturn(nodeIteratorMock);
        // Act
        NodeIterator result = containerPointer.namespaceIterator();
        // Assert
        assertNotNull(result, "The result should not be null");
        assertEquals(nodeIteratorMock, result, "The returned NodeIterator should be the one provided by the mocked DOMNodePointer");
        verify(domNodePointerMock).namespaceIterator(); // Verify that namespaceIterator was called on the mock
    }
}