/**
 * Generated by Aster
 */
package org.apache.commons.jxpath.ri.model.dom;
import java.util.Locale;
import org.apache.commons.jxpath.JXPathContext;
import org.apache.commons.jxpath.JXPathException;
import org.apache.commons.jxpath.ri.Compiler;
import org.apache.commons.jxpath.ri.NamespaceResolver;
import org.apache.commons.jxpath.ri.QName;
import org.apache.commons.jxpath.ri.compiler.NodeNameTest;
import org.apache.commons.jxpath.ri.compiler.NodeTest;
import org.apache.commons.jxpath.ri.compiler.NodeTypeTest;
import org.apache.commons.jxpath.ri.compiler.ProcessingInstructionTest;
import org.apache.commons.jxpath.ri.model.NodeIterator;
import org.apache.commons.jxpath.ri.model.NodePointer;
import org.w3c.dom.Attr;
import org.w3c.dom.Comment;
import org.w3c.dom.Document;
import org.w3c.dom.Element;
import org.w3c.dom.NamedNodeMap;
import org.w3c.dom.Node;
import org.w3c.dom.NodeList;
import org.w3c.dom.ProcessingInstruction;
import org.apache.commons.jxpath.AbstractFactory;
import static org.junit.jupiter.api.Assertions.*;
import java.util.Locale;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.Timeout;
import org.junit.jupiter.api.Timeout.ThreadMode;
import java.util.concurrent.TimeUnit;
import static org.mockito.Mockito.*;
import static org.junit.jupiter.api.Timeout.ThreadMode.SEPARATE_THREAD;
import org.junit.jupiter.api.extension.ExtendWith;
import org.mockito.junit.jupiter.MockitoSettings;
import org.mockito.quality.Strictness;
import org.mockito.InjectMocks;
import org.mockito.InjectMocks;
import org.mockito.Mock;
import org.mockito.Mockito;
import org.mockito.Mockito;
import org.mockito.junit.jupiter.MockitoExtension;   
@ExtendWith(MockitoExtension.class)
@MockitoSettings(strictness = Strictness.LENIENT)
public class Aster_DOMNodePointer_Test_Failing {
private String defaultNamespace;
private NamespaceResolver localNamespaceResolver;
@Mock
    private Node node;
@Mock
    private NodePointer nodePointer1;
@Mock
    private NodePointer nodePointer2;
@Mock
    private NamedNodeMap namedNodeMap;
@InjectMocks
    private DOMNodePointer domNodePointer;
@Mock
    private NodeTest nodeTest;
@Mock
    private NodeList nodeList;
@Mock
    private Document document;
@Mock
    private Node parentNode;
@Mock
    private JXPathContext context;
@Mock
    private AbstractFactory abstractFactory;
@Mock
    private NodeIterator nodeIterator;
Element element;
@Mock
    private Locale locale;
@Mock
    private NodePointer startWith;
@Mock
    private NodePointer nodePointer;
@Mock
    private NamespaceResolver namespaceResolver;
@Mock
    private Node anotherNode;
@Mock
    private Attr attr;
@Mock
    private Comment commentNode;
private final String id = "testId";
    private DOMNodePointer parent;
@Mock
    private NamespaceResolver parentNamespaceResolver;
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testCompareChildNodePointers_DifferentNodes_1() throws Exception {
        when(nodePointer1.getBaseValue()).thenReturn(node);
        when(nodePointer2.getBaseValue()).thenReturn(node);
        when(node.getAttributes()).thenReturn(namedNodeMap);
        when(namedNodeMap.getLength()).thenReturn(1);
        Node node1 = mock(Node.class);
        Node node2 = mock(Node.class);
        when(nodePointer1.getBaseValue()).thenReturn(node1);
        when(nodePointer2.getBaseValue()).thenReturn(node2);
        when(node.getFirstChild()).thenReturn(node1);
        when(node1.getNextSibling()).thenReturn(node2);
        int result = domNodePointer.compareChildNodePointers(nodePointer1, nodePointer2);
        result = domNodePointer.compareChildNodePointers(nodePointer2, nodePointer1);
        assertEquals(-1, result, "Should return0 when node1 comes before node2");}
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testCompareChildNodePointers_AttributeNodes_1() throws Exception {
        when(nodePointer1.getBaseValue()).thenReturn(node);
        when(nodePointer2.getBaseValue()).thenReturn(node);
        when(node.getAttributes()).thenReturn(namedNodeMap);
        when(namedNodeMap.getLength()).thenReturn(1);
        Node attributeNode1 = mock(Node.class);
        Node attributeNode2 = mock(Node.class);
        when(nodePointer1.getBaseValue()).thenReturn(attributeNode1);
        when(nodePointer2.getBaseValue()).thenReturn(attributeNode2);
        when(attributeNode1.getNodeType()).thenReturn(Node.ATTRIBUTE_NODE);
        when(attributeNode2.getNodeType()).thenReturn(Node.ATTRIBUTE_NODE);
        when(node.getAttributes()).thenReturn(namedNodeMap);
        when(namedNodeMap.item(0)).thenReturn(attributeNode1);
        when(namedNodeMap.getLength()).thenReturn(2);
        int result = domNodePointer.compareChildNodePointers(nodePointer1, nodePointer2);
        when(namedNodeMap.item(0)).thenReturn(attributeNode2);
        result = domNodePointer.compareChildNodePointers(nodePointer1, nodePointer2);
        assertEquals(-1, result, "Should return -1 when attributeNode1 is before attributeNode2 in the attributes map");}
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testSetValueWithTextNodeAndNonEmptyString() throws Exception {
        when(node.getNodeType()).thenReturn(Node.TEXT_NODE);
        when(node.getChildNodes()).thenReturn(nodeList);
        when(node.getOwnerDocument()).thenReturn(document);
        when(node.getParentNode()).thenReturn(parentNode);
        String testValue = "Test String";
        when(node.getNodeType()).thenReturn(Node.TEXT_NODE);
        domNodePointer.setValue(testValue);
        verify(node, times(1)).setNodeValue(testValue);
    }
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testSetValueWithNonTextNodeAndNodeValue() throws Exception {
        when(node.getNodeType()).thenReturn(Node.TEXT_NODE);
        when(node.getChildNodes()).thenReturn(nodeList);
        when(node.getOwnerDocument()).thenReturn(document);
        when(node.getParentNode()).thenReturn(parentNode);
        Node inputNode = mock(Node.class);
        when(inputNode.cloneNode(true)).thenReturn(inputNode);
        when(node.getNodeType()).thenReturn(Node.ELEMENT_NODE);
        when(nodeList.getLength()).thenReturn(0); // No children initially
        domNodePointer.setValue(inputNode);
        verify(node, times(1)).appendChild(inputNode);
    }
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testSetValueWithNonTextNodeAndRemovingChildren() throws Exception {
        when(node.getNodeType()).thenReturn(Node.TEXT_NODE);
        when(node.getChildNodes()).thenReturn(nodeList);
        when(node.getOwnerDocument()).thenReturn(document);
        when(node.getParentNode()).thenReturn(parentNode);
        when(node.getNodeType()).thenReturn(Node.ELEMENT_NODE);
        when(nodeList.getLength()).thenReturn(2); // Two children initially
        when(nodeList.item(anyInt())).thenReturn(mock(Node.class));
        domNodePointer.setValue(null);
        verify(node, times(2)).removeChild(any(Node.class));
    }
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testHashCode() throws Exception {
        domNodePointer = new DOMNodePointer(node, Locale.getDefault());
        int expectedHashCode = node.hashCode();
        when(node.hashCode()).thenReturn(expectedHashCode);
        int actualHashCode = domNodePointer.hashCode();
        assertEquals(expectedHashCode, actualHashCode, "The hash code should match the hash code of the node object.");
    }
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testGetName_ProcessingInstructionNode_1() throws Exception {
        domNodePointer = new DOMNodePointer(node, null);
        // Setup for PROCESSING_INSTRUCTION_NODE
        ProcessingInstruction pi = mock(ProcessingInstruction.class);
        when(node.getNodeType()).thenReturn(Node.PROCESSING_INSTRUCTION_NODE);
        when(pi.getTarget()).thenReturn("target");
        when(node).thenReturn(pi);
        // Execute
        QName result = domNodePointer.getName();
        // Verify
        assertEquals(null, result.getPrefix());}
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testGetName_ProcessingInstructionNode_2() throws Exception {
        domNodePointer = new DOMNodePointer(node, null);
        // Setup for PROCESSING_INSTRUCTION_NODE
        ProcessingInstruction pi = mock(ProcessingInstruction.class);
        when(node.getNodeType()).thenReturn(Node.PROCESSING_INSTRUCTION_NODE);
        when(pi.getTarget()).thenReturn("target");
        when(node).thenReturn(pi);
        // Execute
        QName result = domNodePointer.getName();
        // Verify
        assertEquals("target", result.getName());}
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testGetNamespaceURI_WhenNodeHasNamespace() throws Exception {
        domNodePointer = new DOMNodePointer(node, null);
        String expectedNamespaceURI = "http://example.com/ns";
        when(node.getNamespaceURI()).thenReturn(expectedNamespaceURI);
        String result = domNodePointer.getNamespaceURI();
        assertEquals(expectedNamespaceURI, result, "The namespace URI should match the expected value.");
    }
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testGetNamespaceURI_WhenNodeHasNoNamespace() throws Exception {
        domNodePointer = new DOMNodePointer(node, null);
        when(node.getNamespaceURI()).thenReturn(null);
        String result = domNodePointer.getNamespaceURI();
        assertEquals(null, result, "The namespace URI should be null when the node has no namespace.");
    }
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testGetNamespaceURI_NullNode_egpg0() throws Exception {
        Node node = null;
        DOMNodePointer domNodePointer = new DOMNodePointer(node, Locale.getDefault());
        assertNull("Expected null namespace URI for null Node", domNodePointer.getNamespaceURI());
    }
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testCreateAttributeWithNamespace_1() throws Exception {
        when(element.getNamespaceURI()).thenReturn("http://example.com");
        when(nodePointer.getNamespaceResolver()).thenReturn(namespaceResolver);
        when(namespaceResolver.getNamespaceURI("ex")).thenReturn("http://example.com");
        when(nodeIterator.getNodePointer()).thenReturn(nodePointer);
        when(nodePointer.createAttribute(context, new QName("ex", "test"))).thenReturn(nodePointer);
        QName qName = new QName("ex", "test");
        when(element.hasAttributeNS("http://example.com", "test")).thenReturn(false);
        NodePointer result = domNodePointer.createAttribute(context, qName);
        verify(element).setAttributeNS("http://example.com", "ex:test", "");
        assertNotNull(result);}
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testCreateAttributeWithNamespace_2() throws Exception {
        when(element.getNamespaceURI()).thenReturn("http://example.com");
        when(nodePointer.getNamespaceResolver()).thenReturn(namespaceResolver);
        when(namespaceResolver.getNamespaceURI("ex")).thenReturn("http://example.com");
        when(nodeIterator.getNodePointer()).thenReturn(nodePointer);
        when(nodePointer.createAttribute(context, new QName("ex", "test"))).thenReturn(nodePointer);
        QName qName = new QName("ex", "test");
        when(element.hasAttributeNS("http://example.com", "test")).thenReturn(false);
        NodePointer result = domNodePointer.createAttribute(context, qName);
        verify(element).setAttributeNS("http://example.com", "ex:test", "");
        assertEquals(nodePointer, result);}
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testCreateAttributeWithoutNamespace_1() throws Exception {
        when(element.getNamespaceURI()).thenReturn("http://example.com");
        when(nodePointer.getNamespaceResolver()).thenReturn(namespaceResolver);
        when(namespaceResolver.getNamespaceURI("ex")).thenReturn("http://example.com");
        when(nodeIterator.getNodePointer()).thenReturn(nodePointer);
        when(nodePointer.createAttribute(context, new QName("ex", "test"))).thenReturn(nodePointer);
        QName qName = new QName("test");
        when(element.hasAttribute("test")).thenReturn(false);
        NodePointer result = domNodePointer.createAttribute(context, qName);
        verify(element).setAttribute("test", "");
        assertNotNull(result);}
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testCreateAttributeWithoutNamespace_2() throws Exception {
        when(element.getNamespaceURI()).thenReturn("http://example.com");
        when(nodePointer.getNamespaceResolver()).thenReturn(namespaceResolver);
        when(namespaceResolver.getNamespaceURI("ex")).thenReturn("http://example.com");
        when(nodeIterator.getNodePointer()).thenReturn(nodePointer);
        when(nodePointer.createAttribute(context, new QName("ex", "test"))).thenReturn(nodePointer);
        QName qName = new QName("test");
        when(element.hasAttribute("test")).thenReturn(false);
        NodePointer result = domNodePointer.createAttribute(context, qName);
        verify(element).setAttribute("test", "");
        assertEquals(nodePointer, result);}
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testCreateAttributeWithExistingAttribute_1() throws Exception {
        when(element.getNamespaceURI()).thenReturn("http://example.com");
        when(nodePointer.getNamespaceResolver()).thenReturn(namespaceResolver);
        when(namespaceResolver.getNamespaceURI("ex")).thenReturn("http://example.com");
        when(nodeIterator.getNodePointer()).thenReturn(nodePointer);
        when(nodePointer.createAttribute(context, new QName("ex", "test"))).thenReturn(nodePointer);
        QName qName = new QName("test");
        when(element.hasAttribute("test")).thenReturn(true);
        NodePointer result = domNodePointer.createAttribute(context, qName);
        verify(element, never()).setAttribute("test", "");
        assertNotNull(result);}
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testCreateAttributeWithExistingAttribute_2() throws Exception {
        when(element.getNamespaceURI()).thenReturn("http://example.com");
        when(nodePointer.getNamespaceResolver()).thenReturn(namespaceResolver);
        when(namespaceResolver.getNamespaceURI("ex")).thenReturn("http://example.com");
        when(nodeIterator.getNodePointer()).thenReturn(nodePointer);
        when(nodePointer.createAttribute(context, new QName("ex", "test"))).thenReturn(nodePointer);
        QName qName = new QName("test");
        when(element.hasAttribute("test")).thenReturn(true);
        NodePointer result = domNodePointer.createAttribute(context, qName);
        verify(element, never()).setAttribute("test", "");
        assertEquals(nodePointer, result);}
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testCreateAttributeWithUnknownNamespacePrefix_1() throws Exception {
        when(element.getNamespaceURI()).thenReturn("http://example.com");
        when(nodePointer.getNamespaceResolver()).thenReturn(namespaceResolver);
        when(namespaceResolver.getNamespaceURI("ex")).thenReturn("http://example.com");
        when(nodeIterator.getNodePointer()).thenReturn(nodePointer);
        when(nodePointer.createAttribute(context, new QName("ex", "test"))).thenReturn(nodePointer);
        QName qName = new QName("unknown", "test");
        when(namespaceResolver.getNamespaceURI("unknown")).thenReturn(null);
        Exception exception = assertThrows(JXPathException.class, () -> {
            domNodePointer.createAttribute(context, qName);
        });}
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testGetNamespaceURI_WithElementNode() throws Exception {
        when(node.getNodeType()).thenReturn(Node.ELEMENT_NODE);
        when(element.getNamespaceURI()).thenReturn("http://example.com/ns");
        when(document.getDocumentElement()).thenReturn(element);
        when(node instanceof Element).thenReturn(true);
        String uri = DOMNodePointer.getNamespaceURI(node);
        assertEquals("http://example.com/ns", uri);
    }
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testGetNamespaceURI_WithDocumentNode() throws Exception {
        when(node.getNodeType()).thenReturn(Node.ELEMENT_NODE);
        when(element.getNamespaceURI()).thenReturn("http://example.com/ns");
        when(document.getDocumentElement()).thenReturn(element);
        when(node instanceof Document).thenReturn(true);
        when(node.getNodeType()).thenReturn(Node.DOCUMENT_NODE);
        when(((Document) node).getDocumentElement()).thenReturn(element);
        String uri = DOMNodePointer.getNamespaceURI(node);
        assertEquals("http://example.com/ns", uri);
    }
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testGetNamespaceURI_WithNullNamespaceURI() throws Exception {
        when(node.getNodeType()).thenReturn(Node.ELEMENT_NODE);
        when(element.getNamespaceURI()).thenReturn("http://example.com/ns");
        when(document.getDocumentElement()).thenReturn(element);
        when(element.getNamespaceURI()).thenReturn(null);
        when(element.getAttributeNode("xmlns")).thenReturn(attr);
        when(attr.getValue()).thenReturn("http://example.com/default");
        String uri = DOMNodePointer.getNamespaceURI(node);
        assertEquals("http://example.com/default", uri);
    }
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testGetNamespaceURI_WithEmptyNamespaceURI() throws Exception {
        when(node.getNodeType()).thenReturn(Node.ELEMENT_NODE);
        when(element.getNamespaceURI()).thenReturn("http://example.com/ns");
        when(document.getDocumentElement()).thenReturn(element);
        when(element.getNamespaceURI()).thenReturn("");
        String uri = DOMNodePointer.getNamespaceURI(node);
        assertNull(uri);
    }
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testGetValueWithCommentNode() throws Exception {
        domNodePointer = new DOMNodePointer(node, null);
        // Setup the mock to behave as a comment node
        when(node.getNodeType()).thenReturn(Node.COMMENT_NODE);
        when(node).thenReturn(commentNode);
        when(commentNode.getData()).thenReturn(" This is a comment ");
        // Execute the method under test
        Object result = domNodePointer.getValue();
        // Verify the result
        assertEquals("This is a comment", result, "The trimmed comment text should be returned");
    }
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testCompareChildNodePointers_DifferentNodes_1_fid1() throws Exception {
        when(nodePointer1.getBaseValue()).thenReturn(node);
        when(nodePointer2.getBaseValue()).thenReturn(node);
        when(node.getAttributes()).thenReturn(namedNodeMap);
        when(namedNodeMap.getLength()).thenReturn(1);
        Node node1 = mock(Node.class);
        Node node2 = mock(Node.class);
        when(nodePointer1.getBaseValue()).thenReturn(node1);
        when(nodePointer2.getBaseValue()).thenReturn(node2);
        when(node.getFirstChild()).thenReturn(node1);
        when(node1.getNextSibling()).thenReturn(node2);
        int result = domNodePointer.compareChildNodePointers(nodePointer1, nodePointer2);
        result = domNodePointer.compareChildNodePointers(nodePointer2, nodePointer1);
        assertEquals(-1, result, "Should return -1 when node1 comes before node2");}
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testCompareChildNodePointers_DifferentNodes_2_fid1() throws Exception {
        when(nodePointer1.getBaseValue()).thenReturn(node);
        when(nodePointer2.getBaseValue()).thenReturn(node);
        when(node.getAttributes()).thenReturn(namedNodeMap);
        when(namedNodeMap.getLength()).thenReturn(1);
        Node node1 = mock(Node.class);
        Node node2 = mock(Node.class);
        when(nodePointer1.getBaseValue()).thenReturn(node1);
        when(nodePointer2.getBaseValue()).thenReturn(node2);
        when(node.getFirstChild()).thenReturn(node1);
        when(node1.getNextSibling()).thenReturn(node2);
        int result = domNodePointer.compareChildNodePointers(nodePointer1, nodePointer2);
        result = domNodePointer.compareChildNodePointers(nodePointer2, nodePointer1);
        assertEquals(1, result, "Should return 1 when node2 comes after node1");}
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testGetValueWithCommentNodeEmpty_fid1() throws Exception {
        domNodePointer = new DOMNodePointer(node, null);
        // Setup the mock to behave as a comment node with empty data
        when(node.getNodeType()).thenReturn(Node.COMMENT_NODE);
        when(node).thenReturn(commentNode);
        when(commentNode.getData()).thenReturn(" ");
        // Execute the method under test
        Object result = domNodePointer.getValue();
        // Verify the result
        assertEquals("", result, "An empty string should be returned for empty comment data");
    }
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testGetDefaultNamespaceURI_WithNamespace() throws Exception {
        when(node.getNodeType()).thenReturn(Node.DOCUMENT_NODE);
        when(document.getDocumentElement()).thenReturn(element);
        when(element.getNodeType()).thenReturn(Node.ELEMENT_NODE);
        when(element.getAttributeNode("xmlns")).thenReturn(attr);
        when(node instanceof Document).thenReturn(true);
        when(attr.getValue()).thenReturn("http://example.com/ns");
        String result = domNodePointer.getDefaultNamespaceURI();
        assertEquals("http://example.com/ns", result);
    }
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testGetDefaultNamespaceURI_WithoutNamespace() throws Exception {
        when(node.getNodeType()).thenReturn(Node.DOCUMENT_NODE);
        when(document.getDocumentElement()).thenReturn(element);
        when(element.getNodeType()).thenReturn(Node.ELEMENT_NODE);
        when(element.getAttributeNode("xmlns")).thenReturn(attr);
        when(node instanceof Document).thenReturn(true);
        when(element.getAttributeNode("xmlns")).thenReturn(null);
        String result = domNodePointer.getDefaultNamespaceURI();
        assertNull(result);
    }
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testGetDefaultNamespaceURI_WithNonElementNode() throws Exception {
        when(node.getNodeType()).thenReturn(Node.DOCUMENT_NODE);
        when(document.getDocumentElement()).thenReturn(element);
        when(element.getNodeType()).thenReturn(Node.ELEMENT_NODE);
        when(element.getAttributeNode("xmlns")).thenReturn(attr);
        when(node.getNodeType()).thenReturn(Node.TEXT_NODE);
        when(node.getParentNode()).thenReturn(null);
        String result = domNodePointer.getDefaultNamespaceURI();
        assertNull(result);
    }
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testGetPrefix_NullNodeName() throws Exception {
        // Node mock is set up in the field declaration using @Mock
        // Setup
        when(node.getPrefix()).thenReturn(null);
        when(node.getNodeName()).thenReturn(null);
        // Execute
        String result = DOMNodePointer.getPrefix(node);
        // Verify
        assertNull(result, "There should be no prefix when node name is null");
    }
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testNamespacePointer_3() throws Exception {
        // Assuming Node and Locale are interfaces or can be mocked
        domNodePointer = new DOMNodePointer(node, locale);
        String prefix = "testPrefix";
        // Act
        NodePointer result = domNodePointer.namespacePointer(prefix);
        // Assert
        assertEquals(prefix, result.getName().getPrefix(), "The prefix should match the input prefix.");}
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
public void testNamespacePointer_eeUR0_3() throws Exception {
    Node node = mock(Node.class);
    Locale locale = Locale.getDefault();
    DOMNodePointer domNodePointer = new DOMNodePointer(node, locale);
    String prefix = "testPrefix";
    NodePointer result = domNodePointer.namespacePointer(prefix);
    assertEquals(prefix, result.getName().getPrefix());}
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testGetLanguage_WithXmlLangAttribute() throws Exception {
        when(node.getAttributes()).thenReturn(null);
        when(node.getParentNode()).thenReturn(element);
        when(element.getAttributes()).thenReturn(null);
        when(element.getParentNode()).thenReturn(null);
        domNodePointer = new DOMNodePointer(node, Locale.getDefault());
        // Setup the scenario where the "xml:lang" attribute is present
        when(element.getAttribute("xml:lang")).thenReturn("en");
        // Execute the method under test
        String language = domNodePointer.getLanguage();
        // Assert the expected result
        assertEquals("en", language, "The language should be 'en'");
    }
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testGetLanguage_WithoutXmlLangAttribute() throws Exception {
        when(node.getAttributes()).thenReturn(null);
        when(node.getParentNode()).thenReturn(element);
        when(element.getAttributes()).thenReturn(null);
        when(element.getParentNode()).thenReturn(null);
        domNodePointer = new DOMNodePointer(node, Locale.getDefault());
        // Setup the scenario where the "xml:lang" attribute is not present
        when(element.getAttribute("xml:lang")).thenReturn(null);
        // Execute the method under test
        String language = domNodePointer.getLanguage();
        // Assert the expected result
        assertEquals(null, language, "The language should be null as 'xml:lang' attribute is not present");
    }
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testNode_WithNodeNameTestAndElementNode_ReturnsTrue() throws Exception {
        node = mock(Node.class);
        nodeTest = mock(NodeTest.class);
        NodeNameTest nodeNameTest = mock(NodeNameTest.class);
        QName qName = new QName("testPrefix", "localName");
        when(node.getNodeType()).thenReturn(Node.ELEMENT_NODE);
        when(nodeNameTest.getNodeName()).thenReturn(qName);
        when(nodeNameTest.isWildcard()).thenReturn(false);
        when(nodeNameTest.getNamespaceURI()).thenReturn(null);
        when(nodeNameTest instanceof NodeNameTest).thenReturn(true);
        assertTrue(DOMNodePointer.testNode(node, nodeNameTest), "testNode should return true for NodeNameTest with matching conditions");
    }
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testNode_WithNodeTypeTestAndMatchingNodeType_ReturnsTrue() throws Exception {
        node = mock(Node.class);
        nodeTest = mock(NodeTest.class);
        NodeTypeTest nodeTypeTest = mock(NodeTypeTest.class);
        when(node.getNodeType()).thenReturn(Node.TEXT_NODE);
        when(nodeTypeTest.getNodeType()).thenReturn(Compiler.NODE_TYPE_TEXT);
        when(nodeTypeTest instanceof NodeTypeTest).thenReturn(true);
        assertTrue(DOMNodePointer.testNode(node, nodeTypeTest), "testNode should return true for NodeTypeTest with matching node type");
    }
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testNode_WithProcessingInstructionTestAndMatchingTarget_ReturnsTrue() throws Exception {
        node = mock(Node.class);
        nodeTest = mock(NodeTest.class);
        ProcessingInstructionTest piTest = mock(ProcessingInstructionTest.class);
        when(node.getNodeType()).thenReturn(Node.PROCESSING_INSTRUCTION_NODE);
        when(piTest.getTarget()).thenReturn("target");
        when(((ProcessingInstruction) node).getTarget()).thenReturn("target");
        when(piTest instanceof ProcessingInstructionTest).thenReturn(true);
        assertTrue(DOMNodePointer.testNode(node, piTest), "testNode should return true for ProcessingInstructionTest with matching target");
    }
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testNode_WithMismatchedConditions_ReturnsFalse() throws Exception {
        node = mock(Node.class);
        nodeTest = mock(NodeTest.class);
        NodeNameTest nodeNameTest = mock(NodeNameTest.class);
        QName qName = new QName("testPrefix", "localName");
        when(node.getNodeType()).thenReturn(Node.TEXT_NODE); // Mismatched type, should be ELEMENT_NODE
        when(nodeNameTest.getNodeName()).thenReturn(qName);
        when(nodeNameTest.isWildcard()).thenReturn(false);
        when(nodeNameTest.getNamespaceURI()).thenReturn(null);
        when(nodeNameTest instanceof NodeNameTest).thenReturn(true);
        assertFalse(DOMNodePointer.testNode(node, nodeNameTest), "testNode should return false for mismatched conditions");
    }
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
public void testNode_NodeNameTest_WildcardMatchingLocalName_ReturnsTrue_FQRD3() throws Exception {
    Node node = mock(Node.class);
    when(node.getNodeType()).thenReturn(Node.ELEMENT_NODE);
    when(DOMNodePointer.getLocalName(node)).thenReturn("localName");
    NodeNameTest test = mock(NodeNameTest.class);
    QName testName = new QName("localName");
    when(test.getNodeName()).thenReturn(testName);
    when(test.isWildcard()).thenReturn(true);
    assertTrue(DOMNodePointer.testNode(node, test));
}
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
public void testNode_NodeNameTest_NonMatchingLocalName_ReturnsFalse_Ecto4() throws Exception {
    Node node = mock(Node.class);
    when(node.getNodeType()).thenReturn(Node.ELEMENT_NODE);
    when(DOMNodePointer.getLocalName(node)).thenReturn("localName");
    NodeNameTest test = mock(NodeNameTest.class);
    QName testName = new QName("differentName");
    when(test.getNodeName()).thenReturn(testName);
    when(test.isWildcard()).thenReturn(false);
    assertFalse(DOMNodePointer.testNode(node, test));
}
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
public void testNode_NodeNameTest_EqualStringsNamespaceURI_ReturnsTrue_rnTT12() throws Exception {
    Node node = mock(Node.class);
    when(node.getNodeType()).thenReturn(Node.ELEMENT_NODE);
    when(DOMNodePointer.getLocalName(node)).thenReturn("localName");
    when(DOMNodePointer.getNamespaceURI(node)).thenReturn("http://example.com");
    NodeNameTest test = mock(NodeNameTest.class);
    QName testName = new QName("localName");
    when(test.getNodeName()).thenReturn(testName);
    when(test.getNamespaceURI()).thenReturn("http://example.com");
    when(test.isWildcard()).thenReturn(false);
    assertTrue(DOMNodePointer.testNode(node, test));
}
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
public void testNode_NodeNameTest_EqualStringsNamespaceURINullNodeNS_ReturnsFalse_WxcT13() throws Exception {
    Node node = mock(Node.class);
    when(node.getNodeType()).thenReturn(Node.ELEMENT_NODE);
    when(DOMNodePointer.getLocalName(node)).thenReturn("localName");
    when(DOMNodePointer.getNamespaceURI(node)).thenReturn(null);
    NodeNameTest test = mock(NodeNameTest.class);
    QName testName = new QName("localName");
    when(test.getNodeName()).thenReturn(testName);
    when(test.getNamespaceURI()).thenReturn("http://example.com");
    when(test.isWildcard()).thenReturn(false);
    assertFalse(DOMNodePointer.testNode(node, test));
}
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
public void testNode_NodeNameTest_EqualStringsPrefix_ReturnsTrue_tUDH14() throws Exception {
    Node node = mock(Node.class);
    when(node.getNodeType()).thenReturn(Node.ELEMENT_NODE);
    when(DOMNodePointer.getLocalName(node)).thenReturn("localName");
    when(DOMNodePointer.getNamespaceURI(node)).thenReturn(null);
    when(DOMNodePointer.getPrefix(node)).thenReturn("prefix");
    NodeNameTest test = mock(NodeNameTest.class);
    QName testName = new QName("prefix", "localName");
    when(test.getNodeName()).thenReturn(testName);
    when(test.getNamespaceURI()).thenReturn(null);
    when(test.isWildcard()).thenReturn(true);
    assertTrue(DOMNodePointer.testNode(node, test));
}
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
public void testNode_NodeNameTest_EqualStringsPrefixMismatch_ReturnsFalse_UYpI15() throws Exception {
    Node node = mock(Node.class);
    when(node.getNodeType()).thenReturn(Node.ELEMENT_NODE);
    when(DOMNodePointer.getLocalName(node)).thenReturn("localName");
    when(DOMNodePointer.getNamespaceURI(node)).thenReturn(null);
    when(DOMNodePointer.getPrefix(node)).thenReturn("differentPrefix");
    NodeNameTest test = mock(NodeNameTest.class);
    QName testName = new QName("prefix", "localName");
    when(test.getNodeName()).thenReturn(testName);
    when(test.getNamespaceURI()).thenReturn(null);
    when(test.isWildcard()).thenReturn(true);
    assertFalse(DOMNodePointer.testNode(node, test));
}
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
public void testCreateChild_OeJR0() throws Exception {
    Node node = mock(Node.class);
    Locale locale = Locale.getDefault();
    String id = "testId";
    DOMNodePointer domNodePointer = new DOMNodePointer(node, locale, id);
    JXPathContext context = mock(JXPathContext.class);
    QName name = new QName("testName");
    int index = 0;
    Object value = "newValue";
    NodePointer result = domNodePointer.createChild(context, name, index, value);
    assertEquals("newValue", result.getValue());
}
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testAsPathWithElementNode() throws Exception {
        when(node.getNodeType()).thenReturn(Node.ELEMENT_NODE);
        when(node.getLocalName()).thenReturn("elementName");
        when(parent.asPath()).thenReturn("/parent/path");
        when(node.getNamespaceURI()).thenReturn(null);
        assertEquals("/parent/path/elementName[1]", domNodePointer.asPath(), "Path should be correctly constructed for an element node without namespace.");
    }
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testAsPathWithTextNode() throws Exception {
        when(node.getNodeType()).thenReturn(Node.ELEMENT_NODE);
        when(node.getLocalName()).thenReturn("elementName");
        when(parent.asPath()).thenReturn("/parent/path");
        when(node.getNodeType()).thenReturn(Node.TEXT_NODE);
        assertEquals("/parent/path/text()[1]", domNodePointer.asPath(), "Path should be correctly constructed for a text node.");
    }
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testAsPathWithProcessingInstructionNode() throws Exception {
        when(node.getNodeType()).thenReturn(Node.ELEMENT_NODE);
        when(node.getLocalName()).thenReturn("elementName");
        when(parent.asPath()).thenReturn("/parent/path");
        when(node.getNodeType()).thenReturn(Node.PROCESSING_INSTRUCTION_NODE);
        ProcessingInstruction pi = mock(ProcessingInstruction.class);
        when(node).thenReturn(pi);
        when(pi.getTarget()).thenReturn("target");
        assertEquals("/parent/path/processing-instruction('target')[1]", domNodePointer.asPath(), "Path should be correctly constructed for a processing instruction node.");
    }
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testAsPathWithId() throws Exception {
        when(node.getNodeType()).thenReturn(Node.ELEMENT_NODE);
        when(node.getLocalName()).thenReturn("elementName");
        when(parent.asPath()).thenReturn("/parent/path");
        domNodePointer = new DOMNodePointer(node, null, "uniqueId");
        assertEquals("id('uniqueId')", domNodePointer.asPath(), "Path should return ID path when ID is set.");
    }
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
public void testAsPathWithElementNodeAndNoNamespace_vvGL0() throws Exception {
    Node node = mock(Node.class);
    when(node.getNodeType()).thenReturn(Node.ELEMENT_NODE);
    when(node.getPreviousSibling()).thenReturn(null);
    when(node.getLocalName()).thenReturn("element");
    DOMNodePointer pointer = new DOMNodePointer(node, Locale.getDefault());
    String result = pointer.asPath();
    assertEquals("/element[1]", result);
}
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
public void testAsPathWithElementNodeAndMultipleSiblings_iOGn6() throws Exception {
    Node node = mock(Node.class);
    Node sibling1 = mock(Node.class);
    Node sibling2 = mock(Node.class);
    when(node.getNodeType()).thenReturn(Node.ELEMENT_NODE);
    when(node.getPreviousSibling()).thenReturn(sibling1);
    when(sibling1.getNodeType()).thenReturn(Node.ELEMENT_NODE);
    when(sibling1.getPreviousSibling()).thenReturn(sibling2);
    when(sibling2.getNodeType()).thenReturn(Node.ELEMENT_NODE);
    when(sibling2.getPreviousSibling()).thenReturn(null);
    when(node.getLocalName()).thenReturn("element");
    DOMNodePointer pointer = new DOMNodePointer(node, Locale.getDefault());
    String result = pointer.asPath();
    assertEquals("/element[3]", result);
}
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
public void testAsPathWithElementNodeNoNamespace_izAL0() throws Exception {
    Node elementNode = mock(Node.class);
    when(elementNode.getNodeType()).thenReturn(Node.ELEMENT_NODE);
    when(elementNode.getLocalName()).thenReturn("element");
    when(elementNode.getNamespaceURI()).thenReturn(null);
    DOMNodePointer pointer = new DOMNodePointer(elementNode, Locale.getDefault());
    String result = pointer.asPath();
    assertEquals("/element[1]", result);
}
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
public void testAsPathWithElementNodeWithNamespace_nqZF1() throws Exception {
    Node elementNode = mock(Node.class);
    when(elementNode.getNodeType()).thenReturn(Node.ELEMENT_NODE);
    when(elementNode.getLocalName()).thenReturn("element");
    when(elementNode.getNamespaceURI()).thenReturn("http://example.com/ns");
    NamespaceResolver resolver = mock(NamespaceResolver.class);
    when(resolver.getPrefix("http://example.com/ns")).thenReturn("ex");
    DOMNodePointer pointer = new DOMNodePointer(elementNode, Locale.getDefault());
    pointer.setNamespaceResolver(resolver);
    String result = pointer.asPath();
    assertEquals("/ex:element[1]", result);
}
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
public void testAsPathWithParentNode_VdHN7() throws Exception {
    Node elementNode = mock(Node.class);
    when(elementNode.getNodeType()).thenReturn(Node.ELEMENT_NODE);
    when(elementNode.getLocalName()).thenReturn("child");
    Node parentNode = mock(Node.class);
    when(parentNode.getNodeType()).thenReturn(Node.ELEMENT_NODE);
    when(parentNode.getLocalName()).thenReturn("parent");
    DOMNodePointer parentPointer = new DOMNodePointer(parentNode, Locale.getDefault());
    DOMNodePointer childPointer = new DOMNodePointer(parentPointer, elementNode);
    String result = childPointer.asPath();
    assertEquals("/parent/child[1]", result);
}
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testGetNamespaceURI_WithEmptyPrefix_ReturnsDefaultNamespace() throws Exception {
        when(node.getNodeType()).thenReturn(Node.ELEMENT_NODE);
        when(node.getParentNode()).thenReturn(null); // No parent node
        when(element.getAttributeNode(anyString())).thenReturn(null); // No such attribute
        when(document.getDocumentElement()).thenReturn(element);
        String result = domNodePointer.getNamespaceURI("");
        assertEquals(DOMNodePointer.UNKNOWN_NAMESPACE, result);
    }
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testGetNamespaceURI_WithXMLPrefix_ReturnsXMLNamespace() throws Exception {
        when(node.getNodeType()).thenReturn(Node.ELEMENT_NODE);
        when(node.getParentNode()).thenReturn(null); // No parent node
        when(element.getAttributeNode(anyString())).thenReturn(null); // No such attribute
        when(document.getDocumentElement()).thenReturn(element);
        String result = domNodePointer.getNamespaceURI("xml");
        assertEquals(DOMNodePointer.XML_NAMESPACE_URI, result);
    }
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testGetNamespaceURI_WithXMLNSPrefix_ReturnsXMLNSNamespace() throws Exception {
        when(node.getNodeType()).thenReturn(Node.ELEMENT_NODE);
        when(node.getParentNode()).thenReturn(null); // No parent node
        when(element.getAttributeNode(anyString())).thenReturn(null); // No such attribute
        when(document.getDocumentElement()).thenReturn(element);
        String result = domNodePointer.getNamespaceURI("xmlns");
        assertEquals(DOMNodePointer.XMLNS_NAMESPACE_URI, result);
    }
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testGetNamespaceURI_WithValidPrefix_ReturnsCorrectNamespace() throws Exception {
        when(node.getNodeType()).thenReturn(Node.ELEMENT_NODE);
        when(node.getParentNode()).thenReturn(null); // No parent node
        when(element.getAttributeNode(anyString())).thenReturn(null); // No such attribute
        when(document.getDocumentElement()).thenReturn(element);
        when(node.getNodeType()).thenReturn(Node.DOCUMENT_NODE);
        when(document.getDocumentElement()).thenReturn(element);
        when(element.getAttributeNode("xmlns:test")).thenReturn(attr);
        when(attr.getValue()).thenReturn("http://example.com/test");
        String result = domNodePointer.getNamespaceURI("test");
        assertEquals("http://example.com/test", result);
    }
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testGetNamespaceURI_WithUnknownPrefix_ReturnsUnknownNamespace() throws Exception {
        when(node.getNodeType()).thenReturn(Node.ELEMENT_NODE);
        when(node.getParentNode()).thenReturn(null); // No parent node
        when(element.getAttributeNode(anyString())).thenReturn(null); // No such attribute
        when(document.getDocumentElement()).thenReturn(element);
        when(node.getNodeType()).thenReturn(Node.DOCUMENT_NODE);
        when(document.getDocumentElement()).thenReturn(element);
        when(element.getAttributeNode("xmlns:unknown")).thenReturn(null);
        String result = domNodePointer.getNamespaceURI("unknown");
        assertEquals(DOMNodePointer.UNKNOWN_NAMESPACE, result);
    }
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
public void testGetNamespaceURIWithUnmappedPrefix_xgGb4() throws Exception {
    Node node = mock(Node.class);
    when(node.getNodeType()).thenReturn(Node.ELEMENT_NODE);
    when(node.getParentNode()).thenReturn(null);
    DOMNodePointer domNodePointer = new DOMNodePointer(node, Locale.getDefault());
    String result = domNodePointer.getNamespaceURI("unmapped");
    assertNull(result);
}
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
public void testGetNamespaceURIWithDocumentElement_ByRf7() throws Exception {
    Document document = mock(Document.class);
    Element documentElement = mock(Element.class);
    Attr attr = mock(Attr.class);
    when(document.getNodeType()).thenReturn(Node.DOCUMENT_NODE);
    when(document.getDocumentElement()).thenReturn(documentElement);
    when(documentElement.getAttributeNode("xmlns:doc")).thenReturn(attr);
    when(attr.getValue()).thenReturn("http://example.com/doc");
    DOMNodePointer domNodePointer = new DOMNodePointer(document, Locale.getDefault());
    String result = domNodePointer.getNamespaceURI("doc");
    assertEquals("http://example.com/doc", result);
}
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
public void testGetNamespaceURIWithNoNamespaceFound_KBmu8() throws Exception {
    Node node = mock(Node.class);
    when(node.getNodeType()).thenReturn(Node.ELEMENT_NODE);
    when(node.getParentNode()).thenReturn(null);
    DOMNodePointer domNodePointer = new DOMNodePointer(node, Locale.getDefault());
    String result = domNodePointer.getNamespaceURI("noNamespace");
    assertNull(result);
}
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testGetNamespaceResolver_InitialCreation_1() throws Exception {
        // Assuming Locale and Node are properly instantiated or mocked
        domNodePointer = new DOMNodePointer(node, Locale.getDefault());
        when(domNodePointer.getNamespaceResolver()).thenReturn(parentNamespaceResolver);
        // Call the method under test
        NamespaceResolver result = domNodePointer.getNamespaceResolver();
        // Verify the result is not null
        // Verify interactions
        verify(domNodePointer).getNamespaceResolver();
        // Ensure that the returned NamespaceResolver is set with the correct context pointer
        assertNotNull(result, "NamespaceResolver should not be null");}
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testGetNamespaceResolver_InitialCreation_2() throws Exception {
        // Assuming Locale and Node are properly instantiated or mocked
        domNodePointer = new DOMNodePointer(node, Locale.getDefault());
        when(domNodePointer.getNamespaceResolver()).thenReturn(parentNamespaceResolver);
        // Call the method under test
        NamespaceResolver result = domNodePointer.getNamespaceResolver();
        // Verify the result is not null
        // Verify interactions
        verify(domNodePointer).getNamespaceResolver();
        // Ensure that the returned NamespaceResolver is set with the correct context pointer
        assertEquals(domNodePointer, result.getNamespaceContextPointer(), "Namespace context pointer should be set to DOMNodePointer instance");}
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testGetNamespaceResolver_CachedInstance() throws Exception {
        // Assuming Locale and Node are properly instantiated or mocked
        domNodePointer = new DOMNodePointer(node, Locale.getDefault());
        when(domNodePointer.getNamespaceResolver()).thenReturn(parentNamespaceResolver);
        // First call to initialize and cache the resolver
        NamespaceResolver firstCallResolver = domNodePointer.getNamespaceResolver();
        // Second call should retrieve the same instance
        NamespaceResolver secondCallResolver = domNodePointer.getNamespaceResolver();
        // Verify that the same instance is returned
        assertSame(firstCallResolver, secondCallResolver, "Should return the same NamespaceResolver instance on subsequent calls");
        // Verify that the method was called twice
        verify(domNodePointer, times(2)).getNamespaceResolver();
    }
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
public void testCreateChildWithNullPrefix_VUeJ2_YUvP0() throws Exception {
    Node node = mock(Node.class);
    Locale locale = Locale.getDefault();
    JXPathContext context = mock(JXPathContext.class);
    AbstractFactory factory = mock(AbstractFactory.class);
    when(context.getFactory()).thenReturn(factory);
    when(factory.createObject(eq(context), any(DOMNodePointer.class), eq(node), anyString(), eq(0))).thenReturn(true);
    when(context.getNamespaceURI(null)).thenReturn(null);
    NodeIterator iterator = mock(NodeIterator.class);
    when(iterator.setPosition(1)).thenReturn(true);
    NodePointer expectedNodePointer = mock(NodePointer.class);
    when(iterator.getNodePointer()).thenReturn(expectedNodePointer);
    DOMNodePointer domNodePointer = new DOMNodePointer(node, locale);
    QName name = new QName(null, "testNode");
    NodePointer result = domNodePointer.createChild(context, name, 0);
    assertEquals(expectedNodePointer, result);
}
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
public void testCreateChildWithNonNullPrefix_udXn3_BVEF0() throws Exception {
    Node node = mock(Node.class);
    Locale locale = Locale.getDefault();
    JXPathContext context = mock(JXPathContext.class);
    AbstractFactory factory = mock(AbstractFactory.class);
    when(context.getFactory()).thenReturn(factory);
    when(factory.createObject(eq(context), any(DOMNodePointer.class), eq(node), anyString(), eq(0))).thenReturn(true);
    when(context.getNamespaceURI("prefix")).thenReturn("http://example.com");
    NodeIterator iterator = mock(NodeIterator.class);
    when(iterator.setPosition(1)).thenReturn(true);
    NodePointer expectedNodePointer = mock(NodePointer.class);
    when(iterator.getNodePointer()).thenReturn(expectedNodePointer);
    DOMNodePointer domNodePointer = new DOMNodePointer(node, locale);
    QName name = new QName("prefix", "testNode");
    NodePointer result = domNodePointer.createChild(context, name, 0);
    assertEquals(expectedNodePointer, result);
}
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
public void testFindEnclosingAttribute_AttributeFound_yFoC0() throws Exception {
    Node node = mock(Node.class);
    Element element = mock(Element.class);
    when(node.getNodeType()).thenReturn(Node.ELEMENT_NODE);
    when(node).thenReturn(element);
    when(element.getAttribute("targetAttr")).thenReturn("value");
    String result = DOMNodePointer.findEnclosingAttribute(node, "targetAttr");
    assertEquals("value", result);
}
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
public void testFindEnclosingAttribute_AttributeNotFound_vClJ0() throws Exception {
    Node node = mock(Node.class);
    Element element = mock(Element.class);
    when(node.getNodeType()).thenReturn(Node.ELEMENT_NODE);
    when(node).thenReturn(element);
    when(element.getAttribute("targetAttr")).thenReturn("");
    when(((Element) node).getAttribute("targetAttr")).thenReturn("");
    String result = DOMNodePointer.findEnclosingAttribute(node, "targetAttr");
    assertNull(result);
}
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
public void testGetValueWithNonCommentNode_NRiG0() throws Exception {
    Node node = mock(Node.class);
    DOMNodePointer domNodePointer = new DOMNodePointer(node, null);
    when(node.getNodeType()).thenReturn(Node.ELEMENT_NODE);
    when(node.getNodeValue()).thenReturn("ElementValue");
    Object result = domNodePointer.getValue();
}
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
public void testCreateChild_PPsv0() throws Exception {
    Node node = mock(Node.class);
    JXPathContext context = mock(JXPathContext.class);
    QName name = new QName("prefix", "localName");
    DOMNodePointer domNodePointer = new DOMNodePointer(node, Locale.getDefault());
    int index = 0;
    Object value = new Object();
    when(context.getLocale()).thenReturn(Locale.getDefault());
    NodePointer result = domNodePointer.createChild(context, name, index, value);
    assertNotNull(result); // Ensure that a NodePointer is returned
}
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
public void testAsPathWithCDATANode_wjXI3_rEBC0() throws Exception {
    DOMNodePointer pointer = new DOMNodePointer(node, Locale.getDefault());
    assertEquals("/text()[1]", pointer.asPath());
}
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
public void testAsPathWithProcessingInstructionNode_xytB4_mWzC0() throws Exception {
    ProcessingInstruction node = Mockito.mock(ProcessingInstruction.class);
    Mockito.when(node.getTarget()).thenReturn("target");
    DOMNodePointer pointer = new DOMNodePointer(node, Locale.getDefault());
    assertEquals("/processing-instruction('target')[1]", pointer.asPath());
}
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
public void testGetNamespaceURI_WithNullPrefix_ReturnsDefaultNamespace_IVWn0() throws Exception {
    when(node.getNodeType()).thenReturn(Node.ELEMENT_NODE);
    when(node.getParentNode()).thenReturn(null); // No parent node
    when(element.getAttributeNode(anyString())).thenReturn(null); // No such attribute
    when(document.getDocumentElement()).thenReturn(element);
    NamespaceResolver namespaceResolver = domNodePointer.getNamespaceResolver();
    String result = namespaceResolver.getNamespaceURI(null);
    assertEquals(DOMNodePointer.UNKNOWN_NAMESPACE, result);
}
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
public void testGetNamespaceURIWithValidPrefix_yrlD5_IIyf0() throws Exception {
    Node node = mock(Node.class);
    NamedNodeMap namedNodeMap = mock(NamedNodeMap.class);
    Attr attr = mock(Attr.class);
    when(node.getNodeType()).thenReturn(Node.ELEMENT_NODE);
    when(node.getAttributes()).thenReturn(namedNodeMap);
    when(namedNodeMap.getNamedItem("xmlns:test")).thenReturn(attr);
    when(attr.getValue()).thenReturn("http://example.com/test");
    DOMNodePointer domNodePointer = new DOMNodePointer(node, Locale.getDefault());
    String result = domNodePointer.getNamespaceURI("test");
    assertEquals("http://example.com/test", result);
}
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
public void testGetNamespaceURIWithInheritedPrefix_ixSJ6_LulE0() throws Exception {
    Node childNode = mock(Node.class);
    Node parentNode = mock(Node.class);
    NamedNodeMap attributes = mock(NamedNodeMap.class);
    Attr attr = mock(Attr.class);
    when(childNode.getNodeType()).thenReturn(Node.ELEMENT_NODE);
    when(childNode.getParentNode()).thenReturn(parentNode);
    when(parentNode.getAttributes()).thenReturn(attributes);
    when(attributes.getNamedItem("xmlns:inherited")).thenReturn(attr);
    when(attr.getValue()).thenReturn("http://example.com/inherited");
    DOMNodePointer domNodePointer = new DOMNodePointer(childNode, Locale.getDefault());
    String result = domNodePointer.getNamespaceURI("inherited");
    assertEquals("http://example.com/inherited", result);
}
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testCompareChildNodePointers_DifferentNodes() throws Exception {
        when(nodePointer1.getBaseValue()).thenReturn(node);
        when(nodePointer2.getBaseValue()).thenReturn(node);
        when(node.getAttributes()).thenReturn(namedNodeMap);
        when(namedNodeMap.getLength()).thenReturn(1);
        Node node1 = mock(Node.class);
        Node node2 = mock(Node.class);
        when(nodePointer1.getBaseValue()).thenReturn(node1);
        when(nodePointer2.getBaseValue()).thenReturn(node2);
        when(node.getFirstChild()).thenReturn(node1);
        when(node1.getNextSibling()).thenReturn(node2);
        int result = domNodePointer.compareChildNodePointers(nodePointer1, nodePointer2);
        assertEquals(-1, result, "Should return -1 when node1 comes before node2");
        result = domNodePointer.compareChildNodePointers(nodePointer2, nodePointer1);
        assertEquals(1, result, "Should return 1 when node2 comes after node1");
    }
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testCompareChildNodePointers_AttributeNodes() throws Exception {
        when(nodePointer1.getBaseValue()).thenReturn(node);
        when(nodePointer2.getBaseValue()).thenReturn(node);
        when(node.getAttributes()).thenReturn(namedNodeMap);
        when(namedNodeMap.getLength()).thenReturn(1);
        Node attributeNode1 = mock(Node.class);
        Node attributeNode2 = mock(Node.class);
        when(nodePointer1.getBaseValue()).thenReturn(attributeNode1);
        when(nodePointer2.getBaseValue()).thenReturn(attributeNode2);
        when(attributeNode1.getNodeType()).thenReturn(Node.ATTRIBUTE_NODE);
        when(attributeNode2.getNodeType()).thenReturn(Node.ATTRIBUTE_NODE);
        when(node.getAttributes()).thenReturn(namedNodeMap);
        when(namedNodeMap.item(0)).thenReturn(attributeNode1);
        when(namedNodeMap.getLength()).thenReturn(2);
        int result = domNodePointer.compareChildNodePointers(nodePointer1, nodePointer2);
        assertEquals(-1, result, "Should return -1 when attributeNode1 is before attributeNode2 in the attributes map");
        when(namedNodeMap.item(0)).thenReturn(attributeNode2);
        result = domNodePointer.compareChildNodePointers(nodePointer1, nodePointer2);
        assertEquals(1, result, "Should return 1 when attributeNode1 is after attributeNode2 in the attributes map");
    }
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testGetName_ProcessingInstructionNode() throws Exception {
        domNodePointer = new DOMNodePointer(node, null);
        // Setup for PROCESSING_INSTRUCTION_NODE
        ProcessingInstruction pi = mock(ProcessingInstruction.class);
        when(node.getNodeType()).thenReturn(Node.PROCESSING_INSTRUCTION_NODE);
        when(pi.getTarget()).thenReturn("target");
        when(node).thenReturn(pi);
        // Execute
        QName result = domNodePointer.getName();
        // Verify
        assertEquals(null, result.getPrefix());
        assertEquals("target", result.getName());
    }
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testCreateAttributeWithNamespace() throws Exception {
        when(element.getNamespaceURI()).thenReturn("http://example.com");
        when(nodePointer.getNamespaceResolver()).thenReturn(namespaceResolver);
        when(namespaceResolver.getNamespaceURI("ex")).thenReturn("http://example.com");
        when(nodeIterator.getNodePointer()).thenReturn(nodePointer);
        when(nodePointer.createAttribute(context, new QName("ex", "test"))).thenReturn(nodePointer);
        QName qName = new QName("ex", "test");
        when(element.hasAttributeNS("http://example.com", "test")).thenReturn(false);
        NodePointer result = domNodePointer.createAttribute(context, qName);
        verify(element).setAttributeNS("http://example.com", "ex:test", "");
        assertNotNull(result);
        assertEquals(nodePointer, result);
    }
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testCreateAttributeWithoutNamespace() throws Exception {
        when(element.getNamespaceURI()).thenReturn("http://example.com");
        when(nodePointer.getNamespaceResolver()).thenReturn(namespaceResolver);
        when(namespaceResolver.getNamespaceURI("ex")).thenReturn("http://example.com");
        when(nodeIterator.getNodePointer()).thenReturn(nodePointer);
        when(nodePointer.createAttribute(context, new QName("ex", "test"))).thenReturn(nodePointer);
        QName qName = new QName("test");
        when(element.hasAttribute("test")).thenReturn(false);
        NodePointer result = domNodePointer.createAttribute(context, qName);
        verify(element).setAttribute("test", "");
        assertNotNull(result);
        assertEquals(nodePointer, result);
    }
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testCreateAttributeWithExistingAttribute() throws Exception {
        when(element.getNamespaceURI()).thenReturn("http://example.com");
        when(nodePointer.getNamespaceResolver()).thenReturn(namespaceResolver);
        when(namespaceResolver.getNamespaceURI("ex")).thenReturn("http://example.com");
        when(nodeIterator.getNodePointer()).thenReturn(nodePointer);
        when(nodePointer.createAttribute(context, new QName("ex", "test"))).thenReturn(nodePointer);
        QName qName = new QName("test");
        when(element.hasAttribute("test")).thenReturn(true);
        NodePointer result = domNodePointer.createAttribute(context, qName);
        verify(element, never()).setAttribute("test", "");
        assertNotNull(result);
        assertEquals(nodePointer, result);
    }
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testCreateAttributeWithUnknownNamespacePrefix() throws Exception {
        when(element.getNamespaceURI()).thenReturn("http://example.com");
        when(nodePointer.getNamespaceResolver()).thenReturn(namespaceResolver);
        when(namespaceResolver.getNamespaceURI("ex")).thenReturn("http://example.com");
        when(nodeIterator.getNodePointer()).thenReturn(nodePointer);
        when(nodePointer.createAttribute(context, new QName("ex", "test"))).thenReturn(nodePointer);
        QName qName = new QName("unknown", "test");
        when(namespaceResolver.getNamespaceURI("unknown")).thenReturn(null);
        Exception exception = assertThrows(JXPathException.class, () -> {
            domNodePointer.createAttribute(context, qName);
        });
        assertEquals("Unknown namespace prefix: unknown", exception.getMessage());
    }
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testNamespacePointer() throws Exception {
        // Assuming Node and Locale are interfaces or can be mocked
        domNodePointer = new DOMNodePointer(node, locale);
        String prefix = "testPrefix";
        // Act
        NodePointer result = domNodePointer.namespacePointer(prefix);
        // Assert
        assertNotNull(result, "The result should not be null.");
        assertTrue(result instanceof NamespacePointer, "The result should be an instance of NamespacePointer.");
        assertEquals(prefix, result.getName().getPrefix(), "The prefix should match the input prefix.");
    }
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
public void testNamespacePointer_eeUR0() throws Exception {
    Node node = mock(Node.class);
    Locale locale = Locale.getDefault();
    DOMNodePointer domNodePointer = new DOMNodePointer(node, locale);
    String prefix = "testPrefix";
    NodePointer result = domNodePointer.namespacePointer(prefix);
    assertNotNull(result);
    assertTrue(result instanceof NamespacePointer);
    assertEquals(prefix, result.getName().getPrefix());
}
}