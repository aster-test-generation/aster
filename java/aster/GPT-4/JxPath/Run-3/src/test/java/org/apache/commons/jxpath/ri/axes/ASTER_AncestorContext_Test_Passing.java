/**
 * Generated by Aster
 */
package org.apache.commons.jxpath.ri.axes;
import org.apache.commons.jxpath.ri.compiler.NodeTest;
import org.apache.commons.jxpath.ri.model.NodePointer;
import org.apache.commons.jxpath.ri.compiler.NodeTypeTest;
import static org.junit.jupiter.api.Assertions.*;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.Timeout;
import org.junit.jupiter.api.Timeout.ThreadMode;
import java.util.concurrent.TimeUnit;
import static org.mockito.Mockito.*;
import static org.junit.jupiter.api.Timeout.ThreadMode.SEPARATE_THREAD;
import org.junit.jupiter.api.extension.ExtendWith;
import org.mockito.junit.jupiter.MockitoSettings;
import org.mockito.quality.Strictness;
import org.mockito.InjectMocks;
import org.mockito.InjectMocks;
import org.mockito.Mock;
import org.mockito.junit.jupiter.MockitoExtension;   
@ExtendWith(MockitoExtension.class)
@MockitoSettings(strictness = Strictness.LENIENT)
public class Aster_AncestorContext_Test_Passing {
@InjectMocks
    private AncestorContext ancestorContext;
@Mock
    private NamespaceContext namespaceContext;
@Mock
    private NodeTypeTest nodeTypeTest;
@Mock
    private NamespaceContext namespaceContextMock;
@Mock
    private NodeTypeTest nodeTypeTestMock;
@Mock
    private NodePointer currentNodePointer;
@Mock
    private NamespaceContext parentContext;
@Mock
    private NodeTypeTest nodeTest;
    private boolean setStarted = false;
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testSetPosition_SuccessfullyMovesToPosition() throws Exception {
        ancestorContext = new AncestorContext(namespaceContext, true, nodeTypeTest);
        // Arrange
        when(ancestorContext.getCurrentPosition()).thenReturn(1, 2, 3);
        when(ancestorContext.nextNode()).thenReturn(true, true, true);
        // Act
        boolean result = ancestorContext.setPosition(3);
        // Assert
        assertTrue(result);
        verify(ancestorContext, times(2)).nextNode(); // Called twice to move from 1 to 3
    }
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testSetPosition_FailsToMoveToPosition() throws Exception {
        ancestorContext = new AncestorContext(namespaceContext, true, nodeTypeTest);
        // Arrange
        when(ancestorContext.getCurrentPosition()).thenReturn(1);
        when(ancestorContext.nextNode()).thenReturn(false);
        // Act
        boolean result = ancestorContext.setPosition(2);
        // Assert
        assertFalse(result);
        verify(ancestorContext).nextNode(); // Called once and failed
    }
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testSetPosition_NoMovementNeeded() throws Exception {
        ancestorContext = new AncestorContext(namespaceContext, true, nodeTypeTest);
        // Arrange
        when(ancestorContext.getCurrentPosition()).thenReturn(3);
        // Act
        boolean result = ancestorContext.setPosition(3);
        // Assert
        assertTrue(result);
        verify(ancestorContext, never()).nextNode(); // No need to move, already at position
    }
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testSetPosition_ResetAndMove() throws Exception {
        ancestorContext = new AncestorContext(namespaceContext, true, nodeTypeTest);
        // Arrange
        when(ancestorContext.getCurrentPosition()).thenReturn(5, 1, 2, 3);
        when(ancestorContext.nextNode()).thenReturn(true, true, true);
        doNothing().when(ancestorContext).reset();
        // Act
        boolean result = ancestorContext.setPosition(3);
        // Assert
        assertTrue(result);
        verify(ancestorContext).reset(); // Reset because new position is less than current
        verify(ancestorContext, times(3)).nextNode(); // Move from 1 to 3 after reset
    }
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testGetDocumentOrder() throws Exception {
        ancestorContext = new AncestorContext(namespaceContext, true, nodeTypeTest);
        // Since getDocumentOrder is hardcoded to return -1, we expect -1
        int result = ancestorContext.getDocumentOrder();
        assertEquals(-1, result, "The document order should be -1");
    }
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
public void testGetDocumentOrder_sCEj0() throws Exception {
    NodeTypeTest nodeTypeTest = new NodeTypeTest(1);
    SelfContext selfContext = new SelfContext(null, nodeTypeTest);
    NamespaceContext namespaceContext = new NamespaceContext(selfContext, nodeTypeTest);
    AncestorContext ancestorContext = new AncestorContext(namespaceContext, true, nodeTypeTest);
    assertEquals(-1, ancestorContext.getDocumentOrder());
}
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
public void testGetCurrentNodePointer_zrYG0() throws Exception {
    NodeTypeTest nodeTest = new NodeTypeTest(1);
    SelfContext selfContext = new SelfContext(null, nodeTest);
    NamespaceContext namespaceContext = new NamespaceContext(selfContext, nodeTest);
    AncestorContext ancestorContext = new AncestorContext(namespaceContext, true, nodeTest);
    NodePointer expectedNodePointer = ancestorContext.getCurrentNodePointer();
    assertEquals(expectedNodePointer, ancestorContext.getCurrentNodePointer());
}
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testNextNode_IncludeSelfTrue_NodeTestPasses() throws Exception {
        // Setup the initial conditions and interactions
        when(parentContext.getCurrentNodePointer()).thenReturn(currentNodePointer);
        when(currentNodePointer.testNode(any(NodeTest.class))).thenReturn(true);
        when(currentNodePointer.getImmediateParentPointer()).thenReturn(null); // Simulate reaching the root
        ancestorContext = new AncestorContext(parentContext, true, nodeTest);
        // Test the scenario where includeSelf is true and the node test passes
        assertTrue(ancestorContext.nextNode(), "Should return true as the current node passes the node test and includeSelf is true");
        // Verify interactions
        verify(parentContext).getCurrentNodePointer();
        verify(currentNodePointer).testNode(nodeTest);
    }
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testNextNode_IncludeSelfFalse_NodeTestFails() throws Exception {
        // Setup the initial conditions and interactions
        when(parentContext.getCurrentNodePointer()).thenReturn(currentNodePointer);
        when(currentNodePointer.testNode(any(NodeTest.class))).thenReturn(true);
        when(currentNodePointer.getImmediateParentPointer()).thenReturn(null); // Simulate reaching the root
        ancestorContext = new AncestorContext(parentContext, true, nodeTest);
        // Adjust the setup for this specific test
        when(currentNodePointer.testNode(any(NodeTest.class))).thenReturn(false);
        ancestorContext = new AncestorContext(parentContext, false, nodeTest);
        // Test the scenario where includeSelf is false and the node test fails
        assertFalse(ancestorContext.nextNode(), "Should return false as the node test fails and includeSelf is false");
        // Verify interactions
        verify(parentContext).getCurrentNodePointer();
        verify(currentNodePointer).testNode(nodeTest);
        verify(currentNodePointer).getImmediateParentPointer();
    }
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testNextNode_NoMoreParents() throws Exception {
        // Setup the initial conditions and interactions
        when(parentContext.getCurrentNodePointer()).thenReturn(currentNodePointer);
        when(currentNodePointer.testNode(any(NodeTest.class))).thenReturn(true);
        when(currentNodePointer.getImmediateParentPointer()).thenReturn(null); // Simulate reaching the root
        ancestorContext = new AncestorContext(parentContext, true, nodeTest);
        // Test the scenario where there are no more parent pointers
        when(currentNodePointer.getImmediateParentPointer()).thenReturn(null);
        // Call nextNode once to set started and move to parent
        ancestorContext.nextNode(); // Should return false eventually when parent is null
        assertFalse(ancestorContext.nextNode(), "Should return false as there are no more parent nodes");
        // Verify interactions
        verify(currentNodePointer, times(2)).getImmediateParentPointer();
    }
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testNextNode_InitialCall_IncludeSelf_True_NodeMatches_yKrh0() throws Exception {
        NodeTypeTest nodeTest = new NodeTypeTest(1);
        SelfContext selfContext = new SelfContext(null, nodeTest);
        NamespaceContext namespaceContext = new NamespaceContext(selfContext, nodeTest);
        AncestorContext ancestorContext = new AncestorContext(namespaceContext, true, nodeTest);
        assertTrue(ancestorContext.nextNode());
    }
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testNextNode_InitialCall_IncludeSelf_False_NodeMatches_rZsL1() throws Exception {
        NodeTypeTest nodeTest = new NodeTypeTest(1);
        SelfContext selfContext = new SelfContext(null, nodeTest);
        NamespaceContext namespaceContext = new NamespaceContext(selfContext, nodeTest);
        AncestorContext ancestorContext = new AncestorContext(namespaceContext, false, nodeTest);
        assertFalse(ancestorContext.nextNode());
    }
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testNextNode_InitialCall_IncludeSelf_True_NodeDoesNotMatch_ItTm2() throws Exception {
        NodeTypeTest nodeTest = new NodeTypeTest(2);
        SelfContext selfContext = new SelfContext(null, new NodeTypeTest(1));
        NamespaceContext namespaceContext = new NamespaceContext(selfContext, new NodeTypeTest(1));
        AncestorContext ancestorContext = new AncestorContext(namespaceContext, true, nodeTest);
        assertFalse(ancestorContext.nextNode());
    }
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testNextNode_SubsequentCall_NodeMatches_gsTO3() throws Exception {
        NodeTypeTest nodeTest = new NodeTypeTest(1);
        SelfContext selfContext = new SelfContext(null, nodeTest);
        NamespaceContext namespaceContext = new NamespaceContext(selfContext, nodeTest);
        AncestorContext ancestorContext = new AncestorContext(namespaceContext, false, nodeTest);
        ancestorContext.nextNode(); // initial call to set up
        assertTrue(ancestorContext.nextNode());
    }
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testNextNode_SubsequentCall_NoMoreNodes_WhNf4() throws Exception {
        NodeTypeTest nodeTest = new NodeTypeTest(1);
        SelfContext selfContext = new SelfContext(null, nodeTest);
        NamespaceContext namespaceContext = new NamespaceContext(selfContext, nodeTest);
        AncestorContext ancestorContext = new AncestorContext(namespaceContext, false, nodeTest);
        ancestorContext.nextNode(); // initial call to set up
        ancestorContext.nextNode(); // move to next node
        assertFalse(ancestorContext.nextNode());
    }
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
public void testGetCurrentNodePointer_WNVI0() throws Exception {
    NamespaceContext namespaceContext = mock(NamespaceContext.class);
    NodeTypeTest nodeTypeTest = mock(NodeTypeTest.class);
    AncestorContext ancestorContext = new AncestorContext(namespaceContext, false, nodeTypeTest);
    NodePointer currentNodePointer = mock(NodePointer.class);
    when(namespaceContext.getCurrentNodePointer()).thenReturn(currentNodePointer);
    NodePointer result = ancestorContext.getCurrentNodePointer();
}
}