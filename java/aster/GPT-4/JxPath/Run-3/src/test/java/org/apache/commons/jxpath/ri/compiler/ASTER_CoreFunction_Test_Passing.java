/**
 * Generated by Aster
 */
package org.apache.commons.jxpath.ri.compiler;
import org.apache.commons.jxpath.JXPathContext;
import org.apache.commons.jxpath.JXPathException;
import org.apache.commons.jxpath.ri.Compiler;
import org.apache.commons.jxpath.ri.EvalContext;
import org.apache.commons.jxpath.ri.InfoSetUtil;
import org.apache.commons.jxpath.ri.model.NodePointer;
import org.apache.commons.jxpath.Pointer;
import org.apache.commons.jxpath.ri.QName;
import static org.junit.jupiter.api.Assertions.*;
import java.util.Arrays;
import java.util.List;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.Timeout;
import org.junit.jupiter.api.Timeout.ThreadMode;
import java.util.concurrent.TimeUnit;
import static org.mockito.Mockito.*;
import static org.junit.jupiter.api.Timeout.ThreadMode.SEPARATE_THREAD;
import org.junit.jupiter.api.extension.ExtendWith;
import org.mockito.junit.jupiter.MockitoSettings;
import org.mockito.quality.Strictness;
import org.mockito.InjectMocks;
import org.mockito.InjectMocks;
import org.mockito.Mock;
import org.mockito.junit.jupiter.MockitoExtension;   
@ExtendWith(MockitoExtension.class)
@MockitoSettings(strictness = Strictness.LENIENT)
public class Aster_CoreFunction_Test_Passing {
@InjectMocks
    private CoreFunction coreFunction;
@Mock
    private EvalContext evalContext;
@Mock
    private JXPathContext jXPathContext;
@Mock
    private NodePointer nodePointer;
@Mock
    private Expression expression;
@Mock
    private InfoSetUtil infoSetUtil;
@Mock
    private EvalContext context;
@Mock
    private Expression arg1;
@Mock
    private Expression arg2;
@Mock
    private Expression arg1Expression;
private Expression[] expressions;
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testComputeValue_FunctionLast() throws Exception {
        // Assuming functionCode for FUNCTION_LAST is 1 (you should replace this with the actual code)
        int functionCode = Compiler.FUNCTION_LAST;
        Expression[] args = null; // Assuming no arguments are needed for this function
        coreFunction = new CoreFunction(functionCode, args);
        // Setup the expected value
        Object expectedValue = 10; // Assuming the last function returns 10
        // Configure the mock to return the expected value
        when(evalContext.getPosition()).thenReturn((Integer) expectedValue);
        // Call the method under test
        Object result = coreFunction.computeValue(evalContext);
        // Verify the interaction with the mock
        verify(evalContext).getPosition();
        // Assert the result
        assertEquals(expectedValue, result, "The result should match the expected value.");
    }
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testFunctionBooleanTrue() throws Exception {
        coreFunction = new CoreFunction(1, new Expression[]{expression});
        // Setup
        when(expression.computeValue(evalContext)).thenReturn(true);
        // Execution
        Object result = coreFunction.functionBoolean(evalContext);
        // Verification
        assertEquals(Boolean.TRUE, result, "The function should return Boolean.TRUE for true input");
    }
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testFunctionBooleanFalse() throws Exception {
        coreFunction = new CoreFunction(1, new Expression[]{expression});
        // Setup
        when(expression.computeValue(evalContext)).thenReturn(false);
        // Execution
        Object result = coreFunction.functionBoolean(evalContext);
        // Verification
        assertEquals(Boolean.FALSE, result, "The function should return Boolean.FALSE for false input");
    }
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testFunctionSubstringBefore_BothStringsPresent() throws Exception {
        coreFunction = new CoreFunction(0, new Expression[]{arg1, arg2});
        when(arg1.computeValue(context)).thenReturn("Hello World");
        when(arg2.computeValue(context)).thenReturn(" World");
        String result = (String) coreFunction.functionSubstringBefore(context);
        assertEquals("Hello", result);
    }
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testFunctionSubstringBefore_SubstringNotPresent() throws Exception {
        coreFunction = new CoreFunction(0, new Expression[]{arg1, arg2});
        when(arg1.computeValue(context)).thenReturn("Hello World");
        when(arg2.computeValue(context)).thenReturn("Test");
        String result = (String) coreFunction.functionSubstringBefore(context);
        assertEquals("", result);
    }
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testFunctionSubstringBefore_EmptyFirstString() throws Exception {
        coreFunction = new CoreFunction(0, new Expression[]{arg1, arg2});
        when(arg1.computeValue(context)).thenReturn("");
        when(arg2.computeValue(context)).thenReturn("World");
        String result = (String) coreFunction.functionSubstringBefore(context);
        assertEquals("", result);
    }
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testFunctionSubstringBefore_EmptySecondString() throws Exception {
        coreFunction = new CoreFunction(0, new Expression[]{arg1, arg2});
        when(arg1.computeValue(context)).thenReturn("Hello World");
        when(arg2.computeValue(context)).thenReturn("");
        String result = (String) coreFunction.functionSubstringBefore(context);
        assertEquals("", result);
    }
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testFunctionSubstringBefore_BothEmptyStrings() throws Exception {
        coreFunction = new CoreFunction(0, new Expression[]{arg1, arg2});
        when(arg1.computeValue(context)).thenReturn("");
        when(arg2.computeValue(context)).thenReturn("");
        String result = (String) coreFunction.functionSubstringBefore(context);
        assertEquals("", result);
    }
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testFunctionName_NoArguments_ReturnsCurrentNodeName() throws Exception {
        coreFunction = new CoreFunction(0, new Expression[]{});
        when(context.getCurrentNodePointer()).thenReturn(nodePointer);
        when(nodePointer.getName()).thenReturn(new QName("http://example.com", "nodeName"));
        Object result = coreFunction.functionName(context);
        assertEquals("nodeName", result);
    }
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testFunctionName_WithArguments_ReturnsNextNodeName() throws Exception {
        coreFunction = new CoreFunction(0, new Expression[]{});
        // Setup CoreFunction with one argument
        coreFunction = new CoreFunction(0, new Expression[]{arg1Expression});
        when(arg1Expression.compute(context)).thenReturn(context);
        when(context.hasNext()).thenReturn(true);
        when(context.next()).thenReturn(nodePointer);
        when(nodePointer.getName()).thenReturn(new QName("http://example.com", "nextNodeName"));
        Object result = coreFunction.functionName(context);
        assertEquals("nextNodeName", result);
    }
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testFunctionName_WithArguments_NoNextNode_ReturnsEmptyString() throws Exception {
        coreFunction = new CoreFunction(0, new Expression[]{});
        // Setup CoreFunction with one argument
        coreFunction = new CoreFunction(0, new Expression[]{arg1Expression});
        when(arg1Expression.compute(context)).thenReturn(context);
        when(context.hasNext()).thenReturn(false);
        Object result = coreFunction.functionName(context);
        assertEquals("", result);
    }
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testFunctionFalse() {
        coreFunction = new CoreFunction(0, new Expression[0]);
        // Mock EvalContext
        EvalContext mockContext = mock(EvalContext.class);
        // Call the functionFalse method
        Object result = coreFunction.functionFalse(mockContext);
        // Assert that the result is Boolean.FALSE
        assertEquals(Boolean.FALSE, result, "The functionFalse should always return Boolean.FALSE");
    }
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testFunctionLang_WhenLanguageMatches_ReturnsTrue() throws Exception {
        coreFunction = new CoreFunction(0, new Expression[]{arg1});
        // Setup
        String testLang = "en";
        when(arg1.computeValue(context)).thenReturn(testLang);
        when(context.getSingleNodePointer()).thenReturn(nodePointer);
        when(nodePointer.isLanguage(testLang)).thenReturn(true);
        // Execute
        Object result = coreFunction.functionLang(context);
        // Verify
        assertEquals(Boolean.TRUE, result, "Expected language match to return true");
    }
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testFunctionLang_WhenLanguageDoesNotMatch_ReturnsFalse() throws Exception {
        coreFunction = new CoreFunction(0, new Expression[]{arg1});
        // Setup
        String testLang = "en";
        String nodeLang = "fr";
        when(arg1.computeValue(context)).thenReturn(testLang);
        when(context.getSingleNodePointer()).thenReturn(nodePointer);
        when(nodePointer.isLanguage(nodeLang)).thenReturn(false);
        // Execute
        Object result = coreFunction.functionLang(context);
        // Verify
        assertEquals(Boolean.FALSE, result, "Expected language mismatch to return false");
    }
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testFunctionLang_WhenNodePointerIsNull_ReturnsFalse() throws Exception {
        coreFunction = new CoreFunction(0, new Expression[]{arg1});
        // Setup
        String testLang = "en";
        when(arg1.computeValue(context)).thenReturn(testLang);
        when(context.getSingleNodePointer()).thenReturn(null);
        // Execute
        Object result = coreFunction.functionLang(context);
        // Verify
        assertEquals(Boolean.FALSE, result, "Expected null NodePointer to return false");
    }
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testFunctionPosition_1() throws Exception {
        coreFunction = new CoreFunction(0, null); // Assuming functionCode and args are not used in functionPosition
        // Arrange
        EvalContext mockContext = mock(EvalContext.class);
        when(mockContext.getCurrentPosition()).thenReturn(5);
        // Act
        Object result = coreFunction.functionPosition(mockContext);
        // Assert
        assertNotNull(result, "Result should not be null");}
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testFunctionPosition_2() throws Exception {
        coreFunction = new CoreFunction(0, null); // Assuming functionCode and args are not used in functionPosition
        // Arrange
        EvalContext mockContext = mock(EvalContext.class);
        when(mockContext.getCurrentPosition()).thenReturn(5);
        // Act
        Object result = coreFunction.functionPosition(mockContext);
        // Assert
        assertTrue(result instanceof Integer, "Result should be of type Integer");}
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testFunctionPosition_3() throws Exception {
        coreFunction = new CoreFunction(0, null); // Assuming functionCode and args are not used in functionPosition
        // Arrange
        EvalContext mockContext = mock(EvalContext.class);
        when(mockContext.getCurrentPosition()).thenReturn(5);
        // Act
        Object result = coreFunction.functionPosition(mockContext);
        // Assert
        assertEquals(5, result, "The result should equal the current position returned by the context");}
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
public void testGetFunctionNameForFunctionLast_kLdr0() {
    CoreFunction coreFunction = new CoreFunction(Compiler.FUNCTION_LAST, new Expression[]{});
    String functionName = coreFunction.getFunctionName();
    assertEquals("last", functionName);
}
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testFunctionLast_WithNoNodes() throws Exception {
        coreFunction = new CoreFunction(0, null);
        evalContext = mock(EvalContext.class);
        when(evalContext.nextNode()).thenReturn(false);
        when(evalContext.getCurrentPosition()).thenReturn(0);
        Object result = coreFunction.functionLast(evalContext);
        verify(evalContext).reset();
        verify(evalContext, never()).setPosition(anyInt());
        assertEquals(Double.valueOf(0), result, "Expected count should be 0 when there are no nodes.");
    }
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testFunctionLast_WithMultipleNodes() throws Exception {
        coreFunction = new CoreFunction(0, null);
        evalContext = mock(EvalContext.class);
        when(evalContext.nextNode()).thenReturn(true, true, true, false); // 3 nodes
        when(evalContext.getCurrentPosition()).thenReturn(0);
        Object result = coreFunction.functionLast(evalContext);
        verify(evalContext).reset();
        verify(evalContext, never()).setPosition(anyInt());
        assertEquals(Double.valueOf(3), result, "Expected count should be 3.");
    }
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testFunctionLast_WithInitialPositionSet() throws Exception {
        coreFunction = new CoreFunction(0, null);
        evalContext = mock(EvalContext.class);
        when(evalContext.nextNode()).thenReturn(true, true, false); // 2 nodes
        when(evalContext.getCurrentPosition()).thenReturn(5);
        Object result = coreFunction.functionLast(evalContext);
        verify(evalContext).reset();
        verify(evalContext).setPosition(5);
        assertEquals(Double.valueOf(2), result, "Expected count should be 2.");
    }
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testFunctionNotReturnsTrueWhenExpressionIsFalse() throws Exception {
        expression = mock(Expression.class);
        evalContext = mock(EvalContext.class);
        coreFunction = new CoreFunction(0, new Expression[]{expression});
        // Setup the expression to return false
        when(expression.computeValue(evalContext)).thenReturn(Boolean.FALSE);
        // Execute the functionNot method
        Object result = coreFunction.functionNot(evalContext);
        // Verify the result is TRUE because NOT false is true
        assertEquals(Boolean.TRUE, result);
    }
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testFunctionNotReturnsFalseWhenExpressionIsTrue() throws Exception {
        expression = mock(Expression.class);
        evalContext = mock(EvalContext.class);
        coreFunction = new CoreFunction(0, new Expression[]{expression});
        // Setup the expression to return true
        when(expression.computeValue(evalContext)).thenReturn(Boolean.TRUE);
        // Execute the functionNot method
        Object result = coreFunction.functionNot(evalContext);
        // Verify the result is FALSE because NOT true is false
        assertEquals(Boolean.FALSE, result);
    }
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
public void testGetArgumentCountWithNullArgs_icWU0() {
    CoreFunction coreFunction = new CoreFunction(1, null);
    int count = coreFunction.getArgumentCount();
    assertEquals(0, count);
}
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
public void testGetArgumentCountWithNonEmptyArgs_UYQv1() {
    Expression[] expressions = new Expression[5]; // Assuming Expression is a valid class
    CoreFunction coreFunction = new CoreFunction(1, expressions);
    int count = coreFunction.getArgumentCount();
    assertEquals(5, count);
}
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testFunctionStartsWith_True() throws Exception {
        coreFunction = new CoreFunction(0, new Expression[]{arg1, arg2});
        // Setup
        when(arg1.computeValue(context)).thenReturn("Hello World");
        when(arg2.computeValue(context)).thenReturn("Hello");
        when(coreFunction.getArg1()).thenReturn(arg1);
        when(coreFunction.getArg2()).thenReturn(arg2);
        // Execute
        Object result = coreFunction.functionStartsWith(context);
        // Verify
        assertEquals(Boolean.TRUE, result);
    }
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testFunctionStartsWith_False() throws Exception {
        coreFunction = new CoreFunction(0, new Expression[]{arg1, arg2});
        // Setup
        when(arg1.computeValue(context)).thenReturn("Hello World");
        when(arg2.computeValue(context)).thenReturn("World");
        when(coreFunction.getArg1()).thenReturn(arg1);
        when(coreFunction.getArg2()).thenReturn(arg2);
        // Execute
        Object result = coreFunction.functionStartsWith(context);
        // Verify
        assertEquals(Boolean.FALSE, result);
    }
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testFunctionStartsWith_EmptyString() throws Exception {
        coreFunction = new CoreFunction(0, new Expression[]{arg1, arg2});
        // Setup
        when(arg1.computeValue(context)).thenReturn("");
        when(arg2.computeValue(context)).thenReturn("Hello");
        when(coreFunction.getArg1()).thenReturn(arg1);
        when(coreFunction.getArg2()).thenReturn(arg2);
        // Execute
        Object result = coreFunction.functionStartsWith(context);
        // Verify
        assertEquals(Boolean.FALSE, result);
    }
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testFunctionNamespaceURI_WithZeroArguments_ReturnsNamespaceURI() {
        coreFunction = new CoreFunction(0, new Expression[0]); // Assuming functionCode and args are not relevant for this test
        evalContext = mock(EvalContext.class);
        nodePointer = mock(NodePointer.class);
        // Setup
        when(evalContext.getCurrentNodePointer()).thenReturn(nodePointer);
        when(nodePointer.getNamespaceURI()).thenReturn("http://example.com/ns");
        // Execute
        Object result = coreFunction.functionNamespaceURI(evalContext);
        // Verify
        assertEquals("http://example.com/ns", result);
    }
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testFunctionNamespaceURI_WithZeroArguments_ReturnsEmptyStringWhenNamespaceURINull() {
        coreFunction = new CoreFunction(0, new Expression[0]); // Assuming functionCode and args are not relevant for this test
        evalContext = mock(EvalContext.class);
        nodePointer = mock(NodePointer.class);
        // Setup
        when(evalContext.getCurrentNodePointer()).thenReturn(nodePointer);
        when(nodePointer.getNamespaceURI()).thenReturn(null);
        // Execute
        Object result = coreFunction.functionNamespaceURI(evalContext);
        // Verify
        assertEquals("", result);
    }
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testFunctionNamespaceURI_WithNonZeroArguments_HasNextReturnsTrue() {
        coreFunction = new CoreFunction(0, new Expression[0]); // Assuming functionCode and args are not relevant for this test
        evalContext = mock(EvalContext.class);
        nodePointer = mock(NodePointer.class);
        // Setup
        Expression[] args = {mock(Expression.class)};
        coreFunction = new CoreFunction(0, args);
        when(args[0].compute(evalContext)).thenReturn(evalContext);
        when(evalContext.hasNext()).thenReturn(true);
        when(evalContext.next()).thenReturn(nodePointer);
        when(nodePointer.getNamespaceURI()).thenReturn("http://example.com/ns");
        // Execute
        Object result = coreFunction.functionNamespaceURI(evalContext);
        // Verify
        assertEquals("http://example.com/ns", result);
    }
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testFunctionNamespaceURI_WithNonZeroArguments_HasNextReturnsFalse() {
        coreFunction = new CoreFunction(0, new Expression[0]); // Assuming functionCode and args are not relevant for this test
        evalContext = mock(EvalContext.class);
        nodePointer = mock(NodePointer.class);
        // Setup
        Expression[] args = {mock(Expression.class)};
        coreFunction = new CoreFunction(0, args);
        when(args[0].compute(evalContext)).thenReturn(evalContext);
        when(evalContext.hasNext()).thenReturn(false);
        // Execute
        Object result = coreFunction.functionNamespaceURI(evalContext);
        // Verify
        assertEquals("", result);
    }
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testFunctionConcat() throws Exception {
        evalContext = mock(EvalContext.class);
        expressions = new Expression[] {
            mock(Expression.class),
            mock(Expression.class),
            mock(Expression.class)
        };
        coreFunction = new CoreFunction(0, expressions); // Assuming 0 is a valid function code for this example
        // Setup the expected values for each expression
        when(expressions[0].compute(evalContext)).thenReturn("Hello");
        when(expressions[1].compute(evalContext)).thenReturn(" ");
        when(expressions[2].compute(evalContext)).thenReturn("World");
        // Call the functionConcat method
        String result = (String) coreFunction.functionConcat(evalContext);
        // Verify the result
        assertEquals("Hello World", result);
        // Verify that compute was called on each expression with the correct context
        verify(expressions[0]).compute(evalContext);
        verify(expressions[1]).compute(evalContext);
        verify(expressions[2]).compute(evalContext);
    }
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testFunctionEndsWith_True() {
        context = mock(EvalContext.class);
        arg1 = mock(Expression.class);
        arg2 = mock(Expression.class);
        coreFunction = new CoreFunction(0, new Expression[]{arg1, arg2});
        // Setup
        when(arg1.computeValue(context)).thenReturn("HelloWorld");
        when(arg2.computeValue(context)).thenReturn("World");
        when(InfoSetUtil.stringValue("HelloWorld")).thenReturn("HelloWorld");
        when(InfoSetUtil.stringValue("World")).thenReturn("World");
        // Execute
        Object result = coreFunction.functionEndsWith(context);
        // Verify
        assertTrue((Boolean) result, "Expected true when 'HelloWorld' ends with 'World'");
    }
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testFunctionEndsWith_False() {
        context = mock(EvalContext.class);
        arg1 = mock(Expression.class);
        arg2 = mock(Expression.class);
        coreFunction = new CoreFunction(0, new Expression[]{arg1, arg2});
        // Setup
        when(arg1.computeValue(context)).thenReturn("HelloWorld");
        when(arg2.computeValue(context)).thenReturn("Test");
        when(InfoSetUtil.stringValue("HelloWorld")).thenReturn("HelloWorld");
        when(InfoSetUtil.stringValue("Test")).thenReturn("Test");
        // Execute
        Object result = coreFunction.functionEndsWith(context);
        // Verify
        assertFalse((Boolean) result, "Expected false when 'HelloWorld' does not end with 'Test'");
    }
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testFunctionEndsWith_EmptyString() {
        context = mock(EvalContext.class);
        arg1 = mock(Expression.class);
        arg2 = mock(Expression.class);
        coreFunction = new CoreFunction(0, new Expression[]{arg1, arg2});
        // Setup
        when(arg1.computeValue(context)).thenReturn("");
        when(arg2.computeValue(context)).thenReturn("Test");
        when(InfoSetUtil.stringValue("")).thenReturn("");
        when(InfoSetUtil.stringValue("Test")).thenReturn("Test");
        // Execute
        Object result = coreFunction.functionEndsWith(context);
        // Verify
        assertFalse((Boolean) result, "Expected false when empty string does not end with 'Test'");
    }
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
public void testToStringWithNoArguments_iiPO0() {
    CoreFunction coreFunction = new CoreFunction(1, new Expression[0]);
    String result = coreFunction.toString();
    assertEquals("FunctionName()", result);
}
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
public void testToStringWithNullArguments_XjVj3() {
    CoreFunction coreFunction = new CoreFunction(1, null);
    String result = coreFunction.toString();
    assertEquals("FunctionName()", result);
}
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testFunctionCeilingWithNormalValue() throws Exception {
        coreFunction = new CoreFunction(0, new Expression[]{expression});
        when(expression.computeValue(context)).thenReturn(3.3);
        Object result = coreFunction.functionCeiling(context);
        assertEquals(4.0, result);
    }
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testFunctionCeilingWithNaN() throws Exception {
        coreFunction = new CoreFunction(0, new Expression[]{expression});
        when(expression.computeValue(context)).thenReturn(Double.NaN);
        Object result = coreFunction.functionCeiling(context);
        assertTrue(Double.isNaN((Double) result));
    }
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testFunctionCeilingWithPositiveInfinity() throws Exception {
        coreFunction = new CoreFunction(0, new Expression[]{expression});
        when(expression.computeValue(context)).thenReturn(Double.POSITIVE_INFINITY);
        Object result = coreFunction.functionCeiling(context);
        assertTrue(Double.isInfinite((Double) result) && (Double) result > 0);
    }
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testFunctionCeilingWithNegativeInfinity() throws Exception {
        coreFunction = new CoreFunction(0, new Expression[]{expression});
        when(expression.computeValue(context)).thenReturn(Double.NEGATIVE_INFINITY);
        Object result = coreFunction.functionCeiling(context);
        assertTrue(Double.isInfinite((Double) result) && (Double) result < 0);
    }
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testFunctionLocalName_NoArguments_NoNode() {
        coreFunction = new CoreFunction(0, new Expression[0]); // Assuming functionCode and args are not relevant for this test
        // Setup
        when(context.getCurrentNodePointer()).thenReturn(null);
        // Execute
        Object result = coreFunction.functionLocalName(context);
        // Verify
        assertEquals("", result);
    }
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testFunctionLocalName_WithArguments_NoNextNode() {
        coreFunction = new CoreFunction(0, new Expression[0]); // Assuming functionCode and args are not relevant for this test
        // Setup
        Expression[] args = {mock(Expression.class)};
        coreFunction = new CoreFunction(0, args);
        when(args[0].compute(context)).thenReturn(context);
        when(context.hasNext()).thenReturn(false);
        // Execute
        Object result = coreFunction.functionLocalName(context);
        // Verify
        assertEquals("", result);
    }
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testFunctionStringLength_NoArguments() {
        coreFunction = new CoreFunction(0, new Expression[0]); // Assuming functionCode and args are not relevant for this test
        evalContext = mock(EvalContext.class);
        nodePointer = mock(NodePointer.class);
        // Setup
        when(evalContext.getCurrentNodePointer()).thenReturn(nodePointer);
        when(nodePointer.asPath()).thenReturn("testString");
        // Execute
        Object result = coreFunction.functionStringLength(evalContext);
        // Verify
        verify(evalContext).getCurrentNodePointer();
        assertEquals(10.0, result, "The length of 'testString' should be 10.");
    }
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testFunctionStringLength_WithArguments() {
        coreFunction = new CoreFunction(0, new Expression[0]); // Assuming functionCode and args are not relevant for this test
        evalContext = mock(EvalContext.class);
        nodePointer = mock(NodePointer.class);
        // Setup
        Expression[] args = new Expression[1];
        Expression expression = mock(Expression.class);
        args[0] = expression;
        coreFunction = new CoreFunction(0, args);
        when(expression.computeValue(evalContext)).thenReturn("anotherTest");
        when(nodePointer.asPath()).thenReturn("ignoredString");
        // Execute
        Object result = coreFunction.functionStringLength(evalContext);
        // Verify
        verify(expression).computeValue(evalContext);
        assertEquals(11.0, result, "The length of 'anotherTest' should be 11.");
    }
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testFunctionNormalizeSpace_SingleSpace() throws Exception {
        coreFunction = new CoreFunction(0, new Expression[]{arg1Expression});
        when(arg1Expression.computeValue(context)).thenReturn(" Hello World ");
        String result = (String) coreFunction.functionNormalizeSpace(context);
        assertEquals("Hello World", result);
    }
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testFunctionNormalizeSpace_TabAndNewLine() throws Exception {
        coreFunction = new CoreFunction(0, new Expression[]{arg1Expression});
        when(arg1Expression.computeValue(context)).thenReturn("\tHello\nWorld\r\n");
        String result = (String) coreFunction.functionNormalizeSpace(context);
        assertEquals("Hello World", result);
    }
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testFunctionNormalizeSpace_EmptyString() throws Exception {
        coreFunction = new CoreFunction(0, new Expression[]{arg1Expression});
        when(arg1Expression.computeValue(context)).thenReturn("");
        String result = (String) coreFunction.functionNormalizeSpace(context);
        assertEquals("", result);
    }
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testFunctionTrue() {
        coreFunction = new CoreFunction(0, new Expression[0]);
        // Mock the EvalContext as it's passed to the functionTrue method
        EvalContext mockContext = mock(EvalContext.class);
        // Call the functionTrue method
        Object result = coreFunction.functionTrue(mockContext);
        // Assert that the result is Boolean.TRUE
        assertEquals(Boolean.TRUE, result, "The functionTrue should always return Boolean.TRUE");
    }
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testFunctionNull() throws Exception {
        coreFunction = new CoreFunction(0, new Expression[0]);
        EvalContext mockContext = mock(EvalContext.class);
        Object result = coreFunction.functionNull(mockContext);
        assertNull(result, "The result should be null for functionNull.");
    }
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testFunctionSumWithInvalidArgumentType_1() throws Exception {
        coreFunction = new CoreFunction(0, new Expression[]{arg1});
        when(arg1.compute(context)).thenReturn(new Object());
        Exception exception = assertThrows(JXPathException.class, () -> {
            coreFunction.functionSum(context);
        });}
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testFunctionString_OneArgument_ReturnsComputedValue() throws Exception {
        // Assuming CoreFunction constructor and methods are accessible and modifiable for testing
        coreFunction = new CoreFunction(0, new Expression[]{});
        // Setup
        coreFunction = new CoreFunction(0, new Expression[]{expression});
        when(expression.computeValue(evalContext)).thenReturn("computedValue");
        // Execute
        Object result = coreFunction.functionString(evalContext);
        // Verify
        verify(expression).computeValue(evalContext);
        assertEquals("computedValue", result);
    }
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testFunctionString_InvalidArgumentCount_ThrowsAssertionError() throws Exception {
        // Assuming CoreFunction constructor and methods are accessible and modifiable for testing
        coreFunction = new CoreFunction(0, new Expression[]{});
        // Setup
        coreFunction = new CoreFunction(0, new Expression[]{expression, expression});
        // Execute & Verify
        assertThrows(AssertionError.class, () -> coreFunction.functionString(evalContext));
    }
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testFunctionSubstringAfter() throws Exception {
        coreFunction = new CoreFunction(0, new Expression[]{arg1, arg2});
        // Setup the arguments and their return values
        when(arg1.computeValue(context)).thenReturn("hello world");
        when(arg2.computeValue(context)).thenReturn("world");
        // Execute the function
        Object result = coreFunction.functionSubstringAfter(context);
        // Verify the result
        assertEquals(" world", result, "The substring after 'world' in 'hello world' should be ' world'");
        // Verify interactions
        verify(arg1).computeValue(context);
        verify(arg2).computeValue(context);
    }
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testFunctionSubstringAfter_NotFound() throws Exception {
        coreFunction = new CoreFunction(0, new Expression[]{arg1, arg2});
        // Setup the arguments and their return values
        when(arg1.computeValue(context)).thenReturn("hello world");
        when(arg2.computeValue(context)).thenReturn("xyz");
        // Execute the function
        Object result = coreFunction.functionSubstringAfter(context);
        // Verify the result
        assertEquals("", result, "The substring after 'xyz' in 'hello world' should be '' (empty string)");
        // Verify interactions
        verify(arg1).computeValue(context);
        verify(arg2).computeValue(context);
    }
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testComputeContextDependentWithFunctionLast_nAkz0() {
        CoreFunction coreFunction = new CoreFunction(Compiler.FUNCTION_LAST, null);
        assertTrue(coreFunction.computeContextDependent());
    }
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testComputeContextDependentWithFunctionBooleanNoArgs_ESxx1() {
        CoreFunction coreFunction = new CoreFunction(Compiler.FUNCTION_BOOLEAN, new Expression[0]);
        assertTrue(coreFunction.computeContextDependent());
    }
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testComputeContextDependentWithFunctionSum_wbXA5() {
        CoreFunction coreFunction = new CoreFunction(Compiler.FUNCTION_SUM, null);
        assertFalse(coreFunction.computeContextDependent());
    }
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
public void testGetFunctionCode_qpoz0() {
    Expression[] expressions = new Expression[0];
    CoreFunction coreFunction = new CoreFunction(5, expressions);
    int expected = 5;
    assertEquals(expected, coreFunction.getFunctionCode());
}
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testFunctionFloor_NormalValue() throws Exception {
        coreFunction = new CoreFunction(0, new Expression[]{expression});
        when(expression.computeValue(context)).thenReturn(3.7);
        Object result = coreFunction.functionFloor(context);
        assertEquals(3.0, result);
    }
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testFunctionFloor_NaN() throws Exception {
        coreFunction = new CoreFunction(0, new Expression[]{expression});
        when(expression.computeValue(context)).thenReturn(Double.NaN);
        Object result = coreFunction.functionFloor(context);
        assertTrue(Double.isNaN((Double) result));
    }
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testFunctionFloor_PositiveInfinity() throws Exception {
        coreFunction = new CoreFunction(0, new Expression[]{expression});
        when(expression.computeValue(context)).thenReturn(Double.POSITIVE_INFINITY);
        Object result = coreFunction.functionFloor(context);
        assertTrue(Double.isInfinite((Double) result) && (Double) result > 0);
    }
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testFunctionFloor_NegativeInfinity() throws Exception {
        coreFunction = new CoreFunction(0, new Expression[]{expression});
        when(expression.computeValue(context)).thenReturn(Double.NEGATIVE_INFINITY);
        Object result = coreFunction.functionFloor(context);
        assertTrue(Double.isInfinite((Double) result) && (Double) result < 0);
    }
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testFunctionContains_ContainsTrue() throws Exception {
        coreFunction = new CoreFunction(0, new Expression[]{arg1, arg2});
        // Setup
        when(arg1.computeValue(context)).thenReturn("Hello World");
        when(arg2.computeValue(context)).thenReturn("World");
        // Execute
        Object result = coreFunction.functionContains(context);
        // Verify
        assertTrue((Boolean) result, "The function should return true when the first string contains the second string.");
    }
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testFunctionContains_ContainsFalse() throws Exception {
        coreFunction = new CoreFunction(0, new Expression[]{arg1, arg2});
        // Setup
        when(arg1.computeValue(context)).thenReturn("Hello World");
        when(arg2.computeValue(context)).thenReturn("Universe");
        // Execute
        Object result = coreFunction.functionContains(context);
        // Verify
        assertFalse((Boolean) result, "The function should return false when the first string does not contain the second string.");
    }
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testFunctionContains_EmptyString() throws Exception {
        coreFunction = new CoreFunction(0, new Expression[]{arg1, arg2});
        // Setup
        when(arg1.computeValue(context)).thenReturn("");
        when(arg2.computeValue(context)).thenReturn("Anything");
        // Execute
        Object result = coreFunction.functionContains(context);
        // Verify
        assertFalse((Boolean) result, "The function should return false when the first string is empty.");
    }
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testFunctionContains_SecondStringEmpty() throws Exception {
        coreFunction = new CoreFunction(0, new Expression[]{arg1, arg2});
        // Setup
        when(arg1.computeValue(context)).thenReturn("Hello World");
        when(arg2.computeValue(context)).thenReturn("");
        // Execute
        Object result = coreFunction.functionContains(context);
        // Verify
        assertTrue((Boolean) result, "The function should return true when the second string is empty.");
    }
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testFunctionRound_NormalValue() throws Exception {
        coreFunction = new CoreFunction(0, new Expression[]{arg1Expression});
        when(arg1Expression.computeValue(context)).thenReturn(2.7);
        Object result = coreFunction.functionRound(context);
        assertEquals(Double.valueOf(3.0), result);
    }
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testFunctionRound_NegativeValue() throws Exception {
        coreFunction = new CoreFunction(0, new Expression[]{arg1Expression});
        when(arg1Expression.computeValue(context)).thenReturn(-2.7);
        Object result = coreFunction.functionRound(context);
        assertEquals(Double.valueOf(-3.0), result);
    }
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testFunctionRound_NaN() throws Exception {
        coreFunction = new CoreFunction(0, new Expression[]{arg1Expression});
        when(arg1Expression.computeValue(context)).thenReturn(Double.NaN);
        Object result = coreFunction.functionRound(context);
        assertTrue(Double.isNaN((Double) result));
    }
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testFunctionRound_Infinity_1() throws Exception {
        coreFunction = new CoreFunction(0, new Expression[]{arg1Expression});
        when(arg1Expression.computeValue(context)).thenReturn(Double.POSITIVE_INFINITY);
        Object result = coreFunction.functionRound(context);
        when(arg1Expression.computeValue(context)).thenReturn(Double.NEGATIVE_INFINITY);
        result = coreFunction.functionRound(context);
        assertTrue(Double.isInfinite((Double) result) && (Double) result > 0);}
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testFunctionRound_Infinity_2() throws Exception {
        coreFunction = new CoreFunction(0, new Expression[]{arg1Expression});
        when(arg1Expression.computeValue(context)).thenReturn(Double.POSITIVE_INFINITY);
        Object result = coreFunction.functionRound(context);
        when(arg1Expression.computeValue(context)).thenReturn(Double.NEGATIVE_INFINITY);
        result = coreFunction.functionRound(context);
        assertTrue(Double.isInfinite((Double) result) && (Double) result < 0);}
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testFunctionNumberWithNoArguments() {
        context = mock(EvalContext.class);
        nodePointer = mock(NodePointer.class);
        expression = mock(Expression.class);
        coreFunction = new CoreFunction(0, new Expression[]{expression});
        when(context.getCurrentNodePointer()).thenReturn(nodePointer);
        when(nodePointer.getValue()).thenReturn(123.0); // Assuming InfoSetUtil.number() returns the node's value as a number.
        Object result = coreFunction.functionNumber(context);
        verify(context).getCurrentNodePointer();
        assertEquals(123.0, result);
    }
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testFunctionNumberWithOneArgument() {
        context = mock(EvalContext.class);
        nodePointer = mock(NodePointer.class);
        expression = mock(Expression.class);
        coreFunction = new CoreFunction(0, new Expression[]{expression});
        when(expression.computeValue(context)).thenReturn(456.0); // Assuming InfoSetUtil.number() converts this value to a number.
        when(context.getCurrentNodePointer()).thenReturn(null); // This should not be called in this scenario.
        Object result = coreFunction.functionNumber(context);
        verify(expression).computeValue(context);
        assertEquals(456.0, result);
    }
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
public void testFunctionID_kprY0() throws Exception {
    coreFunction = new CoreFunction(1, new Expression[]{expression});
    String id = "testID";
    Object expectedObject = new Object();
    when(expression.computeValue(evalContext)).thenReturn(id);
    when(evalContext.getJXPathContext()).thenReturn(jXPathContext);
    when(jXPathContext.getContextPointer()).thenReturn(nodePointer);
    when(nodePointer.getPointerByID(jXPathContext, id)).thenReturn((Pointer) expectedObject);
    Object result = coreFunction.functionID(evalContext);
    verify(expression).computeValue(evalContext);
    verify(evalContext).getJXPathContext();
    verify(jXPathContext).getContextPointer();
    verify(nodePointer).getPointerByID(jXPathContext, id);
}
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
public void testFunctionSumWithEvalContext_ximn0() throws Exception {
    CoreFunction coreFunction = new CoreFunction(0, new Expression[]{arg1});
    when(arg1.computeValue(context)).thenReturn(context);
    when(context.hasNext()).thenReturn(true, true, false);
    when(context.next()).thenReturn(nodePointer, nodePointer);
    when(nodePointer.getValue()).thenReturn(10.0, 20.0);
    Object result = coreFunction.functionSum(context);
    assertEquals(Double.valueOf(30.0), result);
}
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
public void testFunctionLocalName_NoArguments_NodePresent_UpTn0() {
    CoreFunction coreFunction = new CoreFunction(0, new Expression[0]); // Assuming functionCode and args are not relevant for this test
    EvalContext context = mock(EvalContext.class);
    NodePointer nodePointer = mock(NodePointer.class);
    QName nodeName = new QName(null, "localName");
    when(context.getCurrentNodePointer()).thenReturn(nodePointer);
    when(nodePointer.getName()).thenReturn(nodeName);
    Object result = coreFunction.functionLocalName(context);
    assertEquals("localName", result);
}
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
public void testSubstringNormal_zNvk0_jgGk0() {
    String result = (String) coreFunction.functionSubstring(context);
}
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
public void testFunctionString_NoArguments_ReturnsCurrentNodePointerStringValue_CUcR0() throws Exception {
    final int functionCode = 1; // Example function code
    Expression[] args = new Expression[0]; // No arguments
    CoreFunction coreFunction = new CoreFunction(functionCode, args);
    EvalContext context = mock(EvalContext.class);
    NodePointer currentNodePointer = mock(NodePointer.class);
    when(context.getCurrentNodePointer()).thenReturn(currentNodePointer);
    when(currentNodePointer.asPath()).thenReturn("currentNodeValue");
    Object result = coreFunction.functionSubstring(context);
    assertEquals("currentNodeValue", result);
}
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
public void testFunctionSubstringWithValidInput_bvsn0() {
    Expression arg1 = mock(Expression.class);
    Expression arg2 = mock(Expression.class);
    Expression arg3 = mock(Expression.class);
    EvalContext context = mock(EvalContext.class);
    CoreFunction coreFunction = new CoreFunction(0, new Expression[]{arg1, arg2, arg3});
    when(arg1.computeValue(context)).thenReturn("example");
    when(arg2.computeValue(context)).thenReturn(3.0);
    when(arg3.computeValue(context)).thenReturn(4.0);
    Object result = coreFunction.functionSubstring(context);
    assertEquals("ampl", result);
}
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
public void testFunctionSubstringWithThreeArguments_cTyA0() {
    Expression arg1 = mock(Expression.class);
    Expression arg2 = mock(Expression.class);
    Expression arg3 = mock(Expression.class);
    Expression[] args = {arg1, arg2, arg3};
    CoreFunction coreFunction = new CoreFunction(0, args);
    EvalContext context = mock(EvalContext.class);
    when(arg1.computeValue(context)).thenReturn("example");
    when(arg2.computeValue(context)).thenReturn(3.0);
    when(arg3.computeValue(context)).thenReturn(4.0);
    Object result = coreFunction.functionSubstring(context);
    assertEquals("ampl", result);
}
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
public void testFunctionSubstringWithNegativeLength_KNEL0() {
    CoreFunction coreFunction = mock(CoreFunction.class);
    EvalContext context = mock(EvalContext.class);
    Expression arg1 = mock(Expression.class);
    Expression arg2 = mock(Expression.class);
    Expression arg3 = mock(Expression.class);
    when(coreFunction.getArgumentCount()).thenReturn(3);
    when(coreFunction.getArg1()).thenReturn(arg1);
    when(coreFunction.getArg2()).thenReturn(arg2);
    when(coreFunction.getArg3()).thenReturn(arg3);
    when(arg1.computeValue(context)).thenReturn("Hello World");
    when(arg2.computeValue(context)).thenReturn(3.0);
    when(arg3.computeValue(context)).thenReturn(-5.0);
    Object result = coreFunction.functionSubstring(context);
    assertEquals("", result);
}
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
public void testFunctionSubstringWithZeroLength_DpbV0() {
    Expression arg1 = mock(Expression.class);
    Expression arg2 = mock(Expression.class);
    Expression arg3 = mock(Expression.class);
    EvalContext context = mock(EvalContext.class);
    CoreFunction coreFunction = new CoreFunction(0, new Expression[]{arg1, arg2, arg3});
    when(arg1.computeValue(context)).thenReturn("example");
    when(arg2.computeValue(context)).thenReturn(3.0);
    when(arg3.computeValue(context)).thenReturn(0.0);
    Object result = coreFunction.functionSubstring(context);
    assertEquals("", result);
}
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
public void testFunctionCountWithEvalContext_axoP0() throws Exception {
    Expression expression = mock(Expression.class);
    EvalContext evalContext = mock(EvalContext.class);
    NodePointer nodePointer = mock(NodePointer.class);
    CoreFunction coreFunction = new CoreFunction(0, new Expression[]{expression});
    when(expression.computeValue(evalContext)).thenReturn(evalContext);
    when(evalContext.hasNext()).thenReturn(true, true, true, false);
    when(evalContext.next()).thenReturn(new Object(), new Object(), new Object());
    Object result = coreFunction.functionCount(evalContext);
    verify(expression, times(1)).computeValue(evalContext);
    verify(evalContext, times(4)).hasNext();
    verify(evalContext, times(3)).next();
    assertEquals(Double.valueOf(3), result);
}
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
public void testFunctionCountWithCollection_Nkni0() throws Exception {
    Expression expression = mock(Expression.class);
    EvalContext evalContext = mock(EvalContext.class);
    NodePointer nodePointer = mock(NodePointer.class);
    List<Integer> collection = Arrays.asList(1, 2, 3); // Example collection
    CoreFunction coreFunction = new CoreFunction(0, new Expression[]{expression});
    when(expression.computeValue(evalContext)).thenReturn(collection);
    Object result = coreFunction.functionCount(evalContext);
    verify(expression).computeValue(evalContext);
    assertEquals(Double.valueOf(collection.size()), result);
}
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
public void testFunctionCountWithNull_Zlqn0() throws Exception {
    Expression expression = mock(Expression.class);
    EvalContext evalContext = mock(EvalContext.class);
    CoreFunction coreFunction = new CoreFunction(0, new Expression[]{expression});
    when(expression.computeValue(evalContext)).thenReturn(null);
    Object result = coreFunction.functionCount(evalContext);
    verify(expression).computeValue(evalContext);
    assertEquals(Double.valueOf(0), result);
}
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
public void testFunctionCountWithSingleObject_AqBj0() throws Exception {
    Expression expression = mock(Expression.class);
    EvalContext evalContext = mock(EvalContext.class);
    NodePointer nodePointer = mock(NodePointer.class);
    CoreFunction coreFunction = new CoreFunction(0, new Expression[]{expression});
    Object singleObject = new Object();
    when(expression.computeValue(evalContext)).thenReturn(singleObject);
    Object result = coreFunction.functionCount(evalContext);
    verify(expression).computeValue(evalContext);
    assertEquals(Double.valueOf(1), result);
}
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testFunctionPosition() throws Exception {
        coreFunction = new CoreFunction(0, null); // Assuming functionCode and args are not used in functionPosition
        // Arrange
        EvalContext mockContext = mock(EvalContext.class);
        when(mockContext.getCurrentPosition()).thenReturn(5);
        // Act
        Object result = coreFunction.functionPosition(mockContext);
        // Assert
        assertNotNull(result, "Result should not be null");
        assertTrue(result instanceof Integer, "Result should be of type Integer");
        assertEquals(5, result, "The result should equal the current position returned by the context");
    }
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testFunctionSumWithInvalidArgumentType() throws Exception {
        coreFunction = new CoreFunction(0, new Expression[]{arg1});
        when(arg1.compute(context)).thenReturn(new Object());
        Exception exception = assertThrows(JXPathException.class, () -> {
            coreFunction.functionSum(context);
        });
        assertTrue(exception.getMessage().contains("Invalid argument type for 'sum'"));
    }
@Test
@Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testFunctionRound_Infinity() throws Exception {
        coreFunction = new CoreFunction(0, new Expression[]{arg1Expression});
        when(arg1Expression.computeValue(context)).thenReturn(Double.POSITIVE_INFINITY);
        Object result = coreFunction.functionRound(context);
        assertTrue(Double.isInfinite((Double) result) && (Double) result > 0);
        when(arg1Expression.computeValue(context)).thenReturn(Double.NEGATIVE_INFINITY);
        result = coreFunction.functionRound(context);
        assertTrue(Double.isInfinite((Double) result) && (Double) result < 0);
    }
}