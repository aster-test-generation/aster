/**
 * Generated by Aster
 */
package org.apache.commons.codec.binary;

import java.nio.ByteBuffer;
import java.nio.charset.Charset;
import java.util.concurrent.TimeUnit;
import org.apache.commons.codec.DecoderException;
import org.apache.commons.codec.EncoderException;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.Timeout;
import org.junit.jupiter.api.Timeout.ThreadMode;

import static org.junit.jupiter.api.Assertions.*;
import static org.junit.jupiter.api.Timeout.ThreadMode.SEPARATE_THREAD;

public class Aster_Hex_Test_Passing {
    @Test
    @Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testDecodeHexOddLength_lFmC1() {
        char[] data = new char[]{'0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'A', 'B', 'C', 'D', 'E', 'F', 'G'};
        byte[] out = new byte[data.length / 2];
        int outOffset = 0;
        try {
            Hex.decodeHex(data, out, outOffset);
            fail("Expected DecoderException");
        } catch (DecoderException e) {
            assertEquals("Odd number of characters.", e.getMessage());
        }
    }

    @Test
    @Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testDecodeHexOutputArrayTooSmall_vogl2() {
        char[] data = new char[]{'0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'A', 'B', 'C', 'D', 'E', 'F'};
        byte[] out = new byte[data.length / 2 - 1];
        int outOffset = 0;
        try {
            Hex.decodeHex(data, out, outOffset);
            fail("Expected DecoderException");
        } catch (DecoderException e) {
            assertEquals("Output array is not large enough to accommodate decoded data.", e.getMessage());
        }
    }

    @Test
    @Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testEncodeHex_emptyData_VfWX1() {
        char[] result = Hex.encodeHex(new byte[0]);
        assertEquals(0, result.length);
    }

    @Test
    @Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testEncodeHexWithNullData_rnkK4() {
        byte[] data = null;
        int dataOffset = 0;
        int dataLen = 0;
        boolean toLowerCase = true;
        char[] expected = new char[]{};
        char[] actual = Hex.encodeHex(data, dataOffset, dataLen, toLowerCase);
        assertArrayEquals(expected, actual);
    }

    @Test
    @Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testEncodeHexWithEmptyData_GNdA4() {
        byte[] data = new byte[]{};
        char[] expected = new char[]{};
        char[] actual = Hex.encodeHex(data, 0, data.length, true);
        assertArrayEquals(expected, actual);
    }

    @Test
    @Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testEncodeWithCharset_HeMf0() {
        Hex hex = new Hex(Charset.forName("UTF-8"));
        ByteBuffer array = ByteBuffer.wrap("Hello World".getBytes());
        byte[] encoded = hex.encode(array);
        assertEquals("48656c6c6f20576f726c64", new String(encoded, hex.getCharset()));
    }

    @Test
    @Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testEncodeWithCharsetName_SeTF1() {
        Hex hex = new Hex("UTF-8");
        ByteBuffer array = ByteBuffer.wrap("Hello World".getBytes());
        byte[] encoded = hex.encode(array);
        assertEquals("48656c6c6f20576f726c64", new String(encoded, hex.getCharset()));
    }

    @Test
    @Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testEncodeWithDefaultCharset_zttu2() {
        Hex hex = new Hex();
        ByteBuffer array = ByteBuffer.wrap("Hello World".getBytes());
        byte[] encoded = hex.encode(array);
        assertEquals("48656c6c6f20576f726c64", new String(encoded, hex.getCharset()));
    }

    @Test
    @Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testToDigit_InvalidCharacter_zCPT1() {
        try {
            Hex.toDigit('g', 0);
            fail("Expected DecoderException");
        } catch (DecoderException e) {
            assertEquals("Illegal hexadecimal character g at index 0", e.getMessage());
        }
    }

    @Test
    @Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testDecodeHexValid_PpEW0() throws DecoderException {
        char[] data = "68656c6c6f20776f726c64".toCharArray();
        byte[] expected = "hello world".getBytes();
        byte[] actual = Hex.decodeHex(data);
        assertArrayEquals(expected, actual);
    }

    @Test
    @Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testEncode_abAR0() {
        Hex hex = new Hex();
        byte[] input = new byte[]{0x01, 0x02, 0x03, 0x04, 0x05};
        byte[] expectedOutput = new byte[]{0x30, 0x31, 0x32, 0x33, 0x34, 0x35};
        byte[] actualOutput = hex.encode(input);
    }

    @Test
    @Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testEncodeWithCharset_sHzs1() {
        Hex hex = new Hex(Charset.forName("UTF-8"));
        byte[] input = new byte[]{0x01, 0x02, 0x03, 0x04, 0x05};
        byte[] expectedOutput = new byte[]{0x30, 0x31, 0x32, 0x33, 0x34, 0x35};
        byte[] actualOutput = hex.encode(input);
    }

    @Test
    @Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testEncodeWithCharsetName_oOwE2() {
        Hex hex = new Hex("UTF-8");
        byte[] input = new byte[]{0x01, 0x02, 0x03, 0x04, 0x05};
        byte[] expectedOutput = new byte[]{0x30, 0x31, 0x32, 0x33, 0x34, 0x35};
        byte[] actualOutput = hex.encode(input);
    }

    @Test
    @Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testGetCharsetName_DefaultConstructor_JyBO0() {
        Hex hex = new Hex();
        String charsetName = hex.getCharsetName();
        assertEquals("UTF-8", charsetName);
    }

    @Test
    @Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testGetCharsetName_CharsetConstructor_JGzh1() {
        Charset charset = Charset.forName("UTF-16");
        Hex hex = new Hex(charset);
        String charsetName = hex.getCharsetName();
        assertEquals("UTF-16", charsetName);
    }

    @Test
    @Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testGetCharsetName_CharsetNameConstructor_csmK2() {
        Hex hex = new Hex("UTF-32");
        String charsetName = hex.getCharsetName();
        assertEquals("UTF-32", charsetName);
    }

    @Test
    @Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testEncodeHexString1_bGSA0() {
        byte[] data = new byte[]{0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0A};
        String expected = "0102030405060708090A";
        String actual = Hex.encodeHexString(data);
    }

    @Test
    @Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testEncodeHexString2_rBmF1() {
        byte[] data = new byte[]{0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0A, 0x0B, 0x0C, 0x0D, 0x0E, 0x0F};
        String expected = "0102030405060708090a0b0c0d0e0f";
        String actual = Hex.encodeHexString(data);
        assertEquals(expected, actual);
    }

    @Test
    @Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testEncodeHexString3_Pejl2() {
        byte[] data = new byte[]{0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0A, 0x0B, 0x0C, 0x0D, 0x0E, 0x0F, 0x10};
        String expected = "0102030405060708090a0b0c0d0e0f10";
        String actual = Hex.encodeHexString(data);
        assertEquals(expected, actual);
    }

    @Test
    @Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testEncodeHexString_Sowj0() {
        ByteBuffer data = ByteBuffer.allocate(10);
        data.put((byte) 0x01);
        data.put((byte) 0x02);
        data.put((byte) 0x03);
        data.put((byte) 0x04);
        data.put((byte) 0x05);
        data.put((byte) 0x06);
        data.put((byte) 0x07);
        data.put((byte) 0x08);
        data.put((byte) 0x09);
        data.put((byte) 0x0A);
        data.flip();
        String expected = "0102030405060708090a";
        String actual = Hex.encodeHexString(data);
        assertEquals(expected, actual);
    }

    @Test
    @Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testEncodeHexStringWithEmptyBuffer_dOtF1() {
        ByteBuffer data = ByteBuffer.allocate(0);
        String expected = "";
        String actual = Hex.encodeHexString(data);
        assertEquals(expected, actual);
    }

    @Test
    @Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testToStringWithDefaultCharset_JrVp2() {
        Hex hex = new Hex();
        String expected = "Hex[charsetName=UTF-8]";
        String actual = hex.toString();
    }

    @Test
    @Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testEncodeHexString1_Bfho0() {
        byte[] data = new byte[]{0x01, 0x02, 0x03, 0x04, 0x05};
        String expected = "0102030405";
        String actual = Hex.encodeHexString(data, true);
        assertEquals(expected, actual);
    }

    @Test
    @Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testEncodeHexString2_YxiB1() {
        byte[] data = new byte[]{0x01, 0x02, 0x03, 0x04, 0x05};
        String expected = "0102030405";
        String actual = Hex.encodeHexString(data, false);
        assertEquals(expected, actual);
    }

    @Test
    @Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testEncodeHex_UOIc0() {
        byte[] data = new byte[]{0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0A};
        int dataOffset = 0;
        int dataLen = data.length;
        boolean toLowerCase = true;
        char[] out = new char[dataLen * 2];
        int outOffset = 0;
        Hex.encodeHex(data, dataOffset, dataLen, toLowerCase, out, outOffset);
    }

    @Test
    @Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testEncodeHexWithUpperCase_Npwi1() {
        byte[] data = new byte[]{0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0A};
        int dataOffset = 0;
        int dataLen = data.length;
        boolean toLowerCase = false;
        char[] out = new char[dataLen * 2];
        int outOffset = 0;
        Hex.encodeHex(data, dataOffset, dataLen, toLowerCase, out, outOffset);
        assertEquals("0102030405060708090A", new String(out));
    }

    @Test
    @Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testEncodeHexWithOffset_JLHr2() {
        byte[] data = new byte[]{0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0A};
        int dataOffset = 2;
        int dataLen = data.length - dataOffset;
        boolean toLowerCase = true;
        char[] out = new char[dataLen * 2];
        int outOffset = 0;
        Hex.encodeHex(data, dataOffset, dataLen, toLowerCase, out, outOffset);
    }

    @Test
    @Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testEncodeHexWithInvalidDataAndOffset_IaKO4() {
        byte[] data = new byte[]{0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0A};
        int dataOffset = 2;
        int dataLen = data.length - dataOffset;
        boolean toLowerCase = true;
        char[] out = new char[dataLen * 2];
        int outOffset = 0;
        Hex.encodeHex(data, dataOffset, dataLen, toLowerCase, out, outOffset);
        assertEquals("030405060708090a", new String(out));
    }

    @Test
    @Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testEncodeHex_IzmB0_1() {
        byte[] data = new byte[]{0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0A};
        char[] toDigits = new char[]{'0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'A', 'B', 'C', 'D', 'E', 'F'};
        char[] out = new char[data.length * 2];
        int dataOffset = 0;
        int dataLen = data.length;
        boolean toLowerCase = true;
        int outOffset = 0;
        Hex.encodeHex(data, dataOffset, dataLen, toLowerCase, out, outOffset);
        assertEquals(toDigits[0], out[0]);
    }

    @Test
    @Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testEncodeHex_IzmB0_2() {
        byte[] data = new byte[]{0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0A};
        char[] toDigits = new char[]{'0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'A', 'B', 'C', 'D', 'E', 'F'};
        char[] out = new char[data.length * 2];
        int dataOffset = 0;
        int dataLen = data.length;
        boolean toLowerCase = true;
        int outOffset = 0;
        Hex.encodeHex(data, dataOffset, dataLen, toLowerCase, out, outOffset);
        assertEquals(toDigits[1], out[1]);
    }

    @Test
    @Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testEncodeHex_IzmB0_3() {
        byte[] data = new byte[]{0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0A};
        char[] toDigits = new char[]{'0', '1', '0', '3', '4', '5', '6', '7', '8', '9', 'A', 'B', 'C', 'D', 'E', 'F'};
        char[] out = new char[data.length * 2];
        int dataOffset = 0;
        int dataLen = data.length;
        boolean toLowerCase = true;
        int outOffset = 0;
        Hex.encodeHex(data, dataOffset, dataLen, toLowerCase, out, outOffset);
        assertEquals(toDigits[2], out[2]);
    }

    @Test
    @Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testEncodeHex_IzmB0_4() {
        byte[] data = new byte[]{0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0A};
        char[] toDigits = new char[]{'0', '1', '2', '2', '4', '5', '6', '7', '8', '9', 'A', 'B', 'C', 'D', 'E', 'F'};
        char[] out = new char[data.length * 2];
        int dataOffset = 0;
        int dataLen = data.length;
        boolean toLowerCase = true;
        int outOffset = 0;
        Hex.encodeHex(data, dataOffset, dataLen, toLowerCase, out, outOffset);
        assertEquals(toDigits[3], out[3]);
    }

    @Test
    @Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testEncodeHex_IzmB0_5() {
        byte[] data = new byte[]{0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0A};
        char[] toDigits = new char[]{'0', '1', '2', '3', '0', '5', '6', '7', '8', '9', 'A', 'B', 'C', 'D', 'E', 'F'};
        char[] out = new char[data.length * 2];
        int dataOffset = 0;
        int dataLen = data.length;
        boolean toLowerCase = true;
        int outOffset = 0;
        Hex.encodeHex(data, dataOffset, dataLen, toLowerCase, out, outOffset);
        assertEquals(toDigits[4], out[4]);
    }

    @Test
    @Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testEncodeHex_IzmB0_6() {
        byte[] data = new byte[]{0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0A};
        char[] toDigits = new char[]{'0', '1', '2', '3', '4', '3', '6', '7', '8', '9', 'A', 'B', 'C', 'D', 'E', 'F'};
        char[] out = new char[data.length * 2];
        int dataOffset = 0;
        int dataLen = data.length;
        boolean toLowerCase = true;
        int outOffset = 0;
        Hex.encodeHex(data, dataOffset, dataLen, toLowerCase, out, outOffset);
        assertEquals(toDigits[5], out[5]);
    }

    @Test
    @Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testEncodeHex_IzmB0_7() {
        byte[] data = new byte[]{0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0A};
        char[] toDigits = new char[]{'0', '1', '2', '3', '4', '5', '0', '7', '8', '9', 'A', 'B', 'C', 'D', 'E', 'F'};
        char[] out = new char[data.length * 2];
        int dataOffset = 0;
        int dataLen = data.length;
        boolean toLowerCase = true;
        int outOffset = 0;
        Hex.encodeHex(data, dataOffset, dataLen, toLowerCase, out, outOffset);
        assertEquals(toDigits[6], out[6]);
    }

    @Test
    @Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testEncodeHex_IzmB0_8() {
        byte[] data = new byte[]{0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0A};
        char[] toDigits = new char[]{'0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'A', 'B', 'C', 'D', 'E', 'F'};
        char[] out = new char[data.length * 2];
        int dataOffset = 0;
        int dataLen = data.length;
        boolean toLowerCase = true;
        int outOffset = 0;
        Hex.encodeHex(data, dataOffset, dataLen, toLowerCase, out, outOffset);
    }

    @Test
    @Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testGetCharset_DefaultConstructor_hLIx0() {
        Hex hex = new Hex();
        Charset charset = hex.getCharset();
        assertEquals(Charset.defaultCharset(), charset);
    }

    @Test
    @Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testGetCharset_CharsetConstructor_IdNB1() {
        Charset charset = Charset.forName("UTF-8");
        Hex hex = new Hex(charset);
        assertEquals(charset, hex.getCharset());
    }

    @Test
    @Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testGetCharset_CharsetNameConstructor_mgQJ2() {
        String charsetName = "UTF-8";
        Hex hex = new Hex(charsetName);
        Charset charset = hex.getCharset();
        assertEquals(Charset.forName(charsetName), charset);
    }

    @Test
    @Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testEncodeByteBuffer_uGGI1_eopE0() throws EncoderException {
        Hex hex = new Hex(Charset.forName("UTF-8"));
        ByteBuffer input = ByteBuffer.wrap("Hello, World!".getBytes());
        String expectedOutput = "48656c6c6f2c20576f726c6421";
        byte[] actualOutput = hex.encode(input);
        assertEquals(expectedOutput, new String(actualOutput));
    }

    @Test
    @Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testToDigit_ValidCharacter_rTVd0_bopG0() {
        try {
            int digit = Hex.toDigit('a', 0);
            assertEquals(10, digit);
        } catch (DecoderException e) {
            fail("Exception should not be thrown");
        }
    }
}