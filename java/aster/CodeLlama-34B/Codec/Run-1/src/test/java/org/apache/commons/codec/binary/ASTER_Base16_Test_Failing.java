/**
 * Generated by Aster
 */
package org.apache.commons.codec.binary;

import static org.junit.jupiter.api.Assertions.*;
import static org.junit.jupiter.api.Timeout.ThreadMode.SEPARATE_THREAD;

import java.util.concurrent.TimeUnit;
import org.apache.commons.codec.CodecPolicy;
import org.apache.commons.codec.DecoderException;
import org.apache.commons.codec.EncoderException;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.Timeout;
import org.junit.jupiter.api.Timeout.ThreadMode;

public class Aster_Base16_Test_Failing {
    @Test
    @Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testDecode_LowerCase_Strict_BZtz0() {
        Base16 base16 = new Base16(true, CodecPolicy.STRICT);
        byte[] expected = new byte[]{0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0A, 0x0B, 0x0C, 0x0D, 0x0E, 0x0F};
        byte[] actual = base16.decode("0102030405060708090A0B0C0D0E0F");
        assertArrayEquals(expected, actual);
    }

    @Test
    @Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testDecode_LowerCase_Lenient_baQd1() {
        Base16 base16 = new Base16(true, CodecPolicy.LENIENT);
        byte[] expected = new byte[]{0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0A, 0x0B, 0x0C, 0x0D, 0x0E, 0x0F};
        byte[] actual = base16.decode("0102030405060708090A0B0C0D0E0F");
        assertArrayEquals(expected, actual);
    }

    @Test
    @Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testEncodeAsString_lowerCase_strictDecodingPolicy_Hyaz0() {
        Base16 base16 = new Base16(true, CodecPolicy.STRICT);
        byte[] input = new byte[]{0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0A, 0x0B, 0x0C, 0x0D, 0x0E, 0x0F, 0x10};
        String expected = "0102030405060708090A0B0C0D0E0F10";
        String actual = base16.encodeAsString(input);
        assertEquals(expected, actual);
    }

    @Test
    @Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testEncodeAsString_lowerCase_lenientDecodingPolicy_tlGe2() {
        Base16 base16 = new Base16(true, CodecPolicy.LENIENT);
        byte[] input = new byte[]{0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0A, 0x0B, 0x0C, 0x0D, 0x0E, 0x0F, 0x10};
        String expected = "0102030405060708090A0B0C0D0E0F10";
        String actual = base16.encodeAsString(input);
        assertEquals(expected, actual);
    }

    @Test
    @Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testIsInAlphabet_QCjS0_1() {
        Base16 base16 = new Base16(true, CodecPolicy.STRICT);
        assertTrue(base16.isInAlphabet("0123456789ABCDEF"));
    }

    @Test
    @Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testIsInAlphabet_QCjS0_4() {
        Base16 base16 = new Base16(true, CodecPolicy.STRICT);
        assertFalse(base16.isInAlphabet(""));
    }

    @Test
    @Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testEncode_null_JJns2() throws EncoderException {
        Base16 base16 = new Base16(true);
        assertThrows(EncoderException.class, () -> base16.encode(null));
    }

    @Test
    @Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testGetEncodedLength_lowerCase_strict_HIol0() {
        Base16 base16 = new Base16(true, CodecPolicy.STRICT);
        byte[] pArray = new byte[10];
        long expected = 16;
        long actual = base16.getEncodedLength(pArray);
        assertEquals(expected, actual);
    }

    @Test
    @Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testGetEncodedLength_upperCase_lenient_QHwx2() {
        Base16 base16 = new Base16(false, CodecPolicy.LENIENT);
        byte[] pArray = new byte[10];
        long expected = 16;
        long actual = base16.getEncodedLength(pArray);
        assertEquals(expected, actual);
    }

    @Test
    @Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testGetDefaultBufferSize_amxa0() {
        Base16 base16 = new Base16();
        int defaultBufferSize = base16.getDefaultBufferSize();
        assertEquals(1024, defaultBufferSize);
    }

    @Test
    @Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testGetDefaultBufferSizeWithLowerCase_XyiK1() {
        Base16 base16 = new Base16(true);
        int defaultBufferSize = base16.getDefaultBufferSize();
        assertEquals(1024, defaultBufferSize);
    }

    @Test
    @Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testGetDefaultBufferSizeWithDecodingPolicy_HYlb2() {
        Base16 base16 = new Base16(false, CodecPolicy.STRICT);
        int defaultBufferSize = base16.getDefaultBufferSize();
        assertEquals(1024, defaultBufferSize);
    }

    @Test
    @Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testGetDefaultBufferSizeWithLowerCaseAndDecodingPolicy_swTB3() {
        Base16 base16 = new Base16(true, CodecPolicy.STRICT);
        int defaultBufferSize = base16.getDefaultBufferSize();
        assertEquals(1024, defaultBufferSize);
    }

    @Test
    @Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testIsInAlphabet_LowerCase_True_KkXO0() {
        Base16 base16 = new Base16(true);
        byte[] arrayOctet = new byte[]{10, 20, 30, 40, 50};
        boolean allowWSPad = true;
        assertTrue(base16.isInAlphabet(arrayOctet, allowWSPad));
    }

    @Test
    @Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testIsInAlphabet_UpperCase_True_fhLu2() {
        Base16 base16 = new Base16(false);
        byte[] arrayOctet = new byte[]{10, 20, 30, 40, 50};
        boolean allowWSPad = true;
        assertTrue(base16.isInAlphabet(arrayOctet, allowWSPad));
    }

    @Test
    @Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testDecodeByteArray_pJgE0() throws DecoderException {
        Base16 base16 = new Base16(true, CodecPolicy.STRICT);
        byte[] input = new byte[]{0x01, 0x02, 0x03, 0x04};
        byte[] expectedOutput = new byte[]{0x01, 0x02, 0x03, 0x04};
        byte[] actualOutput = base16.decode(input);
        assertArrayEquals(expectedOutput, actualOutput);
    }

    @Test
    @Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testEncode_MixOfPositiveAndNegativeNumbersAndZeroes_NWnj2_2() {
        Base16 base16 = new Base16(true, CodecPolicy.STRICT);
        byte[] input = new byte[]{1, -2, 3, -4, 5, -6, 7, -8, 9, -10};
        byte[] output = base16.encode(input, 0, input.length);
        assertEquals("313233343536373839310", new String(output));
    }

    @Test
    @Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testGetChunkSeparator_wLAB0_2() {
        Base16 base16 = new Base16();
        byte[] chunkSeparator = base16.getChunkSeparator();
        base16 = new Base16(true);
        chunkSeparator = base16.getChunkSeparator();
        base16 = new Base16(true, CodecPolicy.STRICT);
        chunkSeparator = base16.getChunkSeparator();
        base16 = new Base16(true, CodecPolicy.LENIENT);
        chunkSeparator = base16.getChunkSeparator();
        assertEquals(0x0A, chunkSeparator[0]);
    }

    @Test
    @Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testGetChunkSeparator_wLAB0_3() {
        Base16 base16 = new Base16();
        byte[] chunkSeparator = base16.getChunkSeparator();
        base16 = new Base16(true);
        chunkSeparator = base16.getChunkSeparator();
        base16 = new Base16(true, CodecPolicy.STRICT);
        chunkSeparator = base16.getChunkSeparator();
        base16 = new Base16(true, CodecPolicy.LENIENT);
        chunkSeparator = base16.getChunkSeparator();
        assertEquals(0x0D, chunkSeparator[1]);
    }

    @Test
    @Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testContainsAlphabetOrPad_LowerCase_Strict_rJyu0() {
        Base16 base16 = new Base16(true, CodecPolicy.STRICT);
        byte[] arrayOctet = new byte[]{1, 2, 3, 4, 5, 6, 7, 8, 9, 10};
        assertTrue(base16.containsAlphabetOrPad(arrayOctet));
    }

    @Test
    @Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testContainsAlphabetOrPad_UpperCase_Strict_eifg1() {
        Base16 base16 = new Base16(false, CodecPolicy.STRICT);
        byte[] arrayOctet = new byte[]{1, 2, 3, 4, 5, 6, 7, 8, 9, 10};
        assertTrue(base16.containsAlphabetOrPad(arrayOctet));
    }

    @Test
    @Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testContainsAlphabetOrPad_LowerCase_Lenient_vRXY2() {
        Base16 base16 = new Base16(true, CodecPolicy.LENIENT);
        byte[] arrayOctet = new byte[]{1, 2, 3, 4, 5, 6, 7, 8, 9, 10};
        assertTrue(base16.containsAlphabetOrPad(arrayOctet));
    }

    @Test
    @Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testContainsAlphabetOrPad_UpperCase_Lenient_IZmi3() {
        Base16 base16 = new Base16(false, CodecPolicy.LENIENT);
        byte[] arrayOctet = new byte[]{1, 2, 3, 4, 5, 6, 7, 8, 9, 10};
        assertTrue(base16.containsAlphabetOrPad(arrayOctet));
    }

    @Test
    @Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testAvailable_LowerCase_lQwg0_gqxe0() {
        Base16 base16 = new Base16(true);
        int available = base16.available(null);
        assertEquals(0, available);
    }

    @Test
    @Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testAvailable_LowerCase_Strict_tmsJ2_VOKl0() {
        Base16 base16 = new Base16(true, CodecPolicy.STRICT);
        int available = base16.available(null);
        assertEquals(0, available);
    }

    @Test
    @Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testAvailable_LowerCase_Lenient_NHos3_HUaR0() {
        Base16 base16 = new Base16(true, CodecPolicy.LENIENT);
        int available = base16.available(null);
        assertEquals(0, available);
    }

    @Test
    @Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testAvailable_UpperCase_Strict_BPLK4_VOdr0() {
        Base16 base16 = new Base16(false, CodecPolicy.STRICT);
        int available = base16.available(null);
        assertEquals(0, available);
    }

    @Test
    @Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testEncode_emptyByteArray_OeWr4_BULv0() throws EncoderException {
        Base16 base16 = new Base16(true);
        byte[] input = new byte[0];
        String expected = "";
        byte[] actual = base16.encode(input);
        assertEquals(expected, actual);
    }

    @Test
    @Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testEnsureBufferSize_ExactSize_jvCU2_KHxG0() {
        Base16 base16 = new Base16();
        byte[] buffer = base16.ensureBufferSize(100, new Base16.Context());
        assertEquals(100, buffer.length);
    }

    @Test
    @Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testIsInAlphabet_QCjS0() {
        Base16 base16 = new Base16(true, CodecPolicy.STRICT);
        assertTrue(base16.isInAlphabet("0123456789ABCDEF"));
        assertFalse(base16.isInAlphabet("GHIJKLMNOPQRSTUVWXYZ"));
        assertFalse(base16.isInAlphabet("abcdefghijklmnopqrstuvwxyz"));
        assertFalse(base16.isInAlphabet(""));
    }

    @Test
    @Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testEncode_MixOfPositiveAndNegativeNumbersAndZeroes_NWnj2() {
        Base16 base16 = new Base16(true, CodecPolicy.STRICT);
        byte[] input = new byte[]{1, -2, 3, -4, 5, -6, 7, -8, 9, -10};
        byte[] output = base16.encode(input, 0, input.length);
        assertEquals(20, output.length);
        assertEquals("313233343536373839310", new String(output));
    }

    @Test
    @Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testGetChunkSeparator_wLAB0() {
        Base16 base16 = new Base16();
        byte[] chunkSeparator = base16.getChunkSeparator();
        assertEquals(2, chunkSeparator.length);
        assertEquals(0x0A, chunkSeparator[0]);
        assertEquals(0x0D, chunkSeparator[1]);
        base16 = new Base16(true);
        chunkSeparator = base16.getChunkSeparator();
        assertEquals(2, chunkSeparator.length);
        assertEquals(0x0A, chunkSeparator[0]);
        assertEquals(0x0D, chunkSeparator[1]);
        base16 = new Base16(true, CodecPolicy.STRICT);
        chunkSeparator = base16.getChunkSeparator();
        assertEquals(2, chunkSeparator.length);
        assertEquals(0x0A, chunkSeparator[0]);
        assertEquals(0x0D, chunkSeparator[1]);
        base16 = new Base16(true, CodecPolicy.LENIENT);
        chunkSeparator = base16.getChunkSeparator();
        assertEquals(2, chunkSeparator.length);
        assertEquals(0x0A, chunkSeparator[0]);
        assertEquals(0x0D, chunkSeparator[1]);
    }
}