/**
 * Generated by Aster
 */
package org.apache.commons.cli;

import static org.junit.jupiter.api.Assertions.*;
import static org.junit.jupiter.api.Timeout.ThreadMode.SEPARATE_THREAD;

import java.io.File;
import java.io.FileInputStream;
import java.math.BigDecimal;
import java.math.BigInteger;
import java.net.URL;
import java.nio.file.Path;
import java.util.Date;
import java.util.List;
import java.util.Map;
import java.util.concurrent.TimeUnit;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.Timeout;
import org.junit.jupiter.api.Timeout.ThreadMode;

public class Aster_TypeHandler_Test_Failing {
    @Test
    @Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testCreateValueWithInvalidString_LLxw3() {
        try {
            Object result = TypeHandler.createValue("hello", Integer.class);
            assertNotNull(result);
        } catch (ParseException e) {
            fail("Exception should not be thrown");
        }
    }

    @Test
    @Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testCreateValueWithInvalidClass_vbvd5() {
        try {
            Object result = TypeHandler.createValue("hello", Object.class);
            assertNotNull(result);
        } catch (ParseException e) {
            fail("Exception should not be thrown");
        }
    }

    @Test
    @Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testCreateClassWithNullClassName_aQkb2() throws ParseException {
        String className = null;
        try {
            TypeHandler.createObject(className);
            fail("Expected NullPointerException");
        } catch (NullPointerException e) {
            assertEquals("Class name cannot be null", e.getMessage());
        }
    }

    @Test
    @Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testCreateClassWithNonExistentClass_SdSd5() throws ParseException {
        String className = "com.example.NonExistentClass";
        try {
            TypeHandler.createClass(className);
            fail("Expected ParseException");
        } catch (ParseException e) {
            assertEquals(className, e.getMessage());
        }
    }

    @Test
    @Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testCreateClassWithPrimitiveType_cEQQ6() throws ParseException {
        String className = "int";
        Class<?> expectedClass = int.class;
        Class<?> actualClass = TypeHandler.createClass(className);
        assertSame(expectedClass, actualClass);
    }

    @Test
    @Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testCreateClassWithArrayType_bWBF7() throws ParseException {
        String className = "java.lang.String[]";
        Class<?> expectedClass = String[].class;
        Class<?> actualClass = TypeHandler.createClass(className);
        assertEquals(expectedClass, actualClass);
    }

    @Test
    @Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testCreateClassWithGenericType_yhrA8() throws ParseException {
        String className = "java.util.List<java.lang.String>";
        Class<?> expectedClass = List.class;
        Class<?> actualClass = TypeHandler.createClass(className);
        assertEquals(expectedClass, actualClass);
    }

    @Test
    @Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testCreateClassWithWildcardType_NAni10() throws ParseException {
        String className = "java.util.List<? extends java.lang.String>";
        Class<?> expectedClass = List.class;
        Class<?> actualClass = TypeHandler.createClass(className);
        assertEquals(expectedClass, actualClass);
    }

    @Test
    @Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testCreateClassWithTypeVariable_TpLN11() throws ParseException {
        String className = "java.util.List<T>";
        Class<?> expectedClass = List.class;
        Class<?> actualClass = TypeHandler.createClass(className);
        assertEquals(expectedClass, actualClass);
    }

    @Test
    @Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testCreateFile_wafR0_1() {
        String filePath = "C:\\temp\\test.txt";
        File file = TypeHandler.createFile(filePath);
        filePath = "C:\\temp\\test.txt";
        file = TypeHandler.createFile(filePath);
        filePath = null;
        file = TypeHandler.createFile(filePath);
        assertNotNull(file);
    }

    @Test
    @Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testCreateValue_String_Class_NullString_ungj1() throws ParseException {
        String string = null;
        Class<Integer> clazz = Integer.class;
        Integer expected = null;
        Integer actual = TypeHandler.createValue(string, clazz);
        assertNull(actual);
    }

    @Test
    @Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testCreateValue_String_Class_NullClass_YYcX2() throws ParseException {
        String string = "123";
        Class<Integer> clazz = null;
        Object expected = null;
        Object actual = TypeHandler.createValue(string, clazz);
        assertEquals(expected, actual);
    }

    @Test
    @Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testCreateValue_String_Class_InvalidString_wgyI3() throws ParseException {
        String string = "abc";
        Class<Integer> clazz = Integer.class;
        Integer expected = null;
        Integer actual = TypeHandler.createValue(string, clazz);
        assertNull(actual);
    }

    @Test
    @Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testCreateValue_String_Class_EmptyString_dfHQ6() throws ParseException {
        String string = "";
        Class<Integer> clazz = Integer.class;
        Integer expected = null;
        Integer actual = TypeHandler.createValue(string, clazz);
        assertNull(actual);
    }

    @Test
    @Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testGetDefaultReturnsNewInstance_EsJI1() {
        TypeHandler defaultHandler1 = TypeHandler.getDefault();
        TypeHandler defaultHandler2 = TypeHandler.getDefault();
        assertNotEquals(defaultHandler1, defaultHandler2);
    }

    @Test
    @Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testCreateNumber_SjNq0_1() throws ParseException {
        String validNumberString = "123";
        Number expectedNumber = 123;
        Number actualNumber = TypeHandler.createNumber(validNumberString);
        String validNumberStringWithDecimal = "123.456";
        Number expectedNumberWithDecimal = 123.456;
        Number actualNumberWithDecimal = TypeHandler.createNumber(validNumberStringWithDecimal);
        String validNumberStringWithNegativeValue = "-123";
        Number expectedNumberWithNegativeValue = -123;
        Number actualNumberWithNegativeValue = TypeHandler.createNumber(validNumberStringWithNegativeValue);
        String validNumberStringWithZeroValue = "0";
        Number expectedNumberWithZeroValue = 0;
        Number actualNumberWithZeroValue = TypeHandler.createNumber(validNumberStringWithZeroValue);
        String validNumberStringWithScientificNotation = "1.23e+2";
        Number expectedNumberWithScientificNotation = 123;
        Number actualNumberWithScientificNotation = TypeHandler.createNumber(validNumberStringWithScientificNotation);
        String validNumberStringWithHexadecimal = "0x123";
        Number expectedNumberWithHexadecimal = 0x123;
        Number actualNumberWithHexadecimal = TypeHandler.createNumber(validNumberStringWithHexadecimal);
        String validNumberStringWithBinary = "0b101010";
        Number expectedNumberWithBinary = 0b101010;
        Number actualNumberWithBinary = TypeHandler.createNumber(validNumberStringWithBinary);
        String validNumberStringWithOctal = "0123";
        Number expectedNumberWithOctal = 0123;
        Number actualNumberWithOctal = TypeHandler.createNumber(validNumberStringWithOctal);
        String validNumberStringWithLeadingZero = "0123";
        Number expectedNumberWithLeadingZero = 123;
        Number actualNumberWithLeadingZero = TypeHandler.createNumber(validNumberStringWithLeadingZero);
        String validNumberStringWithTrailingZero = "1230";
        Number expectedNumberWithTrailingZero = 123;
        Number actualNumberWithTrailingZero = TypeHandler.createNumber(validNumberStringWithTrailingZero);
        String validNumberStringWithLeadingDecimalPoint = ".123";
        Number expectedNumberWithLeadingDecimalPoint = 0.123;
        Number actualNumberWithLeadingDecimalPoint = TypeHandler.createNumber(validNumberStringWithLeadingDecimalPoint);
        assertEquals(expectedNumberWithHexadecimal, actualNumberWithHexadecimal);
    }

    @Test
    @Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testCreateNumber_SjNq0_2() throws ParseException {
        String validNumberString = "123";
        Number expectedNumber = 123;
        Number actualNumber = TypeHandler.createNumber(validNumberString);
        String validNumberStringWithDecimal = "123.456";
        Number expectedNumberWithDecimal = 123.456;
        Number actualNumberWithDecimal = TypeHandler.createNumber(validNumberStringWithDecimal);
        String validNumberStringWithNegativeValue = "-123";
        Number expectedNumberWithNegativeValue = -123;
        Number actualNumberWithNegativeValue = TypeHandler.createNumber(validNumberStringWithNegativeValue);
        String validNumberStringWithZeroValue = "0";
        Number expectedNumberWithZeroValue = 0;
        Number actualNumberWithZeroValue = TypeHandler.createNumber(validNumberStringWithZeroValue);
        String validNumberStringWithScientificNotation = "1.23e+2";
        Number expectedNumberWithScientificNotation = 123;
        Number actualNumberWithScientificNotation = TypeHandler.createNumber(validNumberStringWithScientificNotation);
        String validNumberStringWithHexadecimal = "0x123";
        Number expectedNumberWithHexadecimal = 0x123;
        Number actualNumberWithHexadecimal = TypeHandler.createNumber(validNumberStringWithHexadecimal);
        String validNumberStringWithBinary = "0b101010";
        Number expectedNumberWithBinary = 0b101010;
        Number actualNumberWithBinary = TypeHandler.createNumber(validNumberStringWithBinary);
        String validNumberStringWithOctal = "0123";
        Number expectedNumberWithOctal = 0123;
        Number actualNumberWithOctal = TypeHandler.createNumber(validNumberStringWithOctal);
        String validNumberStringWithLeadingZero = "0123";
        Number expectedNumberWithLeadingZero = 123;
        Number actualNumberWithLeadingZero = TypeHandler.createNumber(validNumberStringWithLeadingZero);
        String validNumberStringWithTrailingZero = "1230";
        Number expectedNumberWithTrailingZero = 123;
        Number actualNumberWithTrailingZero = TypeHandler.createNumber(validNumberStringWithTrailingZero);
        String validNumberStringWithLeadingDecimalPoint = ".123";
        Number expectedNumberWithLeadingDecimalPoint = 0.123;
        Number actualNumberWithLeadingDecimalPoint = TypeHandler.createNumber(validNumberStringWithLeadingDecimalPoint);
        assertEquals(expectedNumberWithDecimal, actualNumberWithDecimal);
        assertEquals(expectedNumberWithHexadecimal, actualNumberWithHexadecimal);
    }

    @Test
    @Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testCreateNumber_SjNq0_4() throws ParseException {
        String validNumberString = "123";
        Number expectedNumber = 123;
        Number actualNumber = TypeHandler.createNumber(validNumberString);
        String validNumberStringWithDecimal = "123.456";
        Number expectedNumberWithDecimal = 123.456;
        Number actualNumberWithDecimal = TypeHandler.createNumber(validNumberStringWithDecimal);
        String validNumberStringWithNegativeValue = "-123";
        Number expectedNumberWithNegativeValue = -123;
        Number actualNumberWithNegativeValue = TypeHandler.createNumber(validNumberStringWithNegativeValue);
        String validNumberStringWithZeroValue = "0";
        Number expectedNumberWithZeroValue = 0;
        Number actualNumberWithZeroValue = TypeHandler.createNumber(validNumberStringWithZeroValue);
        String validNumberStringWithScientificNotation = "1.23e+2";
        Number expectedNumberWithScientificNotation = 123;
        Number actualNumberWithScientificNotation = TypeHandler.createNumber(validNumberStringWithScientificNotation);
        String validNumberStringWithHexadecimal = "0x123";
        Number expectedNumberWithHexadecimal = 291;
        Number actualNumberWithHexadecimal = TypeHandler.createNumber(validNumberStringWithHexadecimal);
        String validNumberStringWithBinary = "0b101010";
        Number expectedNumberWithBinary = 42;
        Number actualNumberWithBinary = TypeHandler.createNumber(validNumberStringWithBinary);
        String validNumberStringWithOctal = "0123";
        Number expectedNumberWithOctal = 83;
        Number actualNumberWithOctal = TypeHandler.createNumber(validNumberStringWithOctal);
        String validNumberStringWithLeadingZero = "0123";
        Number expectedNumberWithLeadingZero = 123;
        Number actualNumberWithLeadingZero = TypeHandler.createNumber(validNumberStringWithLeadingZero);
        String validNumberStringWithTrailingZero = "1230";
        Number expectedNumberWithTrailingZero = 123;
        Number actualNumberWithTrailingZero = TypeHandler.createNumber(validNumberStringWithTrailingZero);
        String validNumberStringWithLeadingDecimalPoint = ".123";
        Number expectedNumberWithLeadingDecimalPoint = 0.123;
        Number actualNumberWithLeadingDecimalPoint = TypeHandler.createNumber(validNumberStringWithLeadingDecimalPoint);
        assertEquals(expectedNumberWithZeroValue, actualNumberWithZeroValue);
    }

    @Test
    @Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testCreateNumber_SjNq0_7() throws ParseException {
        String validNumberString = "123";
        Number expectedNumber = 123;
        Number actualNumber = TypeHandler.createNumber(validNumberString);
        String validNumberStringWithDecimal = "123.456";
        Number expectedNumberWithDecimal = 123.456;
        Number actualNumberWithDecimal = TypeHandler.createNumber(validNumberStringWithDecimal);
        String validNumberStringWithNegativeValue = "-123";
        Number expectedNumberWithNegativeValue = -123;
        Number actualNumberWithNegativeValue = TypeHandler.createNumber(validNumberStringWithNegativeValue);
        String validNumberStringWithZeroValue = "0";
        Number expectedNumberWithZeroValue = 0;
        Number actualNumberWithZeroValue = TypeHandler.createNumber(validNumberStringWithZeroValue);
        String validNumberStringWithScientificNotation = "1.23e+2";
        Number expectedNumberWithScientificNotation = 123;
        Number actualNumberWithScientificNotation = TypeHandler.createNumber(validNumberStringWithScientificNotation);
        String validNumberStringWithHexadecimal = "0x123";
        Number expectedNumberWithHexadecimal = 0x123;
        Number actualNumberWithHexadecimal = TypeHandler.createNumber(validNumberStringWithHexadecimal);
        String validNumberStringWithBinary = "0b101010";
        Number expectedNumberWithBinary = 0b101010;
        Number actualNumberWithBinary = TypeHandler.createNumber(validNumberStringWithBinary);
        String validNumberStringWithOctal = "0123";
        Number expectedNumberWithOctal = 0123;
        Number actualNumberWithOctal = TypeHandler.createNumber(validNumberStringWithOctal);
        String validNumberStringWithLeadingZero = "0123";
        Number expectedNumberWithLeadingZero = 123;
        Number actualNumberWithLeadingZero = TypeHandler.createNumber(validNumberStringWithLeadingZero);
        String validNumberStringWithTrailingZero = "1230";
        Number expectedNumberWithTrailingZero = 123;
        Number actualNumberWithTrailingZero = TypeHandler.createNumber(validNumberStringWithTrailingZero);
        String validNumberStringWithLeadingDecimalPoint = ".123";
        Number expectedNumberWithLeadingDecimalPoint = 0.123;
        Number actualNumberWithLeadingDecimalPoint = TypeHandler.createNumber(validNumberStringWithLeadingDecimalPoint);
        assertEquals(expectedNumberWithBinary, actualNumberWithBinary);
        assertEquals(expectedNumberWithHexadecimal, actualNumberWithHexadecimal);
    }

    @Test
    @Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testCreateNumber_SjNq0_8() throws ParseException {
        String validNumberString = "123";
        Number expectedNumber = 123;
        Number actualNumber = TypeHandler.createNumber(validNumberString);
        String validNumberStringWithDecimal = "123.456";
        Number expectedNumberWithDecimal = 123.456;
        Number actualNumberWithDecimal = TypeHandler.createNumber(validNumberStringWithDecimal);
        String validNumberStringWithNegativeValue = "-123";
        Number expectedNumberWithNegativeValue = -123;
        Number actualNumberWithNegativeValue = TypeHandler.createNumber(validNumberStringWithNegativeValue);
        String validNumberStringWithZeroValue = "0";
        Number expectedNumberWithZeroValue = 0;
        Number actualNumberWithZeroValue = TypeHandler.createNumber(validNumberStringWithZeroValue);
        String validNumberStringWithScientificNotation = "1.23e+2";
        Number expectedNumberWithScientificNotation = 123;
        Number actualNumberWithScientificNotation = TypeHandler.createNumber(validNumberStringWithScientificNotation);
        String validNumberStringWithHexadecimal = "0x123";
        Number expectedNumberWithHexadecimal = 0x123;
        Number actualNumberWithHexadecimal = TypeHandler.createNumber(validNumberStringWithHexadecimal);
        String validNumberStringWithBinary = "0b101010";
        Number expectedNumberWithBinary = 0b101010;
        Number actualNumberWithBinary = TypeHandler.createNumber(validNumberStringWithBinary);
        String validNumberStringWithOctal = "0123";
        Number expectedNumberWithOctal = 0123;
        Number actualNumberWithOctal = TypeHandler.createNumber(validNumberStringWithOctal);
        String validNumberStringWithLeadingZero = "0123";
        Number expectedNumberWithLeadingZero = 123;
        Number actualNumberWithLeadingZero = TypeHandler.createNumber(validNumberStringWithLeadingZero);
        String validNumberStringWithTrailingZero = "1230";
        Number expectedNumberWithTrailingZero = 123;
        Number actualNumberWithTrailingZero = TypeHandler.createNumber(validNumberStringWithTrailingZero);
        String validNumberStringWithLeadingDecimalPoint = ".123";
        Number expectedNumberWithLeadingDecimalPoint = 0.123;
        Number actualNumberWithLeadingDecimalPoint = TypeHandler.createNumber(validNumberStringWithLeadingDecimalPoint);
        assertEquals(expectedNumberWithOctal, actualNumberWithOctal);
    }

    @Test
    @Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testCreateNumber_SjNq0_9() throws ParseException {
        String validNumberString = "123";
        Number expectedNumber = 123;
        Number actualNumber = TypeHandler.createNumber(validNumberString);
        String validNumberStringWithDecimal = "123.456";
        Number expectedNumberWithDecimal = 123.456;
        Number actualNumberWithDecimal = TypeHandler.createNumber(validNumberStringWithDecimal);
        String validNumberStringWithNegativeValue = "-123";
        Number expectedNumberWithNegativeValue = -123;
        Number actualNumberWithNegativeValue = TypeHandler.createNumber(validNumberStringWithNegativeValue);
        String validNumberStringWithZeroValue = "0";
        Number expectedNumberWithZeroValue = 0;
        Number actualNumberWithZeroValue = TypeHandler.createNumber(validNumberStringWithZeroValue);
        String validNumberStringWithScientificNotation = "1.23e+2";
        Number expectedNumberWithScientificNotation = 123;
        Number actualNumberWithScientificNotation = TypeHandler.createNumber(validNumberStringWithScientificNotation);
        String validNumberStringWithHexadecimal = "0x123";
        Number expectedNumberWithHexadecimal = 0x123;
        Number actualNumberWithHexadecimal = TypeHandler.createNumber(validNumberStringWithHexadecimal);
        String validNumberStringWithBinary = "0b101010";
        Number expectedNumberWithBinary = 0b101010;
        Number actualNumberWithBinary = TypeHandler.createNumber(validNumberStringWithBinary);
        String validNumberStringWithOctal = "0123";
        Number expectedNumberWithOctal = 0123;
        Number actualNumberWithOctal = TypeHandler.createNumber(validNumberStringWithOctal);
        String validNumberStringWithLeadingZero = "0123";
        Number expectedNumberWithLeadingZero = 123;
        Number actualNumberWithLeadingZero = TypeHandler.createNumber(validNumberStringWithLeadingZero);
        String validNumberStringWithTrailingZero = "1230";
        Number expectedNumberWithTrailingZero = 123;
        Number actualNumberWithTrailingZero = TypeHandler.createNumber(validNumberStringWithTrailingZero);
        String validNumberStringWithLeadingDecimalPoint = ".123";
        Number expectedNumberWithLeadingDecimalPoint = 0.123;
        Number actualNumberWithLeadingDecimalPoint = TypeHandler.createNumber(validNumberStringWithLeadingDecimalPoint);
        assertEquals(expectedNumberWithLeadingZero, actualNumberWithLeadingZero);
    }

    @Test
    @Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testCreateNumber_SjNq0_10() throws ParseException {
        String validNumberString = "123";
        Number expectedNumber = 123;
        Number actualNumber = TypeHandler.createNumber(validNumberString);
        String validNumberStringWithDecimal = "123.456";
        Number expectedNumberWithDecimal = 123.456;
        Number actualNumberWithDecimal = TypeHandler.createNumber(validNumberStringWithDecimal);
        String validNumberStringWithNegativeValue = "-123";
        Number expectedNumberWithNegativeValue = -123;
        Number actualNumberWithNegativeValue = TypeHandler.createNumber(validNumberStringWithNegativeValue);
        String validNumberStringWithZeroValue = "0";
        Number expectedNumberWithZeroValue = 0;
        Number actualNumberWithZeroValue = TypeHandler.createNumber(validNumberStringWithZeroValue);
        String validNumberStringWithScientificNotation = "1.23e+2";
        Number expectedNumberWithScientificNotation = 123;
        Number actualNumberWithScientificNotation = TypeHandler.createNumber(validNumberStringWithScientificNotation);
        String validNumberStringWithHexadecimal = "0x123";
        Number expectedNumberWithHexadecimal = 0x123;
        Number actualNumberWithHexadecimal = TypeHandler.createNumber(validNumberStringWithHexadecimal);
        String validNumberStringWithBinary = "0b101010";
        Number expectedNumberWithBinary = 0b101010;
        Number actualNumberWithBinary = TypeHandler.createNumber(validNumberStringWithBinary);
        String validNumberStringWithOctal = "0123";
        Number expectedNumberWithOctal = 0123;
        Number actualNumberWithOctal = TypeHandler.createNumber(validNumberStringWithOctal);
        String validNumberStringWithLeadingZero = "0123";
        Number expectedNumberWithLeadingZero = 123;
        Number actualNumberWithLeadingZero = TypeHandler.createNumber(validNumberStringWithLeadingZero);
        String validNumberStringWithTrailingZero = "1230";
        Number expectedNumberWithTrailingZero = 123;
        Number actualNumberWithTrailingZero = TypeHandler.createNumber(validNumberStringWithTrailingZero);
        String validNumberStringWithLeadingDecimalPoint = ".123";
        Number expectedNumberWithLeadingDecimalPoint = 0.123;
        Number actualNumberWithLeadingDecimalPoint = TypeHandler.createNumber(validNumberStringWithLeadingDecimalPoint);
        assertEquals(expectedNumberWithTrailingZero, actualNumberWithTrailingZero);
    }

    @Test
    @Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testCreateNumber_SjNq0_11() throws ParseException {
        String validNumberString = "123";
        Number expectedNumber = 123;
        Number actualNumber = TypeHandler.createNumber(validNumberString);
        String validNumberStringWithDecimal = "123.456";
        Number expectedNumberWithDecimal = 123.456;
        Number actualNumberWithDecimal = TypeHandler.createNumber(validNumberStringWithDecimal);
        String validNumberStringWithNegativeValue = "-123";
        Number expectedNumberWithNegativeValue = -123;
        Number actualNumberWithNegativeValue = TypeHandler.createNumber(validNumberStringWithNegativeValue);
        String validNumberStringWithZeroValue = "0";
        Number expectedNumberWithZeroValue = 0;
        Number actualNumberWithZeroValue = TypeHandler.createNumber(validNumberStringWithZeroValue);
        String validNumberStringWithScientificNotation = "1.23e+2";
        Number expectedNumberWithScientificNotation = 123;
        Number actualNumberWithScientificNotation = TypeHandler.createNumber(validNumberStringWithScientificNotation);
        String validNumberStringWithHexadecimal = "0x123";
        Number expectedNumberWithHexadecimal = 0x123;
        Number actualNumberWithHexadecimal = TypeHandler.createNumber(validNumberStringWithHexadecimal);
        String validNumberStringWithBinary = "0b101010";
        Number expectedNumberWithBinary = 0b101010;
        Number actualNumberWithBinary = TypeHandler.createNumber(validNumberStringWithBinary);
        String validNumberStringWithOctal = "0123";
        Number expectedNumberWithOctal = 0123;
        Number actualNumberWithOctal = TypeHandler.createNumber(validNumberStringWithOctal);
        String validNumberStringWithLeadingZero = "0123";
        Number expectedNumberWithLeadingZero = 123;
        Number actualNumberWithLeadingZero = TypeHandler.createNumber(validNumberStringWithLeadingZero);
        String validNumberStringWithTrailingZero = "1230";
        Number expectedNumberWithTrailingZero = 123;
        Number actualNumberWithTrailingZero = TypeHandler.createNumber(validNumberStringWithTrailingZero);
        String validNumberStringWithLeadingDecimalPoint = ".123";
        Number expectedNumberWithLeadingDecimalPoint = 0.123;
        Number actualNumberWithLeadingDecimalPoint = TypeHandler.createNumber(validNumberStringWithLeadingDecimalPoint);
        assertEquals(expectedNumberWithLeadingDecimalPoint, actualNumberWithLeadingDecimalPoint);
    }

    @Test
    @Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testCreateDate_PavA0() throws ParseException {
        String dateString = "2022-01-01";
        Date expectedDate = new Date(2022, 0, 1);
        Date actualDate = TypeHandler.createDate(dateString);
        assertEquals(expectedDate, actualDate);
    }

    @Test
    @Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testCreateDateWithNullString_bboQ2() {
        String dateString = null;
        try {
            TypeHandler.createDate(dateString);
            fail("Expected NullPointerException");
        } catch (NullPointerException e) {
            assertNotNull(e);
        }
    }

    @Test
    @Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testCreateFiles_EmptyString_SdnL0() {
        String string = "";
        File[] files = TypeHandler.createFiles(string);
        assertEquals(0, files.length);
    }

    @Test
    @Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testCreateFiles_SingleFile_kVrI1_1() {
        String string = "file1.txt";
        File[] files = TypeHandler.createFiles(string);
        assertEquals(1, files.length);
    }

    @Test
    @Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testCreateFiles_SingleFile_kVrI1_2() {
        String string = "file1.txt";
        File[] files = TypeHandler.createFiles(string);
        assertEquals("file1.txt", files[0].getName());
    }

    @Test
    @Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testCreateFiles_MultipleFiles_AaOe2_1() {
        String string = "file1.txt,file2.txt,file3.txt";
        File[] files = TypeHandler.createFiles(string);
        assertEquals(3, files.length);
    }

    @Test
    @Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testCreateFiles_MultipleFiles_AaOe2_2() {
        String string = "file1.txt,file2.txt,file3.txt";
        File[] files = TypeHandler.createFiles(string);
        assertEquals("file2.txt", files[1].getName());
    }

    @Test
    @Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testCreateFiles_MultipleFiles_AaOe2_3() {
        String string = "file1.txt,file2.txt,file3.txt";
        File[] files = TypeHandler.createFiles(string);
        assertEquals("file3.txt", files[2].getName());
    }

    @Test
    @Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testCreateFiles_InvalidFile_xjud3_2() {
        String string = "file1.txt,file2.txt,file3.txt";
        File[] files = TypeHandler.createFiles(string);
        assertEquals("file1.txt", files[0].getName());
        assertEquals("file2.txt", files[1].getName());
        assertEquals("file3.txt", files[2].getName());
    }

    @Test
    @Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testCreateFiles_NullString_QcSo4() {
        String string = null;
        File[] files = TypeHandler.createFiles(string);
        assertNull(files);
    }

    @Test
    @Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testOpenFile_NullFilePath_ywzl2_DsLg0() {
        try {
            TypeHandler.openFile(null);
            fail("Expected NullPointerException to be thrown");
        } catch (NullPointerException e) {
            assertEquals("File path cannot be null", e.getMessage());
        } catch (ParseException e) {
            assertNull(e);
        }
    }

    @Test
    @Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testCreateValueWithInvalidString_LLxw3_fid1() {
        try {
            Object result = TypeHandler.createValue("hello", Integer.class);
            assertNull(result);
        } catch (ParseException e) {
            fail("Exception should not be thrown");
        }
    }

    @Test
    @Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testCreateValueWithNullClass_LyuE4_fid1() {
        try {
            Object result = TypeHandler.createValue("hello", null);
            assertNull(result);
        } catch (ParseException e) {
            fail("Exception should not be thrown");
        }
    }

    @Test
    @Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testCreateValueWithInvalidClass_vbvd5_fid1() {
        try {
            Object result = TypeHandler.createValue("hello", Object.class);
            assertNull(result);
        } catch (ParseException e) {
            fail("Exception should not be thrown");
        }
    }

    @Test
    @Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testCreateClassWithNullClassName_aQkb2_fid1() throws ParseException {
        String className = null;
        try {
            TypeHandler.createClass(className);
            fail("Expected NullPointerException");
        } catch (NullPointerException e) {
            assertEquals("Class name cannot be null", e.getMessage());
        }
    }

    @Test
    @Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testCreateClassWithEmptyClassName_GVfv3_fid1() throws ParseException {
        String className = "";
        try {
            TypeHandler.createClass(className);
            fail("Expected ParseException");
        } catch (ParseException e) {
            assertEquals("Class name cannot be empty", e.getMessage());
        }
    }

    @Test
    @Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testCreateClassWithWhitespaceClassName_Dlzv4_fid1() throws ParseException {
        String className = "   ";
        try {
            TypeHandler.createClass(className);
            fail("Expected ParseException");
        } catch (ParseException e) {
            assertEquals("Class name cannot be whitespace", e.getMessage());
        }
    }

    @Test
    @Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testCreateClassWithNonExistentClass_SdSd5_fid1() throws ParseException {
        String className = "com.example.NonExistentClass";
        try {
            TypeHandler.createClass(className);
            fail("Expected ParseException");
        } catch (ParseException e) {
            assertEquals("Class not found: " + className, e.getMessage());
        }
    }

    @Test
    @Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testCreateClassWithPrimitiveType_cEQQ6_fid1() throws ParseException {
        String className = "int";
        Class<?> expectedClass = int.class;
        Class<?> actualClass = TypeHandler.createClass(className);
        assertEquals(expectedClass, actualClass);
    }

    @Test
    @Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testCreateFile_wafR0_1_fid1() {
        String filePath = "C:\\temp\\test.txt";
        File file = TypeHandler.createFile(filePath);
        filePath = "C:\\temp\\test.txt";
        file = TypeHandler.createFile(filePath);
        filePath = null;
        file = TypeHandler.createFile(filePath);
        assertEquals(filePath, file.getPath());
    }

    @Test
    @Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testCreateFile_wafR0_2_fid1() {
        String filePath = "C:\\temp\\test.txt";
        File file = TypeHandler.createFile(filePath);
        filePath = "C:\\temp\\test.txt";
        file = TypeHandler.createFile(filePath);
        filePath = null;
        file = TypeHandler.createFile(filePath);
        assertEquals(File.class, file.getClass());
    }

    @Test
    @Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testCreateFile_wafR0_3_fid1() {
        String filePath = "C:\\temp\\test.txt";
        File file = TypeHandler.createFile(filePath);
        filePath = "C:\\temp\\test.txt";
        file = TypeHandler.createFile(filePath);
        filePath = null;
        file = TypeHandler.createFile(filePath);
        assertNull(file);
    }

    @Test
    @Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testCreateValue_String_Class_NullString_ungj1_fid1() throws ParseException {
        String string = null;
        Class<Integer> clazz = Integer.class;
        Integer expected = null;
        Integer actual = TypeHandler.createValue(string, clazz);
        assertEquals(expected, actual);
    }

    @Test
    @Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testCreateValue_String_Class_NullClass_YYcX2_fid1() throws ParseException {
        String string = "123";
        Class<Integer> clazz = null;
        Integer expected = null;
        Integer actual = TypeHandler.createValue(string, clazz);
        assertEquals(expected, actual);
    }

    @Test
    @Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testCreateValue_String_Class_InvalidString_wgyI3_fid1() throws ParseException {
        String string = "abc";
        Class<Integer> clazz = Integer.class;
        Integer expected = null;
        Integer actual = TypeHandler.createValue(string, clazz);
        assertEquals(expected, actual);
    }

    @Test
    @Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testCreateValue_String_Class_EmptyString_dfHQ6_fid1() throws ParseException {
        String string = "";
        Class<Integer> clazz = Integer.class;
        Integer expected = null;
        Integer actual = TypeHandler.createValue(string, clazz);
        assertEquals(expected, actual);
    }

    @Test
    @Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testGetDefaultReturnsNewInstance_EsJI1_fid1() {
        TypeHandler defaultHandler1 = TypeHandler.getDefault();
        TypeHandler defaultHandler2 = TypeHandler.getDefault();
        assertNotSame(defaultHandler1, defaultHandler2);
    }

    @Test
    @Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testCreateDefaultMap_kuVv0_2_fid1() {
        Map<Class<?>, Converter<?, ? extends Throwable>> map = TypeHandler.createDefaultMap();
        assertEquals(16, map.size());
    }

    @Test
    @Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testGetConverterWithCustomConverter_QFmG3_fid1() {
        TypeHandler typeHandler = new TypeHandler();
        Converter<String, ?> converter = typeHandler.getConverter(String.class);
        assertNotEquals(Converter.DEFAULT, converter);
    }

    @Test
    @Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testGetConverterWithNullClass_cEoP4_fid1() {
        TypeHandler typeHandler = new TypeHandler();
        Converter<String, ?> converter = typeHandler.getConverter(null);
        assertNull(converter);
    }

    @Test
    @Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testGetConverterWithEmptyConverterMap_vFKo6_fid1() {
        TypeHandler typeHandler = new TypeHandler();
        Converter<String, ?> converter = typeHandler.getConverter(String.class);
        assertNull(converter);
    }

    @Test
    @Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testGetConverterWithConverterMapContainingDifferentType_hwxf8_fid1() {
        TypeHandler typeHandler = new TypeHandler();
        Converter<Integer, ?> converter = typeHandler.getConverter(Integer.class);
        assertNull(converter);
    }

    @Test
    @Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testOpenFile_InvalidFilePath_ekwO1_fid1() {
        String filePath = "path/to/invalid_file.txt";
        try {
            TypeHandler.openFile(filePath);
            fail("Expected ParseException to be thrown");
        } catch (ParseException e) {
            assertEquals("Invalid file path: " + filePath, e.getMessage());
        }
    }

    @Test
    @Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testOpenFile_EmptyFilePath_NlSW3_fid1() {
        try {
            TypeHandler.openFile("");
            fail("Expected ParseException to be thrown");
        } catch (ParseException e) {
            assertEquals("File path cannot be empty", e.getMessage());
        }
    }

    @Test
    @Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testOpenFile_FileDoesNotExist_DTwS4_fid1() {
        String filePath = "path/to/non_existent_file.txt";
        try {
            TypeHandler.openFile(filePath);
            fail("Expected ParseException to be thrown");
        } catch (ParseException e) {
            assertEquals("File does not exist: " + filePath, e.getMessage());
        }
    }

    @Test
    @Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testOpenFile_FileIsDirectory_PqsC5_fid1() {
        String filePath = "path/to/directory";
        try {
            TypeHandler.openFile(filePath);
            fail("Expected ParseException to be thrown");
        } catch (ParseException e) {
            assertEquals("File is a directory: " + filePath, e.getMessage());
        }
    }

    @Test
    @Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testOpenFile_FileIsNotReadable_JRAR6_fid1() {
        String filePath = "path/to/unreadable_file.txt";
        try {
            TypeHandler.openFile(filePath);
            fail("Expected ParseException to be thrown");
        } catch (ParseException e) {
            assertEquals("File is not readable: " + filePath, e.getMessage());
        }
    }

    @Test
    @Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testOpenFile_FileIsNotWritable_FIDY7_fid1() {
        String filePath = "path/to/unwritable_file.txt";
        try {
            TypeHandler.openFile(filePath);
            fail("Expected ParseException to be thrown");
        } catch (ParseException e) {
            assertEquals("File is not writable: " + filePath, e.getMessage());
        }
    }

    @Test
    @Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testOpenFile_FileIsNotExecutable_HhJH8_fid1() {
        String filePath = "path/to/unexecutable_file.txt";
        try {
            TypeHandler.openFile(filePath);
            fail("Expected ParseException to be thrown");
        } catch (ParseException e) {
            assertEquals("File is not executable: " + filePath, e.getMessage());
        }
    }

    @Test
    @Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testOpenFile_FileIsNotAFile_jtbG9_fid1() {
        String filePath = "path/to/non_file.txt";
        try {
            TypeHandler.openFile(filePath);
            fail("Expected ParseException to be thrown");
        } catch (ParseException e) {
            assertEquals("File is not a file: " + filePath, e.getMessage());
        }
    }

    @Test
    @Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testCreateNumber_SjNq0_1_fid1() throws ParseException {
        String validNumberString = "123";
        Number expectedNumber = 123;
        Number actualNumber = TypeHandler.createNumber(validNumberString);
        String validNumberStringWithDecimal = "123.456";
        Number expectedNumberWithDecimal = 123.456;
        Number actualNumberWithDecimal = TypeHandler.createNumber(validNumberStringWithDecimal);
        String validNumberStringWithNegativeValue = "-123";
        Number expectedNumberWithNegativeValue = -123;
        Number actualNumberWithNegativeValue = TypeHandler.createNumber(validNumberStringWithNegativeValue);
        String validNumberStringWithZeroValue = "0";
        Number expectedNumberWithZeroValue = 0;
        Number actualNumberWithZeroValue = TypeHandler.createNumber(validNumberStringWithZeroValue);
        String validNumberStringWithScientificNotation = "1.23e+2";
        Number expectedNumberWithScientificNotation = 123;
        Number actualNumberWithScientificNotation = TypeHandler.createNumber(validNumberStringWithScientificNotation);
        String validNumberStringWithHexadecimal = "0x123";
        Number expectedNumberWithHexadecimal = 0x123;
        Number actualNumberWithHexadecimal = TypeHandler.createNumber(validNumberStringWithHexadecimal);
        String validNumberStringWithBinary = "0b101010";
        Number expectedNumberWithBinary = 0b101010;
        Number actualNumberWithBinary = TypeHandler.createNumber(validNumberStringWithBinary);
        String validNumberStringWithOctal = "0123";
        Number expectedNumberWithOctal = 0123;
        Number actualNumberWithOctal = TypeHandler.createNumber(validNumberStringWithOctal);
        String validNumberStringWithLeadingZero = "0123";
        Number expectedNumberWithLeadingZero = 123;
        Number actualNumberWithLeadingZero = TypeHandler.createNumber(validNumberStringWithLeadingZero);
        String validNumberStringWithTrailingZero = "1230";
        Number expectedNumberWithTrailingZero = 123;
        Number actualNumberWithTrailingZero = TypeHandler.createNumber(validNumberStringWithTrailingZero);
        String validNumberStringWithLeadingDecimalPoint = ".123";
        Number expectedNumberWithLeadingDecimalPoint = 0.123;
        Number actualNumberWithLeadingDecimalPoint = TypeHandler.createNumber(validNumberStringWithLeadingDecimalPoint);
        assertEquals(expectedNumber, actualNumber);
    }

    @Test
    @Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testCreateNumber_SjNq0_2_fid1() throws ParseException {
        String validNumberString = "123";
        Number expectedNumber = 123;
        Number actualNumber = TypeHandler.createNumber(validNumberString);
        String validNumberStringWithDecimal = "123.456";
        Number expectedNumberWithDecimal = 123.456;
        Number actualNumberWithDecimal = TypeHandler.createNumber(validNumberStringWithDecimal);
        String validNumberStringWithNegativeValue = "-123";
        Number expectedNumberWithNegativeValue = -123;
        Number actualNumberWithNegativeValue = TypeHandler.createNumber(validNumberStringWithNegativeValue);
        String validNumberStringWithZeroValue = "0";
        Number expectedNumberWithZeroValue = 0;
        Number actualNumberWithZeroValue = TypeHandler.createNumber(validNumberStringWithZeroValue);
        String validNumberStringWithScientificNotation = "1.23e+2";
        Number expectedNumberWithScientificNotation = 123;
        Number actualNumberWithScientificNotation = TypeHandler.createNumber(validNumberStringWithScientificNotation);
        String validNumberStringWithHexadecimal = "0x123";
        Number expectedNumberWithHexadecimal = 0x123;
        Number actualNumberWithHexadecimal = TypeHandler.createNumber(validNumberStringWithHexadecimal);
        String validNumberStringWithBinary = "0b101010";
        Number expectedNumberWithBinary = 0b101010;
        Number actualNumberWithBinary = TypeHandler.createNumber(validNumberStringWithBinary);
        String validNumberStringWithOctal = "0123";
        Number expectedNumberWithOctal = 0123;
        Number actualNumberWithOctal = TypeHandler.createNumber(validNumberStringWithOctal);
        String validNumberStringWithLeadingZero = "0123";
        Number expectedNumberWithLeadingZero = 123;
        Number actualNumberWithLeadingZero = TypeHandler.createNumber(validNumberStringWithLeadingZero);
        String validNumberStringWithTrailingZero = "1230";
        Number expectedNumberWithTrailingZero = 123;
        Number actualNumberWithTrailingZero = TypeHandler.createNumber(validNumberStringWithTrailingZero);
        String validNumberStringWithLeadingDecimalPoint = ".123";
        Number expectedNumberWithLeadingDecimalPoint = 0.123;
        Number actualNumberWithLeadingDecimalPoint = TypeHandler.createNumber(validNumberStringWithLeadingDecimalPoint);
        assertEquals(expectedNumberWithDecimal, actualNumberWithDecimal);
    }

    @Test
    @Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testCreateNumber_SjNq0_3_fid1() throws ParseException {
        String validNumberString = "123";
        Number expectedNumber = 123;
        Number actualNumber = TypeHandler.createNumber(validNumberString);
        String validNumberStringWithDecimal = "123.456";
        Number expectedNumberWithDecimal = 123.456;
        Number actualNumberWithDecimal = TypeHandler.createNumber(validNumberStringWithDecimal);
        String validNumberStringWithNegativeValue = "-123";
        Number expectedNumberWithNegativeValue = -123;
        Number actualNumberWithNegativeValue = TypeHandler.createNumber(validNumberStringWithNegativeValue);
        String validNumberStringWithZeroValue = "0";
        Number expectedNumberWithZeroValue = 0;
        Number actualNumberWithZeroValue = TypeHandler.createNumber(validNumberStringWithZeroValue);
        String validNumberStringWithScientificNotation = "1.23e+2";
        Number expectedNumberWithScientificNotation = 123;
        Number actualNumberWithScientificNotation = TypeHandler.createNumber(validNumberStringWithScientificNotation);
        String validNumberStringWithHexadecimal = "0x123";
        Number expectedNumberWithHexadecimal = 0x123;
        Number actualNumberWithHexadecimal = TypeHandler.createNumber(validNumberStringWithHexadecimal);
        String validNumberStringWithBinary = "0b101010";
        Number expectedNumberWithBinary = 0b101010;
        Number actualNumberWithBinary = TypeHandler.createNumber(validNumberStringWithBinary);
        String validNumberStringWithOctal = "0123";
        Number expectedNumberWithOctal = 0123;
        Number actualNumberWithOctal = TypeHandler.createNumber(validNumberStringWithOctal);
        String validNumberStringWithLeadingZero = "0123";
        Number expectedNumberWithLeadingZero = 123;
        Number actualNumberWithLeadingZero = TypeHandler.createNumber(validNumberStringWithLeadingZero);
        String validNumberStringWithTrailingZero = "1230";
        Number expectedNumberWithTrailingZero = 123;
        Number actualNumberWithTrailingZero = TypeHandler.createNumber(validNumberStringWithTrailingZero);
        String validNumberStringWithLeadingDecimalPoint = ".123";
        Number expectedNumberWithLeadingDecimalPoint = 0.123;
        Number actualNumberWithLeadingDecimalPoint = TypeHandler.createNumber(validNumberStringWithLeadingDecimalPoint);
        assertEquals(expectedNumberWithNegativeValue, actualNumberWithNegativeValue);
    }

    @Test
    @Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testCreateNumber_SjNq0_4_fid1() throws ParseException {
        String validNumberString = "123";
        Number expectedNumber = 123;
        Number actualNumber = TypeHandler.createNumber(validNumberString);
        String validNumberStringWithDecimal = "123.456";
        Number expectedNumberWithDecimal = 123.456;
        Number actualNumberWithDecimal = TypeHandler.createNumber(validNumberStringWithDecimal);
        String validNumberStringWithNegativeValue = "-123";
        Number expectedNumberWithNegativeValue = -123;
        Number actualNumberWithNegativeValue = TypeHandler.createNumber(validNumberStringWithNegativeValue);
        String validNumberStringWithZeroValue = "0";
        Number expectedNumberWithZeroValue = 0;
        Number actualNumberWithZeroValue = TypeHandler.createNumber(validNumberStringWithZeroValue);
        String validNumberStringWithScientificNotation = "1.23e+2";
        Number expectedNumberWithScientificNotation = 123;
        Number actualNumberWithScientificNotation = TypeHandler.createNumber(validNumberStringWithScientificNotation);
        String validNumberStringWithHexadecimal = "0x123";
        Number expectedNumberWithHexadecimal = 0x123;
        Number actualNumberWithHexadecimal = TypeHandler.createNumber(validNumberStringWithHexadecimal);
        String validNumberStringWithBinary = "0b101010";
        Number expectedNumberWithBinary = 0b101010;
        Number actualNumberWithBinary = TypeHandler.createNumber(validNumberStringWithBinary);
        String validNumberStringWithOctal = "0123";
        Number expectedNumberWithOctal = 0123;
        Number actualNumberWithOctal = TypeHandler.createNumber(validNumberStringWithOctal);
        String validNumberStringWithLeadingZero = "0123";
        Number expectedNumberWithLeadingZero = 123;
        Number actualNumberWithLeadingZero = TypeHandler.createNumber(validNumberStringWithLeadingZero);
        String validNumberStringWithTrailingZero = "1230";
        Number expectedNumberWithTrailingZero = 123;
        Number actualNumberWithTrailingZero = TypeHandler.createNumber(validNumberStringWithTrailingZero);
        String validNumberStringWithLeadingDecimalPoint = ".123";
        Number expectedNumberWithLeadingDecimalPoint = 0.123;
        Number actualNumberWithLeadingDecimalPoint = TypeHandler.createNumber(validNumberStringWithLeadingDecimalPoint);
        assertEquals(expectedNumberWithZeroValue, actualNumberWithZeroValue);
    }

    @Test
    @Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testCreateNumber_SjNq0_5_fid1() throws ParseException {
        String validNumberString = "123";
        Number expectedNumber = 123;
        Number actualNumber = TypeHandler.createNumber(validNumberString);
        String validNumberStringWithDecimal = "123.456";
        Number expectedNumberWithDecimal = 123.456;
        Number actualNumberWithDecimal = TypeHandler.createNumber(validNumberStringWithDecimal);
        String validNumberStringWithNegativeValue = "-123";
        Number expectedNumberWithNegativeValue = -123;
        Number actualNumberWithNegativeValue = TypeHandler.createNumber(validNumberStringWithNegativeValue);
        String validNumberStringWithZeroValue = "0";
        Number expectedNumberWithZeroValue = 0;
        Number actualNumberWithZeroValue = TypeHandler.createNumber(validNumberStringWithZeroValue);
        String validNumberStringWithScientificNotation = "1.23e+2";
        Number expectedNumberWithScientificNotation = 123;
        Number actualNumberWithScientificNotation = TypeHandler.createNumber(validNumberStringWithScientificNotation);
        String validNumberStringWithHexadecimal = "0x123";
        Number expectedNumberWithHexadecimal = 0x123;
        Number actualNumberWithHexadecimal = TypeHandler.createNumber(validNumberStringWithHexadecimal);
        String validNumberStringWithBinary = "0b101010";
        Number expectedNumberWithBinary = 0b101010;
        Number actualNumberWithBinary = TypeHandler.createNumber(validNumberStringWithBinary);
        String validNumberStringWithOctal = "0123";
        Number expectedNumberWithOctal = 0123;
        Number actualNumberWithOctal = TypeHandler.createNumber(validNumberStringWithOctal);
        String validNumberStringWithLeadingZero = "0123";
        Number expectedNumberWithLeadingZero = 123;
        Number actualNumberWithLeadingZero = TypeHandler.createNumber(validNumberStringWithLeadingZero);
        String validNumberStringWithTrailingZero = "1230";
        Number expectedNumberWithTrailingZero = 123;
        Number actualNumberWithTrailingZero = TypeHandler.createNumber(validNumberStringWithTrailingZero);
        String validNumberStringWithLeadingDecimalPoint = ".123";
        Number expectedNumberWithLeadingDecimalPoint = 0.123;
        Number actualNumberWithLeadingDecimalPoint = TypeHandler.createNumber(validNumberStringWithLeadingDecimalPoint);
        assertEquals(expectedNumberWithScientificNotation, actualNumberWithScientificNotation);
    }

    @Test
    @Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testCreateNumber_SjNq0_7_fid1() throws ParseException {
        String validNumberString = "123";
        Number expectedNumber = 123;
        Number actualNumber = TypeHandler.createNumber(validNumberString);
        String validNumberStringWithDecimal = "123.456";
        Number expectedNumberWithDecimal = 123.456;
        Number actualNumberWithDecimal = TypeHandler.createNumber(validNumberStringWithDecimal);
        String validNumberStringWithNegativeValue = "-123";
        Number expectedNumberWithNegativeValue = -123;
        Number actualNumberWithNegativeValue = TypeHandler.createNumber(validNumberStringWithNegativeValue);
        String validNumberStringWithZeroValue = "0";
        Number expectedNumberWithZeroValue = 0;
        Number actualNumberWithZeroValue = TypeHandler.createNumber(validNumberStringWithZeroValue);
        String validNumberStringWithScientificNotation = "1.23e+2";
        Number expectedNumberWithScientificNotation = 123;
        Number actualNumberWithScientificNotation = TypeHandler.createNumber(validNumberStringWithScientificNotation);
        String validNumberStringWithHexadecimal = "0x123";
        Number expectedNumberWithHexadecimal = 0x123;
        Number actualNumberWithHexadecimal = TypeHandler.createNumber(validNumberStringWithHexadecimal);
        String validNumberStringWithBinary = "0b101010";
        Number expectedNumberWithBinary = 0b101010;
        Number actualNumberWithBinary = TypeHandler.createNumber(validNumberStringWithBinary);
        String validNumberStringWithOctal = "0123";
        Number expectedNumberWithOctal = 0123;
        Number actualNumberWithOctal = TypeHandler.createNumber(validNumberStringWithOctal);
        String validNumberStringWithLeadingZero = "0123";
        Number expectedNumberWithLeadingZero = 123;
        Number actualNumberWithLeadingZero = TypeHandler.createNumber(validNumberStringWithLeadingZero);
        String validNumberStringWithTrailingZero = "1230";
        Number expectedNumberWithTrailingZero = 123;
        Number actualNumberWithTrailingZero = TypeHandler.createNumber(validNumberStringWithTrailingZero);
        String validNumberStringWithLeadingDecimalPoint = ".123";
        Number expectedNumberWithLeadingDecimalPoint = 0.123;
        Number actualNumberWithLeadingDecimalPoint = TypeHandler.createNumber(validNumberStringWithLeadingDecimalPoint);
        assertEquals(expectedNumberWithBinary, actualNumberWithBinary);
    }

    @Test
    @Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testCreateFiles_MultipleFiles_AaOe2_2_fid1() {
        String string = "file1.txt,file2.txt,file3.txt";
        File[] files = TypeHandler.createFiles(string);
        assertEquals("file1.txt", files[0].getName());
    }

    @Test
    @Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testCreateFiles_NullString_QcSo4_fid1() {
        String string = null;
        File[] files = TypeHandler.createFiles(string);
        assertEquals(0, files.length);
    }

    @Test
    @Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testCreateURLWithInvalidString_AzmQ1_fid1() {
        String invalidUrl = "invalid_url";
        try {
            TypeHandler.createURL(invalidUrl);
            fail("Expected ParseException to be thrown");
        } catch (ParseException e) {
            assertEquals("Invalid URL: " + invalidUrl, e.getMessage());
        }
    }

    @Test
    @Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testCreateObjectWithEmptyClassName_dkEB3_fid1() throws ParseException {
        String className = "";
        try {
            TypeHandler.createObject(className);
            fail("Expected ParseException");
        } catch (ParseException e) {
            assertEquals("Class name cannot be empty", e.getMessage());
        }
    }

    @Test
    @Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testCreateObjectWithWhitespaceClassName_cANf4_fid1() throws ParseException {
        String className = "   ";
        try {
            TypeHandler.createObject(className);
            fail("Expected ParseException");
        } catch (ParseException e) {
            assertEquals("Class name cannot be whitespace", e.getMessage());
        }
    }

    @Test
    @Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testCreateObjectWithNonExistentClass_FMNs5_fid1() throws ParseException {
        String className = "com.example.NonExistentClass";
        try {
            TypeHandler.createObject(className);
            fail("Expected ParseException");
        } catch (ParseException e) {
            assertEquals("Class not found: com.example.NonExistentClass", e.getMessage());
        }
    }

    @Test
    @Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testCreateObjectWithInterface_PeLA6_fid1() throws ParseException {
        String className = "java.lang.Runnable";
        try {
            TypeHandler.createObject(className);
            fail("Expected ParseException");
        } catch (ParseException e) {
            assertEquals("Cannot create instance of interface: java.lang.Runnable", e.getMessage());
        }
    }

    @Test
    @Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testCreateObjectWithAbstractClass_YVzb7_fid1() throws ParseException {
        String className = "java.lang.AbstractList";
        try {
            TypeHandler.createObject(className);
            fail("Expected ParseException");
        } catch (ParseException e) {
            assertEquals("Cannot create instance of abstract class: java.lang.AbstractList", e.getMessage());
        }
    }

    @Test
    @Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testCreateObjectWithArrayClass_TPwu8_fid1() throws ParseException {
        String className = "java.lang.String[]";
        try {
            TypeHandler.createObject(className);
            fail("Expected ParseException");
        } catch (ParseException e) {
            assertEquals("Cannot create instance of array class: java.lang.String[]", e.getMessage());
        }
    }

    @Test
    @Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testCreateObjectWithPrimitiveClass_yQIg9_fid1() throws ParseException {
        String className = "int";
        try {
            TypeHandler.createObject(className);
            fail("Expected ParseException");
        } catch (ParseException e) {
            assertEquals("Cannot create instance of primitive class: int", e.getMessage());
        }
    }

    @Test
    @Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testCreateValue_String_Class_InvalidClass_hThm4_WKcN0_fid1() throws ParseException {
        String string = "123";
        Class<String> clazz = String.class;
        String expected = null;
        Object actual = TypeHandler.createValue(string, clazz);
        assertEquals(expected, actual);
    }

    @Test
    @Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testGetConverterWithInvalidClass_Tgze1_oMvk0_fid1() {
        TypeHandler typeHandler = new TypeHandler();
        Converter<?, ?> converter = typeHandler.getConverter(Integer.class);
        assertNull(converter);
    }

    @Test
    @Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testCreateFiles_EmptyStringArray_TTtt5_MEVS1() {
        String[] strings = new String[0];
        File[] files = TypeHandler.createFiles("");
        assertEquals(0, files.length);
    }

    @Test
    @Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testOpenFile_NullFilePath_ywzl2_DsLg0_fid1() {
        try {
            TypeHandler.openFile(null);
            fail("Expected NullPointerException to be thrown");
        } catch (NullPointerException e) {
            assertEquals("File path cannot be null", e.getMessage());
        } catch (ParseException e) {
            fail("Unexpected ParseException thrown");
        }
    }

    @Test
    @Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testCreateFile_wafR0() {
        String filePath = "C:\\temp\\test.txt";
        File file = TypeHandler.createFile(filePath);
        assertEquals(filePath, file.getPath());
        assertEquals(File.class, file.getClass());
        filePath = "C:\\temp\\test.txt";
        file = TypeHandler.createFile(filePath);
        assertNull(file);
        filePath = null;
        file = TypeHandler.createFile(filePath);
        assertNull(file);
    }

    @Test
    @Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testCreateDefaultMap_kuVv0() {
        Map<Class<?>, Converter<?, ? extends Throwable>> map = TypeHandler.createDefaultMap();
        assertNotNull(map);
        assertEquals(16, map.size());
        assertTrue(map.containsKey(Object.class));
        assertTrue(map.containsKey(Class.class));
        assertTrue(map.containsKey(Date.class));
        assertTrue(map.containsKey(File.class));
        assertTrue(map.containsKey(Path.class));
        assertTrue(map.containsKey(Number.class));
        assertTrue(map.containsKey(URL.class));
        assertTrue(map.containsKey(FileInputStream.class));
        assertTrue(map.containsKey(Long.class));
        assertTrue(map.containsKey(Integer.class));
        assertTrue(map.containsKey(Short.class));
        assertTrue(map.containsKey(Byte.class));
        assertTrue(map.containsKey(Character.class));
        assertTrue(map.containsKey(Double.class));
        assertTrue(map.containsKey(Float.class));
        assertTrue(map.containsKey(BigInteger.class));
        assertTrue(map.containsKey(BigDecimal.class));
    }

    @Test
    @Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testCreateNumber_SjNq0() throws ParseException {
        String validNumberString = "123";
        Number expectedNumber = 123;
        Number actualNumber = TypeHandler.createNumber(validNumberString);
        assertEquals(expectedNumber, actualNumber);
        String validNumberStringWithDecimal = "123.456";
        Number expectedNumberWithDecimal = 123.456;
        Number actualNumberWithDecimal = TypeHandler.createNumber(validNumberStringWithDecimal);
        assertEquals(expectedNumberWithDecimal, actualNumberWithDecimal);
        String validNumberStringWithNegativeValue = "-123";
        Number expectedNumberWithNegativeValue = -123;
        Number actualNumberWithNegativeValue = TypeHandler.createNumber(validNumberStringWithNegativeValue);
        assertEquals(expectedNumberWithNegativeValue, actualNumberWithNegativeValue);
        String validNumberStringWithZeroValue = "0";
        Number expectedNumberWithZeroValue = 0;
        Number actualNumberWithZeroValue = TypeHandler.createNumber(validNumberStringWithZeroValue);
        assertEquals(expectedNumberWithZeroValue, actualNumberWithZeroValue);
        String validNumberStringWithScientificNotation = "1.23e+2";
        Number expectedNumberWithScientificNotation = 123;
        Number actualNumberWithScientificNotation = TypeHandler.createNumber(validNumberStringWithScientificNotation);
        assertEquals(expectedNumberWithScientificNotation, actualNumberWithScientificNotation);
        String validNumberStringWithHexadecimal = "0x123";
        Number expectedNumberWithHexadecimal = 0x123;
        Number actualNumberWithHexadecimal = TypeHandler.createNumber(validNumberStringWithHexadecimal);
        assertEquals(expectedNumberWithHexadecimal, actualNumberWithHexadecimal);
        String validNumberStringWithBinary = "0b101010";
        Number expectedNumberWithBinary = 0b101010;
        Number actualNumberWithBinary = TypeHandler.createNumber(validNumberStringWithBinary);
        assertEquals(expectedNumberWithBinary, actualNumberWithBinary);
        String validNumberStringWithOctal = "0123";
        Number expectedNumberWithOctal = 0123;
        Number actualNumberWithOctal = TypeHandler.createNumber(validNumberStringWithOctal);
        assertEquals(expectedNumberWithOctal, actualNumberWithOctal);
        String validNumberStringWithLeadingZero = "0123";
        Number expectedNumberWithLeadingZero = 123;
        Number actualNumberWithLeadingZero = TypeHandler.createNumber(validNumberStringWithLeadingZero);
        assertEquals(expectedNumberWithLeadingZero, actualNumberWithLeadingZero);
        String validNumberStringWithTrailingZero = "1230";
        Number expectedNumberWithTrailingZero = 123;
        Number actualNumberWithTrailingZero = TypeHandler.createNumber(validNumberStringWithTrailingZero);
        assertEquals(expectedNumberWithTrailingZero, actualNumberWithTrailingZero);
        String validNumberStringWithLeadingDecimalPoint = ".123";
        Number expectedNumberWithLeadingDecimalPoint = 0.123;
        Number actualNumberWithLeadingDecimalPoint = TypeHandler.createNumber(validNumberStringWithLeadingDecimalPoint);
        assertEquals(expectedNumberWithLeadingDecimalPoint, actualNumberWithLeadingDecimalPoint);
    }

    @Test
    @Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testCreateFiles_SingleFile_kVrI1() {
        String string = "file1.txt";
        File[] files = TypeHandler.createFiles(string);
        assertEquals(1, files.length);
        assertEquals("file1.txt", files[0].getName());
    }

    @Test
    @Timeout(value = 1, unit = TimeUnit.SECONDS, threadMode = SEPARATE_THREAD)
    public void testCreateFiles_MultipleFiles_AaOe2() {
        String string = "file1.txt,file2.txt,file3.txt";
        File[] files = TypeHandler.createFiles(string);
        assertEquals(3, files.length);
        assertEquals("file1.txt", files[0].getName());
        assertEquals("file2.txt", files[1].getName());
        assertEquals("file3.txt", files[2].getName());
    }
}