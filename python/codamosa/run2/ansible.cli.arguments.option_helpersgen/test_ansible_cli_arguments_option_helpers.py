# Automatically generated by Pynguin.
import ansible.cli.arguments.option_helpers as module_0
import argparse as module_1

def test_case_0():
    pass

def test_case_1():
    var_0 = module_0.version()
    list_0 = [var_0]
    float_0 = 2215.678
    str_0 = '7zza4r@,?fbc2f'
    ansible_version_0 = module_0.AnsibleVersion(list_0, float_0, str_0)
    var_1 = module_0.unfrack_path()

def test_case_2():
    argument_parser_0 = module_1.ArgumentParser()
    var_0 = module_0.add_runtask_options(argument_parser_0)
    var_1 = argument_parser_0.parse_args()
    str_0 = 'Expected "%s" but got "%s"'
    str_1 = 'test1'
    str_2 = 'test2=test2'
    str_3 = 'test3=test3'
    str_4 = [str_3, str_1, str_2, str_3, str_3]
    var_2 = var_1.extra_vars
    var_3 = (str_4, var_2)
    var_4 = str_0 % var_3
    var_5 = AssertionError(var_4)

def test_case_3():
    var_0 = module_0.version()

def test_case_4():
    str_0 = 'test'
    var_0 = module_0.create_base_parser(str_0)
    var_1 = module_0.add_check_options(var_0)

def test_case_5():
    str_0 = 'ansible-playbook'
    var_0 = module_0.create_base_parser(str_0)
    var_1 = module_0.add_async_options(var_0)

def test_case_6():
    argument_parser_0 = module_1.ArgumentParser()
    var_0 = module_0.add_meta_options(argument_parser_0)

def test_case_7():
    argument_parser_0 = module_1.ArgumentParser()
    var_0 = module_0.add_tasknoplay_options(argument_parser_0)
    str_0 = 'Unit test for function add_tasknoplay_options completed successfully'
    var_1 = print(str_0)

def test_case_8():
    str_0 = 'ansible'
    var_0 = module_0.create_base_parser(str_0)
    var_1 = module_0.add_subset_options(var_0)

def test_case_9():
    argument_parser_0 = module_1.ArgumentParser()
    var_0 = module_0.add_check_options(argument_parser_0)

def test_case_10():
    str_0 = 'ansible-playbook'
    bool_0 = False
    str_1 = '-)T!uUk<:pW"Z?'
    float_0 = -483.92
    tuple_0 = (float_0,)
    dict_0 = {str_1: tuple_0, str_1: str_1, str_1: tuple_0}
    argument_parser_0 = module_1.ArgumentParser(bool_0, str_1, tuple_0, dict_0)
    var_0 = module_0.add_basedir_options(argument_parser_0)
    var_1 = module_0.create_base_parser(str_0)
    var_2 = module_0.add_async_options(var_1)

def test_case_11():
    var_0 = module_0.version()
    list_0 = []
    str_0 = 'QRH+)k/"Ub'
    float_0 = 2215.678
    ansible_version_0 = module_0.AnsibleVersion(list_0, float_0, str_0)
    prepend_list_action_0 = module_0.PrependListAction(list_0, str_0, ansible_version_0)
    float_1 = 307.0
    unrecognized_argument_0 = module_0.UnrecognizedArgument(float_1, prepend_list_action_0)
    list_1 = [float_0]
    namespace_0 = module_1.Namespace()
    var_1 = prepend_list_action_0.__call__(list_1, namespace_0, list_1)

def test_case_12():
    str_0 = 'test_args'
    str_1 = ''
    var_0 = None
    var_1 = module_0.create_base_parser(str_0, str_1, var_0, var_0)
    var_2 = module_0.add_output_options(var_1)

def test_case_13():
    str_0 = 'test_parser'
    var_0 = module_0.create_base_parser(str_0)
    var_1 = module_0.add_connect_options(var_0)

def test_case_14():
    str_0 = 'prog'
    var_0 = module_0.create_base_parser(str_0)
    var_1 = module_0.add_inventory_options(var_0)

def test_case_15():
    bytes_0 = b'\x04'
    list_0 = [bytes_0, bytes_0]
    str_0 = None
    str_1 = 'N'
    str_2 = '=Tmgh2?|X2$W0[y.C'
    dict_0 = {str_0: list_0, str_1: bytes_0, str_1: str_1, str_2: str_0}
    prepend_list_action_0 = None
    bool_0 = True
    argument_parser_0 = module_1.ArgumentParser(list_0, dict_0, prepend_list_action_0, bool_0)
    int_0 = 820
    str_3 = 'i&AJI:IBB'
    set_0 = {int_0, int_0}
    int_1 = -2658
    prepend_list_action_1 = module_0.PrependListAction(str_3, set_0, int_1)
    tuple_0 = ()
    ansible_version_0 = module_0.AnsibleVersion(int_0, prepend_list_action_1, tuple_0)
    var_0 = ansible_version_0.__call__(argument_parser_0, list_0, prepend_list_action_0)
    unrecognized_argument_0 = None
    bool_1 = True
    list_1 = [unrecognized_argument_0, bool_1]
    prepend_list_action_2 = module_0.PrependListAction(unrecognized_argument_0, bool_1, list_1)
    str_4 = '\n---\nmodule: cron\nshort_description: Manage cron.d and crontab entries\ndescription:\n  - Use this module to manage crontab and environment variables entries. This module allows\n    you to create environment variables and named crontab entries, update, or delete them.\n  - \'When crontab jobs are managed: the module includes one line with the description of the\n    crontab entry C("#Ansible: <name>") corresponding to the "name" passed to the module,\n    which is used by future ansible/module calls to find/check the state. The "name"\n    parameter should be unique, and changing the "name" value will result in a new cron\n    task being created (or a different one being removed).\'\n  - When environment variables are managed, no comment line is added, but, when the module\n    needs to find/check the state, it uses the "name" parameter to find the environment\n    variable definition line.\n  - When using symbols such as %, they must be properly escaped.\nversion_added: "0.9"\noptions:\n  name:\n    description:\n      - Description of a crontab entry or, if env is set, the name of environment variable.\n      - This parameter is always required as of ansible-core 2.12.\n    type: str\n    required: yes\n  user:\n    description:\n      - The specific user whose crontab should be modified.\n      - When unset, this parameter defaults to the current user.\n    type: str\n  job:\n    description:\n      - The command to execute or, if env is set, the value of environment variable.\n      - The command should not contain line breaks.\n      - Required if I(state=present).\n    type: str\n    aliases: [ value ]\n  state:\n    description:\n      - Whether to ensure the job or environment variable is present or absent.\n    type: str\n    choices: [ absent, present ]\n    default: present\n  cron_file:\n    description:\n      - If specified, uses this file instead of an individual user\'s crontab.\n        The assumption is that this file is exclusively managed by the module,\n        do not use if the file contains multiple entries, NEVER use for /etc/crontab.\n      - If this is a relative path, it is interpreted with respect to I(/etc/cron.d).\n      - Many linux distros expect (and some require) the filename portion to consist solely\n        of upper- and lower-case letters, digits, underscores, and hyphens.\n      - Using this parameter requires you to specify the I(user) as well, unless I(state) is not I(present).\n      - Either this parameter or I(name) is required\n    type: path\n  backup:\n    description:\n      - If set, create a backup of the crontab before it is modified.\n        The location of the backup is returned in the C(backup_file) variable by this module.\n    type: bool\n    default: no\n  minute:\n    description:\n      - Minute when the job should run (C(0-59), C(*), C(*/2), and so on).\n    type: str\n    default: "*"\n  hour:\n    description:\n      - Hour when the job should run (C(0-23), C(*), C(*/2), and so on).\n    type: str\n    default: "*"\n  day:\n    description:\n      - Day of the month the job should run (C(1-31), C(*), C(*/2), and so on).\n    type: str\n    default: "*"\n    aliases: [ dom ]\n  month:\n    description:\n      - Month of the year the job should run (C(1-12), C(*), C(*/2), and so on).\n    type: str\n    default: "*"\n  weekday:\n    description:\n      - Day of the week that the job should run (C(0-6) for Sunday-Saturday, C(*), and so on).\n    type: str\n    default: "*"\n    aliases: [ dow ]\n  special_time:\n    description:\n      - Special time specification nickname.\n    type: str\n    choices: [ annually, daily, hourly, monthly, reboot, weekly, yearly ]\n    version_added: "1.3"\n  disabled:\n    description:\n      - If the job should be disabled (commented out) in the crontab.\n      - Only has effect if I(state=present).\n    type: bool\n    default: no\n    version_added: "2.0"\n  env:\n    description:\n      - If set, manages a crontab\'s environment variable.\n      - New variables are added on top of crontab.\n      - I(name) and I(value) parameters are the name and the value of environment variable.\n    type: bool\n    default: false\n    version_added: "2.1"\n  insertafter:\n    description:\n      - Used with I(state=present) and I(env).\n      - If specified, the environment variable will be inserted after the declaration of specified environment variable.\n    type: str\n    version_added: "2.1"\n  insertbefore:\n    description:\n      - Used with I(state=present) and I(env).\n      - If specified, the environment variable will be inserted before the declaration of specified environment variable.\n    type: str\n    version_added: "2.1"\nrequirements:\n  - cron (any \'vixie cron\' conformant variant, like cronie)\nauthor:\n  - Dane Summers (@dsummersl)\n  - Mike Grozak (@rhaido)\n  - Patrick Callahan (@dirtyharrycallahan)\n  - Evan Kaufman (@EvanK)\n  - Luca Berruti (@lberruti)\nextends_documentation_fragment:\n    - action_common_attributes\nattributes:\n    check_mode:\n        support: full\n    diff_mode:\n        support: full\n    platform:\n        support: full\n        platforms: posix\n'
    dict_1 = {str_4: bytes_0, str_4: bytes_0}
    ansible_version_1 = module_0.AnsibleVersion(bytes_0, prepend_list_action_2, dict_1)
    var_1 = module_0.version()
    ansible_version_2 = None
    sorting_help_formatter_0 = module_0.SortingHelpFormatter(ansible_version_2)
    bytes_1 = b'\xff\x18R\xb8\xa0\x94\xb8\xcf\xed\x1f\xa1\xdf\x82Q\xf4\xb4'
    list_2 = [sorting_help_formatter_0]
    var_2 = module_0.add_runas_options(list_2)
    str_5 = '#gdaIR'
    list_3 = [bytes_1]
    bool_2 = True
    ansible_version_3 = module_0.AnsibleVersion(sorting_help_formatter_0, bytes_1, str_5, list_3, bool_2)
    str_6 = None
    var_3 = module_0.add_meta_options(str_6)
    var_4 = module_0.add_subset_options(list_3)

def test_case_16():
    var_0 = module_0.version()
    list_0 = [var_0]
    bytes_0 = b'*\x1f\xbb\xc7\x96\xd8\xba\x97\x06\xd0'
    var_1 = module_0.create_base_parser(bytes_0)
    str_0 = 'QRH+)k/"Ub'
    float_0 = 2215.678
    str_1 = 'jhQ Mcn0,zOI/G]Cb,'
    ansible_version_0 = module_0.AnsibleVersion(list_0, float_0, str_1)
    prepend_list_action_0 = module_0.PrependListAction(list_0, str_0, ansible_version_0)
    int_0 = 3911
    tuple_0 = ()
    namespace_0 = module_1.Namespace()
    dict_0 = {prepend_list_action_0: namespace_0, ansible_version_0: str_1}
    var_2 = prepend_list_action_0.__call__(tuple_0, namespace_0, dict_0)
    str_2 = '~%'
    tuple_1 = ()
    bool_0 = False
    dict_1 = {str_0: int_0}
    argument_parser_0 = module_1.ArgumentParser(tuple_1, bool_0, list_0, dict_1)
    unrecognized_argument_0 = module_0.UnrecognizedArgument(str_2, ansible_version_0, int_0, tuple_1, argument_parser_0)
    float_1 = 737.1364293923634
    str_3 = '$b_.+xdu'
    str_4 = 'B!)066zvD?\\7q\\<0%'
    argument_parser_1 = module_1.ArgumentParser(float_1, str_3, prepend_list_action_0, str_4)
    int_1 = 3911
    bytes_1 = b'O\x08t\xe5\xf3\xa3\x9f\x94.l\xa3'
    action_0 = module_1.Action(bytes_1, dict_0, int_1, dict_0)
    var_3 = prepend_list_action_0.__call__(prepend_list_action_0, namespace_0, tuple_1)