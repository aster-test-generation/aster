# Automatically generated by Pynguin.
import pymonet.either as module_0
import builtins as module_1

def test_case_0():
    try:
        callable_0 = None
        str_0 = '\n        Take function and applied this function with monad value and returns new monad with mapped value.\n\n        :params mapper: function to apply on monad value\n        :type mapper: Function(A) -> B\n        :returns: for successfully new Try with mapped value, othercase copy of self\n        :rtype: Try[B]\n        '
        either_0 = module_0.Either(str_0)
        var_0 = either_0.to_lazy()
        var_1 = either_0.case(callable_0, callable_0)
    except BaseException:
        pass

def test_case_1():
    try:
        object_0 = None
        float_0 = 1145.1
        either_0 = module_0.Either(float_0)
        bool_0 = either_0.__eq__(object_0)
        left_0 = module_0.Left(either_0)
        var_0 = left_0.bind(object_0)
        var_1 = either_0.ap(var_0)
        callable_0 = None
        bool_1 = either_0.__eq__(object_0)
        list_0 = []
        either_1 = module_0.Either(list_0)
        either_2 = module_0.Either(either_0)
        left_1 = module_0.Left(either_0)
        var_2 = left_1.bind(list_0)
        var_3 = None
        either_3 = module_0.Either(var_3)
        var_4 = either_1.case(callable_0, callable_0)
    except BaseException:
        pass

def test_case_2():
    try:
        var_0 = None
        either_0 = module_0.Either(var_0)
        str_0 = 'g?nX\'n/"d1:\'K'
        set_0 = {str_0, str_0, str_0, str_0}
        var_1 = either_0.is_right()
        bool_0 = False
        right_0 = module_0.Right(bool_0)
        bytes_0 = b'|\xd2Vm\x1a\xd1\x9a\xbd\xad\xea\xbc\xb9\x08\x1f\x16O\x04\xa6e#'
        var_2 = either_0.to_box()
        bool_1 = right_0.is_right()
        either_1 = module_0.Either(bytes_0)
        var_3 = either_1.case(set_0, right_0)
    except BaseException:
        pass

def test_case_3():
    try:
        var_0 = None
        either_0 = module_0.Either(var_0)
        var_1 = either_0.to_try()
        str_0 = 'g?nX\'n/"d1:\'K'
        set_0 = {str_0, str_0, str_0, str_0}
        var_2 = either_0.is_right()
        bool_0 = False
        right_0 = module_0.Right(bool_0)
        bytes_0 = b'|\xd2Vm\x1a\xd1\x9a\xbd\xad\xea\xbc\xb9\x08\x1f\x16O\x04\xa6e#'
        var_3 = either_0.to_box()
        bool_1 = right_0.is_right()
        either_1 = module_0.Either(bytes_0)
        var_4 = either_1.case(set_0, right_0)
    except BaseException:
        pass

def test_case_4():
    try:
        object_0 = None
        float_0 = 1145.1
        either_0 = module_0.Either(float_0)
        bool_0 = either_0.__eq__(object_0)
        object_1 = module_1.object()
        str_0 = 'vskD\x0c^k:bSG'
        str_1 = '\n        Take function (A) -> B and applied this function on current Validation value.\n\n        :param mapper: mapper function\n        :type mapper: Function(A) -> B\n        :returns: new Validation with mapped value and previous errors\n        :rtype: Validation[B, List[E]]\n        '
        left_0 = module_0.Left(str_1)
        var_0 = left_0.bind(str_0)
        var_1 = None
        either_1 = module_0.Either(var_1)
        var_2 = either_0.case(float_0, either_0)
    except BaseException:
        pass

def test_case_5():
    try:
        float_0 = -3180.0
        either_0 = module_0.Either(float_0)
        bytes_0 = b'3{u'
        left_0 = module_0.Left(bytes_0)
        left_1 = module_0.Left(bytes_0)
        bool_0 = left_1.is_left()
        var_0 = either_0.to_box()
        left_2 = None
        list_0 = [either_0, var_0]
        var_1 = left_2.bind(list_0)
    except BaseException:
        pass

def test_case_6():
    try:
        callable_0 = None
        str_0 = 'Y~{[Jm}{\ro\\$/dx'
        right_0 = module_0.Right(str_0)
        var_0 = right_0.map(callable_0)
    except BaseException:
        pass

def test_case_7():
    try:
        int_0 = 3229
        bool_0 = True
        right_0 = module_0.Right(bool_0)
        var_0 = right_0.bind(int_0)
    except BaseException:
        pass

def test_case_8():
    try:
        var_0 = None
        either_0 = module_0.Either(var_0)
        str_0 = 'g?nX\'n/"dR:\'"'
        set_0 = {str_0, str_0, str_0, str_0}
        bool_0 = False
        right_0 = module_0.Right(bool_0)
        bytes_0 = b'|\xd2Vm\x1a\xd1\x9a\xbd\xad\xea\xbc\xb9\x08\x1f\x16O\x04\xa6e#'
        bool_1 = right_0.is_right()
        either_1 = module_0.Either(bytes_0)
        var_1 = either_1.case(set_0, right_0)
    except BaseException:
        pass

def test_case_9():
    try:
        object_0 = None
        float_0 = 1145.1
        either_0 = module_0.Either(float_0)
        bool_0 = either_0.__eq__(object_0)
        object_1 = module_1.object()
        str_0 = 'vskD\x0c^k:bSG'
        dict_0 = {str_0: str_0}
        right_0 = module_0.Right(dict_0)
        var_0 = right_0.to_maybe()
        str_1 = '\n        Take function (A) -> B and applied this function on current Validation value.\n\n        :param mapper: mapper function\n        :type mapper: Function(A) -> B\n        :returns: new Validation with mapped value and previous errors\n        :rtype: Validation[B, List[E]]\n        '
        left_0 = module_0.Left(str_1)
        bool_1 = right_0.is_right()
        var_1 = right_0.to_validation()
        var_2 = right_0.map(object_1)
    except BaseException:
        pass

def test_case_10():
    try:
        str_0 = 'test_value1'
        either_0 = module_0.Either(str_0)
        either_1 = module_0.Either(str_0)
        str_1 = 'GR7FiM-1\x0bc\n$r=st'
        tuple_0 = (str_1,)
        either_2 = module_0.Either(tuple_0)
        list_0 = None
        float_0 = 3813.11845
        right_0 = module_0.Right(either_0)
        var_0 = right_0.case(list_0, float_0)
    except BaseException:
        pass