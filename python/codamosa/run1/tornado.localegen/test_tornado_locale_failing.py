# Automatically generated by Pynguin.
import tornado.locale as module_0
import gettext as module_1
import datetime as module_2

def test_case_0():
    try:
        str_0 = None
        module_0.load_translations(str_0)
    except BaseException:
        pass

def test_case_1():
    try:
        str_0 = None
        module_0.load_gettext_translations(str_0, str_0)
    except BaseException:
        pass

def test_case_2():
    try:
        str_0 = '9gWq6U^6t[Q;)`7'
        module_0.set_default_locale(str_0)
        float_0 = -1600.0
        int_0 = -2480
        bool_0 = True
        bool_1 = None
        str_1 = '`/Ypan\n`'
        list_0 = [str_1]
        locale_0 = module_0.get(*list_0)
        str_2 = locale_0.format_date(float_0, int_0, bool_0, bool_1)
        str_3 = "The XSRF-prevention token for the current user/session.\n\n        To prevent cross-site request forgery, we set an '_xsrf' cookie\n        and include the same '_xsrf' value as an argument with all POST\n        requests. If the two do not match, we reject the form submission\n        as a potential forgery.\n\n        See http://en.wikipedia.org/wiki/Cross-site_request_forgery\n\n        This property is of type `bytes`, but it contains only ASCII\n        characters. If a character string is required, there is no\n        need to base64-encode it; just decode the byte string as\n        UTF-8.\n\n        .. versionchanged:: 3.2.2\n           The xsrf token will now be have a random mask applied in every\n           request, which makes it safe to include the token in pages\n           that are compressed.  See http://breachattack.com for more\n           information on the issue fixed by this change.  Old (version 1)\n           cookies will be converted to version 2 when this method is called\n           unless the ``xsrf_cookie_version`` `Application` setting is\n           set to 1.\n\n        .. versionchanged:: 4.3\n           The ``xsrf_cookie_kwargs`` `Application` setting may be\n           used to supply additional cookie options (which will be\n           passed directly to `set_cookie`). For example,\n           ``xsrf_cookie_kwargs=dict(httponly=True, secure=True)``\n           will set the ``secure`` and ``httponly`` flags on the\n           ``_xsrf`` cookie.\n        "
        str_4 = None
        list_1 = [str_3, str_4, str_4]
        locale_1 = module_0.get(*list_1)
        str_5 = locale_1.translate(str_0, str_0)
    except BaseException:
        pass

def test_case_3():
    try:
        int_0 = -2734
        str_0 = 'S*W?o\x0cL*>-J%6'
        str_1 = ':yt>('
        list_0 = [str_0, str_0, str_1]
        locale_0 = module_0.get(*list_0)
        str_2 = locale_0.friendly_number(int_0)
        locale_1 = module_0.get()
        str_3 = 'E>X%sCJ|1\\\x0bL5f'
        null_translations_0 = None
        gettext_locale_0 = module_0.GettextLocale(str_3, null_translations_0)
    except BaseException:
        pass

def test_case_4():
    try:
        locale_0 = module_0.get()
    except BaseException:
        pass

def test_case_5():
    try:
        str_0 = '^9'
        locale_0 = module_0.get()
        str_1 = locale_0.translate(str_0, str_0)
    except BaseException:
        pass

def test_case_6():
    try:
        str_0 = '{'
        locale_0 = module_0.Locale(str_0)
    except BaseException:
        pass

def test_case_7():
    try:
        bytes_0 = b'\x81M\x02G0O\x06\xac{!'
        str_0 = ''
        str_1 = '#j3GE5owK&X}'
        str_2 = 'R%h'
        str_3 = '^C$"'
        dict_0 = {}
        dict_1 = {str_3: dict_0, str_3: dict_0, str_0: dict_0, str_3: dict_0}
        c_s_v_locale_0 = module_0.CSVLocale(str_3, dict_1)
        str_4 = c_s_v_locale_0.pgettext(str_2, str_2)
        str_5 = ',Kz3},B\\`I1I'
        null_translations_0 = module_1.NullTranslations()
        gettext_locale_0 = module_0.GettextLocale(str_5, null_translations_0)
        str_6 = gettext_locale_0.translate(str_1)
        list_0 = [str_0, str_1]
        locale_0 = module_0.get(*list_0)
        str_7 = locale_0.list(bytes_0)
    except BaseException:
        pass

def test_case_8():
    try:
        str_0 = '\x0c~/A?iO:m'
        int_0 = -197
        str_1 = '$73Nyjt\tY'
        list_0 = [str_1]
        null_translations_0 = module_1.NullTranslations(list_0)
        gettext_locale_0 = module_0.GettextLocale(str_1, null_translations_0)
        str_2 = gettext_locale_0.translate(str_0, str_0, int_0)
        str_3 = '[IHkJr{vzp/}hJJ+Jw-'
        locale_0 = module_0.Locale(str_3)
    except BaseException:
        pass

def test_case_9():
    try:
        str_0 = '9gWq6U^6t[Q;)`7'
        iterable_0 = module_0.get_supported_locales()
        module_0.set_default_locale(str_0)
        float_0 = -1600.0
        int_0 = -2480
        bool_0 = True
        bool_1 = None
        null_translations_0 = module_1.NullTranslations()
        gettext_locale_0 = module_0.GettextLocale(str_0, null_translations_0)
        str_1 = gettext_locale_0.pgettext(str_0, str_0)
        str_2 = '`/Ypan\n`'
        int_1 = 3003
        locale_0 = module_0.get()
        list_0 = [str_2]
        locale_1 = module_0.get(*list_0)
        str_3 = locale_1.format_date(float_0, int_0, bool_0, bool_1)
        str_4 = locale_1.format_date(int_1)
        str_5 = locale_1.list(str_0)
        int_2 = 2103
        str_6 = locale_1.friendly_number(int_2)
        null_translations_1 = module_1.NullTranslations()
        str_7 = gettext_locale_0.translate(str_6)
        str_8 = "Executes a request, asynchronously returning an `HTTPResponse`.\n\n        The request may be either a string URL or an `HTTPRequest` object.\n        If it is a string, we construct an `HTTPRequest` using any additional\n        kwargs: ``HTTPRequest(request, **kwargs)``\n\n        This method returns a `.Future` whose result is an\n        `HTTPResponse`. By default, the ``Future`` will raise an\n        `HTTPError` if the request returned a non-200 response code\n        (other errors may also be raised if the server could not be\n        contacted). Instead, if ``raise_error`` is set to False, the\n        response will always be returned regardless of the response\n        code.\n\n        If a ``callback`` is given, it will be invoked with the `HTTPResponse`.\n        In the callback interface, `HTTPError` is not automatically raised.\n        Instead, you must check the response's ``error`` attribute or\n        call its `~HTTPResponse.rethrow` method.\n\n        .. versionchanged:: 6.0\n\n           The ``callback`` argument was removed. Use the returned\n           `.Future` instead.\n\n           The ``raise_error=False`` argument only affects the\n           `HTTPError` raised when a non-200 response code is used,\n           instead of suppressing all errors.\n        "
        gettext_locale_1 = module_0.GettextLocale(str_8, null_translations_0)
        str_9 = 'y'
        str_10 = gettext_locale_1.translate(str_9, int_0)
    except BaseException:
        pass

def test_case_10():
    try:
        str_0 = '[7<V`[L$cq^@6:o5'
        module_0.set_default_locale(str_0)
        float_0 = -1600.0
        int_0 = -2480
        bool_0 = True
        str_1 = 'E'
        list_0 = [str_1]
        locale_0 = module_0.get(*list_0)
        str_2 = locale_0.format_date(float_0, int_0, bool_0, bool_0)
        null_translations_0 = module_1.NullTranslations()
        str_3 = "The XSRF-prevention token for the current user/session.\n\n        To prevent cross-site request forgery, we set an '_xsrf' cookie\n        and include the same '_xsrf' value as an argument with all POST\n        requests. If the two do not match, we reject the form submission\n        as a potential forgery.\n\n        See http://en.wikipedia.org/wiki/Cross-site_request_forgery\n\n        This property is of type `bytes`, but it contains only ASCII\n        characters. If a character string is required, there is no\n        need to base64-encode it; just decode the byte string as\n        UTF-8.\n\n        .. versionchanged:: 3.2.2\n           The xsrf token will now be have a random mask applied in every\n           request, which makes it safe to include the token in pages\n           that are compressed.  See http://breachattack.com for more\n           information on the issue fixed by this change.  Old (version 1)\n           cookies will be converted to version 2 when this method is called\n           unless the ``xsrf_cookie_version`` `Application` setting is\n           set to 1.\n\n        .. versionchanged:: 4.3\n           The ``xsrf_cookie_kwargs`` `Application` setting may be\n           used to supply additional cookie options (which will be\n           passed directly to `set_cookie`). For example,\n           ``xsrf_cookie_kwargs=dict(httponly=True, secure=True)``\n           will set the ``secure`` and ``httponly`` flags on the\n           ``_xsrf`` cookie.\n        "
        str_4 = None
        list_1 = [str_3, str_4, str_4]
        locale_1 = module_0.get(*list_1)
        str_5 = locale_1.translate(str_0, str_0)
    except BaseException:
        pass

def test_case_11():
    try:
        str_0 = '<Rs'
        iterable_0 = module_0.get_supported_locales()
        module_0.set_default_locale(str_0)
        float_0 = -1600.0
        int_0 = -2480
        bool_0 = False
        bool_1 = None
        null_translations_0 = module_1.NullTranslations()
        gettext_locale_0 = module_0.GettextLocale(str_0, null_translations_0)
        str_1 = gettext_locale_0.pgettext(str_0, str_0)
        str_2 = '`/Ypan\n`'
        list_0 = [str_2]
        locale_0 = module_0.get(*list_0)
        str_3 = locale_0.format_date(float_0, int_0, bool_0, bool_1)
        str_4 = 'PYD'
        str_5 = gettext_locale_0.pgettext(str_0, str_4, int_0)
    except BaseException:
        pass

def test_case_12():
    try:
        str_0 = '9gWq6U^6t[Q;)`7'
        iterable_0 = module_0.get_supported_locales()
        module_0.set_default_locale(str_0)
        list_0 = []
        locale_0 = module_0.get(*list_0)
        float_0 = -1600.0
        int_0 = -2480
        bool_0 = True
        bool_1 = None
        str_1 = '`/Ypan\n`'
        list_1 = [str_1]
        locale_1 = module_0.get(*list_1)
        str_2 = locale_1.format_date(float_0, int_0, bool_0, bool_1)
        locale_2 = module_0.get(*list_1)
        int_1 = -3084
        str_3 = locale_0.format_date(float_0, int_1, bool_0)
        str_4 = locale_2.list(list_0)
        datetime_0 = module_2.datetime()
    except BaseException:
        pass

def test_case_13():
    try:
        str_0 = 'D_.pz=.?CrrT4'
        str_1 = "*<tdIl:'J"
        str_2 = '%|\x0cb{'
        str_3 = '71wL9{p>7K3J_?'
        bool_0 = True
        dict_0 = {}
        dict_1 = {str_0: dict_0, str_0: dict_0}
        c_s_v_locale_0 = module_0.CSVLocale(str_0, dict_1)
        str_4 = c_s_v_locale_0.pgettext(str_1, str_2, str_3, bool_0)
        float_0 = -1600.0
        int_0 = -2480
        bool_1 = True
        bool_2 = None
        str_5 = '`/Ypan\n`'
        list_0 = [str_5]
        locale_0 = module_0.get(*list_0)
        locale_1 = module_0.get()
        str_6 = locale_0.format_date(float_0, int_0, bool_1, bool_2)
        str_7 = locale_0.list(str_0)
        str_8 = locale_0.friendly_number(int_0)
        str_9 = locale_0.translate(str_5, str_5)
    except BaseException:
        pass

def test_case_14():
    try:
        str_0 = '<%s'
        iterable_0 = module_0.get_supported_locales()
        module_0.set_default_locale(str_0)
        float_0 = -1600.0
        int_0 = -2480
        bool_0 = True
        bool_1 = None
        null_translations_0 = module_1.NullTranslations()
        gettext_locale_0 = module_0.GettextLocale(str_0, null_translations_0)
        str_1 = gettext_locale_0.pgettext(str_0, str_0)
        str_2 = '`/Ypan\n`'
        list_0 = [str_2]
        locale_0 = module_0.get(*list_0)
        str_3 = locale_0.format_date(float_0, int_0, bool_0, bool_1)
        locale_1 = module_0.get()
        int_1 = 3233
        bool_2 = True
        bool_3 = False
        str_4 = locale_1.format_date(float_0, int_1, bool_2, bool_3, bool_2)
        str_5 = locale_0.list(str_0)
        null_translations_1 = module_1.NullTranslations(float_0)
        str_6 = 'foo'
        gettext_locale_1 = module_0.GettextLocale(str_6, null_translations_1)
        module_0.load_gettext_translations(str_4, str_2)
    except BaseException:
        pass

def test_case_15():
    try:
        str_0 = '&J~eg\x0cW`Dz~>\\x%q8f A'
        float_0 = -1600.0
        int_0 = -2480
        iterable_0 = module_0.get_supported_locales()
        bool_0 = False
        bool_1 = None
        str_1 = '`/Ypan\n`'
        null_translations_0 = module_1.NullTranslations()
        gettext_locale_0 = module_0.GettextLocale(str_0, null_translations_0)
        locale_0 = module_0.get()
        str_2 = locale_0.pgettext(str_1, str_0)
        str_3 = None
        str_4 = gettext_locale_0.pgettext(str_3, str_3)
        list_0 = [str_1]
        locale_1 = module_0.get(*list_0)
        str_5 = locale_1.format_date(float_0, int_0, bool_0, bool_1)
        locale_2 = module_0.get()
        datetime_0 = None
        str_6 = locale_0.format_date(datetime_0, bool_0)
    except BaseException:
        pass

def test_case_16():
    try:
        iterable_0 = module_0.get_supported_locales()
        null_translations_0 = module_1.NullTranslations()
        str_0 = 'N2z4^V5O3K)gbQ'
        str_1 = '{Y;8(x/^SDT )Qo'
        str_2 = 'Sets the given response header name and value.\n\n        All header values are converted to strings (`datetime` objects\n        are fomatted according to the HTTP specification for the\n        ``Date`` header).\n\n        '
        str_3 = 'JU~$d%'
        dict_0 = {str_2: str_3}
        str_4 = 'opO_w6%A5XXOO4H@6b\n/'
        dict_1 = {str_1: dict_0, str_4: dict_0}
        c_s_v_locale_0 = module_0.CSVLocale(str_0, dict_1)
        list_0 = [str_4]
        locale_0 = module_0.get(*list_0)
        locale_1 = module_0.get(*list_0)
        datetime_0 = None
        bool_0 = locale_0.format_day(datetime_0)
    except BaseException:
        pass

def test_case_17():
    try:
        str_0 = 'hen'
        int_0 = 123456784
        module_0.set_default_locale(str_0)
        locale_0 = module_0.get()
        int_1 = 123456
        bool_0 = True
        locale_1 = module_0.get()
        str_1 = locale_1.format_date(int_0, int_1, bool_0)
        str_2 = None
        int_2 = None
        str_3 = locale_0.friendly_number(int_2)
        module_0.load_translations(str_2)
    except BaseException:
        pass

def test_case_18():
    try:
        str_0 = 'en'
        int_0 = 123456776
        module_0.set_default_locale(str_0)
        locale_0 = module_0.get()
        str_1 = 'en_US'
        str_2 = locale_0.pgettext(str_0, str_1)
        int_1 = 123456
        str_3 = locale_0.format_date(int_0)
        locale_1 = module_0.get()
        bool_0 = None
        str_4 = locale_1.format_date(int_0, int_1, bool_0)
        int_2 = 123
        str_5 = '_AC[ggMTDz9'
        list_0 = [str_5, str_4, str_1]
        locale_2 = module_0.get(*list_0)
        str_6 = None
        str_7 = locale_2.friendly_number(int_2)
        module_0.load_translations(str_6)
    except BaseException:
        pass

def test_case_19():
    try:
        str_0 = 'zh_CN'
        int_0 = 123456784
        module_0.set_default_locale(str_0)
        locale_0 = module_0.get()
        str_1 = 'n!|ll@CdceAjG'
        str_2 = locale_0.pgettext(str_0, str_1)
        int_1 = 1234569
        str_3 = locale_0.format_date(int_0)
        bool_0 = None
        str_4 = locale_0.format_date(int_0, int_0, bool_0)
        str_5 = '_AC[ggMTDz9'
        list_0 = [str_5, str_4]
        locale_1 = module_0.get(*list_0)
        str_6 = None
        str_7 = locale_1.friendly_number(int_1)
        module_0.load_translations(str_6)
    except BaseException:
        pass