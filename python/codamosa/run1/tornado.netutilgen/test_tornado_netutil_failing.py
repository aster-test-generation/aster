# Automatically generated by Pynguin.
import tornado.netutil as module_0
import ssl as module_1
import socket as module_2
import concurrent.futures._base as module_3

def test_case_0():
    try:
        int_0 = None
        list_0 = module_0.bind_sockets(int_0, int_0, int_0)
    except BaseException:
        pass

def test_case_1():
    try:
        str_0 = 'D/'
        socket_0 = module_0.bind_unix_socket(str_0)
    except BaseException:
        pass

def test_case_2():
    try:
        str_0 = '&{DWr\\+%)*^JkVi'
        int_0 = 2092
        socket_0 = module_0.bind_unix_socket(str_0, int_0)
        str_1 = '``AsyncIOLoop`` is an `.IOLoop` that runs on an ``asyncio`` event loop.\n    This class follows the usual Tornado semantics for creating new\n    ``IOLoops``; these loops are not necessarily related to the\n    ``asyncio`` default event loop.\n\n    Each ``AsyncIOLoop`` creates a new ``asyncio.EventLoop``; this object\n    can be accessed with the ``asyncio_loop`` attribute.\n\n    .. versionchanged:: 5.0\n\n       When an ``AsyncIOLoop`` becomes the current `.IOLoop`, it also sets\n       the current `asyncio` event loop.\n\n    .. deprecated:: 5.0\n\n       Now used automatically when appropriate; it is no longer necessary\n       to refer to this class directly.\n    '
        callable_0 = module_0.add_accept_handler(socket_0, str_1)
    except BaseException:
        pass

def test_case_3():
    try:
        blocking_resolver_0 = module_0.BlockingResolver()
    except BaseException:
        pass

def test_case_4():
    try:
        str_0 = ''
        bool_0 = module_0.is_valid_ip(str_0)
        str_1 = 'PYCR$$kG\rW\x0bm<I\x0bT'
        str_2 = 'V@m<EO}AX1d]fh'
        str_3 = '8U'
        dict_0 = {str_2: str_1, str_3: bool_0}
        resolver_0 = module_0.Resolver(**dict_0)
    except BaseException:
        pass

def test_case_5():
    try:
        dict_0 = {}
        s_s_l_context_0 = module_0.ssl_options_to_context(dict_0)
        threaded_resolver_0 = module_0.ThreadedResolver()
    except BaseException:
        pass

def test_case_6():
    try:
        threaded_resolver_0 = module_0.ThreadedResolver()
    except BaseException:
        pass

def test_case_7():
    try:
        str_0 = None
        dict_0 = {str_0: str_0, str_0: str_0}
        s_s_l_context_0 = module_0.ssl_options_to_context(dict_0)
    except BaseException:
        pass

def test_case_8():
    try:
        int_0 = 80
        list_0 = module_0.bind_sockets(int_0)
    except BaseException:
        pass

def test_case_9():
    try:
        str_0 = None
        socket_0 = module_0.bind_unix_socket(str_0)
    except BaseException:
        pass

def test_case_10():
    try:
        str_0 = "'ih1lXJ"
        socket_0 = module_0.bind_unix_socket(str_0)
        int_0 = 80
        int_1 = -2035
        bool_0 = False
        list_0 = module_0.bind_sockets(int_1, str_0, int_1, int_0, bool_0)
    except BaseException:
        pass

def test_case_11():
    try:
        s_s_l_context_0 = None
        s_s_l_context_1 = module_0.ssl_options_to_context(s_s_l_context_0)
    except BaseException:
        pass

def test_case_12():
    try:
        str_0 = "'ih1lXJ"
        int_0 = 380
        socket_0 = module_0.bind_unix_socket(str_0, int_0)
        list_0 = [socket_0, str_0]
        override_resolver_0 = module_0.OverrideResolver(*list_0)
        int_1 = None
        list_1 = module_0.bind_sockets(int_1, str_0)
    except BaseException:
        pass

def test_case_13():
    try:
        str_0 = '|QBwUVn][)5'
        dict_0 = {}
        s_s_l_context_0 = module_0.ssl_options_to_context(dict_0)
        s_s_l_context_1 = module_1.SSLContext()
        list_0 = [str_0, str_0]
        override_resolver_0 = module_0.OverrideResolver(*list_0)
        override_resolver_1 = module_0.OverrideResolver(*list_0)
        override_resolver_1.close()
    except BaseException:
        pass

def test_case_14():
    try:
        str_0 = '5]==S8OeY#N\r*eA\x0b;A'
        bool_0 = module_0.is_valid_ip(str_0)
        address_family_0 = module_2.AddressFamily.AF_IPX
        int_0 = -145
        int_1 = 999
        str_1 = ''
        bool_1 = True
        list_0 = module_0.bind_sockets(int_1, str_1, address_family_0, int_0, int_1, bool_1)
    except BaseException:
        pass

def test_case_15():
    try:
        s_s_l_context_0 = module_1.SSLContext()
        str_0 = '.O9{Q4||""CQicrY/'
        bool_0 = module_0.is_valid_ip(str_0)
    except BaseException:
        pass

def test_case_16():
    try:
        str_0 = '5]==S8OeY#N\r*eA\x0b;A'
        bool_0 = module_0.is_valid_ip(str_0)
        address_family_0 = module_2.AddressFamily.AF_IPX
        int_0 = -145
        int_1 = 999
        str_1 = ''
        bool_1 = False
        list_0 = module_0.bind_sockets(int_1, str_1, address_family_0, int_0, int_1, bool_1)
    except BaseException:
        pass

def test_case_17():
    try:
        resolver_0 = module_0.Resolver()
        str_0 = '/etc/resolv.conf'
        socket_0 = module_0.bind_unix_socket(str_0)
    except BaseException:
        pass

def test_case_18():
    try:
        str_0 = '31'
        dict_0 = {}
        s_s_l_context_0 = module_0.ssl_options_to_context(dict_0)
        int_0 = 1435
        bool_0 = module_0.is_valid_ip(str_0)
        list_0 = module_0.bind_sockets(int_0)
    except BaseException:
        pass

def test_case_19():
    try:
        str_0 = 'www.google.com'
        int_0 = 443
        list_0 = module_0.bind_sockets(int_0, str_0)
    except BaseException:
        pass

def test_case_20():
    try:
        future_0 = module_3.Future()
        str_0 = 'V|E'
        int_0 = 3455
        list_0 = [future_0, future_0]
        override_resolver_0 = module_0.OverrideResolver(*list_0)
        awaitable_0 = override_resolver_0.resolve(str_0, int_0)
    except BaseException:
        pass

def test_case_21():
    try:
        int_0 = 0
        list_0 = module_0.bind_sockets(int_0)
        var_0 = len(list_0)
        int_1 = 1
        var_1 = list_0[int_0]
        var_2 = var_3.getsockname()[int_1]
    except BaseException:
        pass