# Automatically generated by Pynguin.
import isort.exceptions as module_0
import builtins as module_1

def test_case_0():
    str_0 = '*.{py}'
    assignments_format_mismatch_0 = module_0.AssignmentsFormatMismatch(str_0)
    str_1 = 'fK:i[gZ'
    str_2 = '0b~QP`"J/\\\\2_3"}<e\\'
    existing_syntax_errors_0 = module_0.ExistingSyntaxErrors(str_2)
    invalid_settings_path_0 = module_0.InvalidSettingsPath(str_1)
    i_sort_error_0 = module_0.ISortError()

def test_case_1():
    str_0 = '__name__'
    existing_syntax_errors_0 = module_0.ExistingSyntaxErrors(str_0)

def test_case_2():
    str_0 = None
    profile_does_not_exist_0 = module_0.ProfileDoesNotExist(str_0)
    introduced_syntax_errors_0 = module_0.IntroducedSyntaxErrors(str_0)
    str_1 = "(q'p9_aX# j/0sGIbT("
    formatting_plugin_does_not_exist_0 = module_0.FormattingPluginDoesNotExist(str_1)

def test_case_3():
    type_0 = None
    str_0 = '1]#ox14oqq0f`@>dU*Tk'
    file_skip_setting_0 = module_0.FileSkipSetting(str_0)
    literal_sort_type_mismatch_0 = module_0.LiteralSortTypeMismatch(type_0, type_0)

def test_case_4():
    str_0 = '+=$0!~GAxK*a~0O$0'
    unsupported_encoding_0 = module_0.UnsupportedEncoding(str_0)
    str_1 = 'CtO=M=Nay`\x0cCgx:rFaM'
    invalid_settings_path_0 = module_0.InvalidSettingsPath(str_1)
    existing_syntax_errors_0 = module_0.ExistingSyntaxErrors(str_0)
    file_skip_comment_0 = module_0.FileSkipComment(str_1)
    str_2 = "Q;tZ'%HU@0~2hb2|"
    formatting_plugin_does_not_exist_0 = module_0.FormattingPluginDoesNotExist(str_2)
    str_3 = ' raise FrozenInstanceError(f"cannot delete field {name!r}")'
    file_skipped_0 = module_0.FileSkipped(str_3, str_3)

def test_case_5():
    type_0 = None
    literal_sort_type_mismatch_0 = module_0.LiteralSortTypeMismatch(type_0, type_0)
    str_0 = 'wu9^'
    assignments_format_mismatch_0 = module_0.AssignmentsFormatMismatch(str_0)
    profile_does_not_exist_0 = module_0.ProfileDoesNotExist(str_0)
    str_1 = 'C{^'
    str_2 = 'Qb&<v/s'
    str_3 = 'i"}x(vO8NWvg4\nqb9|V\n'
    file_skipped_0 = module_0.FileSkipped(str_2, str_3)
    exception_0 = module_1.Exception()
    str_4 = ' s ZTN"qY^/[v@<%,8'
    literal_parsing_failure_0 = module_0.LiteralParsingFailure(str_4, exception_0)
    literal_parsing_failure_1 = module_0.LiteralParsingFailure(str_1, exception_0)
    profile_does_not_exist_1 = module_0.ProfileDoesNotExist(str_1)
    formatting_plugin_does_not_exist_0 = module_0.FormattingPluginDoesNotExist(str_1)

def test_case_6():
    str_0 = 'U NS'
    dict_0 = {}
    unsupported_settings_0 = module_0.UnsupportedSettings(dict_0)
    unsupported_encoding_0 = module_0.UnsupportedEncoding(str_0)
    str_1 = '"'
    str_2 = '^'
    profile_does_not_exist_0 = module_0.ProfileDoesNotExist(str_2)
    assignments_format_mismatch_0 = module_0.AssignmentsFormatMismatch(str_1)

def test_case_7():
    str_0 = ' is declared with init=False, it cannot be specified with replace()'
    missing_section_0 = module_0.MissingSection(str_0, str_0)
    str_1 = "Return the fields of a dataclass instance as a new tuple of field values.\n    Example usage::\n      @dataclass\n      class C:\n          x: int\n          y: int\n    c = C(1, 2)\n    assert astuple(c) == (1, 2)\n    If given, 'tuple_factory' will be used instead of built-in tuple.\n    The function applies recursively to field values that are\n    dataclass instances. This will also look into built-in containers:\n    tuples, lists, and dicts.\n    "
    file_skip_setting_0 = module_0.FileSkipSetting(str_1)
    file_skip_setting_1 = module_0.FileSkipSetting(str_0)

def test_case_8():
    str_0 = 'line_length'
    str_1 = 'indent'
    str_2 = 'value'
    str_3 = 'source'
    int_0 = 42
    str_4 = 'config'
    var_0 = {str_2: int_0, str_3: str_4}
    str_5 = '    '
    str_6 = 'runtime'
    str_7 = {str_2: str_5, str_3: str_6}
    var_1 = {str_0: var_0, str_1: str_7}
    unsupported_settings_0 = module_0.UnsupportedSettings(var_1)