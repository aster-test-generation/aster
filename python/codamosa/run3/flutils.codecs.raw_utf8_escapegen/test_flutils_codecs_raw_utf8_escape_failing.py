# Automatically generated by Pynguin.
import flutils.codecs.raw_utf8_escape as module_0
import codecs as module_1
import collections as module_2

def test_case_0():
    try:
        str_0 = None
        tuple_0 = module_0.encode(str_0)
    except BaseException:
        pass

def test_case_1():
    try:
        str_0 = "The given 'command' must be of type: str, List[str] or Tuple[str]."
        tuple_0 = module_0.encode(str_0)
        bytes_0 = b'\x93\xa6\x00\xe2c6\xd2\x9e\x10\x81\x10'
        tuple_1 = module_0.decode(bytes_0)
    except BaseException:
        pass

def test_case_2():
    try:
        list_0 = None
        tuple_0 = module_0.decode(list_0)
    except BaseException:
        pass

def test_case_3():
    try:
        module_0.register()
        bool_0 = True
        tuple_0 = module_0.decode(bool_0)
    except BaseException:
        pass

def test_case_4():
    try:
        str_0 = 'eutf8h'
        var_0 = module_1.getdecoder(str_0)
    except BaseException:
        pass

def test_case_5():
    try:
        tuple_0 = ()
        module_0.register()
        tuple_1 = module_0.decode(tuple_0)
        tuple_2 = module_0.decode(tuple_1)
    except BaseException:
        pass

def test_case_6():
    try:
        dict_0 = {}
        user_string_0 = module_2.UserString(dict_0)
        tuple_0 = module_0.encode(user_string_0)
        bytes_0 = b'w\xda\x17qu\xab'
        str_0 = 'C=-TOE>B=mk9-\r6'
        tuple_1 = module_0.decode(bytes_0, str_0)
    except BaseException:
        pass

def test_case_7():
    try:
        str_0 = "Change the mode of a path.\n\n    This function processes the given ``path`` with\n    :obj:`~flutils.normalize_path`.\n\n    If the given ``path`` does NOT exist, nothing will be done.\n\n    This function will **NOT** change the mode of:\n\n    - symlinks (symlink targets that are files or directories will be changed)\n    - sockets\n    - fifo\n    - block devices\n    - char devices\n\n    Args:\n        path (:obj:`str`, :obj:`bytes` or :obj:`Path <pathlib.Path>`):\n            The path of the file or directory to have it's mode changed.  This\n            value can be a :term:`glob pattern`.\n        mode_file (:obj:`int`, optional): The mode applied to the given\n            ``path`` that is a file or a symlink target that is a file.\n            Defaults to ``0o600``.\n        mode_dir (:obj:`int`, optional): The mode applied to the given\n            ``path`` that is a directory or a symlink target that is a\n            directory. Defaults to ``0o700``.\n        include_parent (:obj:`bool`, optional): A value of :obj:`True`` will\n            chmod the parent directory of the given ``path`` that contains a\n            a :term:`glob pattern`.  Defaults to :obj:`False`.\n\n    :rtype: :obj:`None`\n\n    Examples:\n        >>> from flutils.pathutils import chmod\n        >>> chmod('~/tmp/flutils.tests.osutils.txt', 0o660)\n\n        Supports a :term:`glob pattern`.  So to recursively change the mode\n        of a directory just do:\n\n        >>> chmod('~/tmp/**', mode_file=0o644, mode_dir=0o770)\n\n        To change the mode of a directory's immediate contents:\n\n        >>> chmod('~/tmp/*')\n\n    "
        module_0.register()
        tuple_0 = module_0.encode(str_0)
        bytes_0 = b'P\xe5\xe8\x13\x97\x8e'
        user_string_0 = module_2.UserString(bytes_0)
        tuple_1 = module_0.encode(user_string_0)
    except BaseException:
        pass

def test_case_8():
    try:
        bytes_0 = b'\x7f[\x8d\x11\x94m\xd9I\xd1|\xa7}\xd6\xf6\xc7.\xd4!\x00'
        int_0 = 1409
        tuple_0 = (bytes_0, int_0)
        list_0 = [tuple_0, bytes_0]
        user_string_0 = module_2.UserString(list_0)
        tuple_1 = module_0.encode(user_string_0, user_string_0)
    except BaseException:
        pass

def test_case_9():
    try:
        bytes_0 = b's\xdc\x95\x02\x1f\x10'
        user_string_0 = module_2.UserString(bytes_0)
        tuple_0 = module_0.encode(user_string_0)
        byte_string_0 = None
        module_0.register()
        tuple_1 = module_0.decode(byte_string_0)
    except BaseException:
        pass